附加知识点
菜鸟网：https://www.runoob.com/  
Rpmfind镜像：http://rpmfind.net/
Linux内核：https://www.kernel.org/
Shell 基础：https://www.runoob.com/linux/linux-shell-basic-operators.html

********目录********
---top动态查看系统负荷
---Linux设置与网络同步的时间
---重置linux网卡流量统计
---Linux下简单的磁盘报警脚本/crontab无法获取变量
---CentOS7禁止ping和允许ping
---Linux清屏命令(3种方式）
---CentOS添加开机自启动命令和脚本
---修改dns地址
---Centos查看外网IP
---ssh远程linux服务器时不需要输入密码
---centos查看目录或文件占用最大的硬盘空间
---看远程连接到centos服务器的ip地址 
---shell中实现字符串反转的三种简单方法
---shell字符串大小写转换
---Linux 查看哪些IP正在远程服务器和查看近期远程情况
---shell 中的 set -e 和 set +e的区别
---Shell去除空行的4种方法
---shell中脚本之间函数的调用
---base64 加密解密文本或文件
---crontab 配置文件
---rsync+SSH同步文件指定服务器端口
---列出最新时间的文件排在最前
---Linux 设置静态IP
---Linux系统盘扩容
---查看服务器系统版本信息
---在Linux服务器上部署禅道
---利用yum下载软件包的三种方法
---sed以变量的方式删除文件内容
---linux shell 用sed命令在文本的行尾或行首添加字符
---Centos7 使用chrony做时间同步
---awk根据指定的字符串分割字符串
---Centos7 最小化安装后网络链接配置
---Linux中查看开启了哪些服务的命令
---Nginx添加多个站点或网站
---Nginx隐藏转发的端口号
---nginx设置成服务并开机自动启动
---nginx的日志切割
---Centos7开放及查看端口
---查看swap内存被哪些进程占用
---监控(glances)
---CentOS_7 时间与网络时间同步
---配置GRE VPN(配置Linux服务器不同网段的实现成内网通讯)
---在线解密解密暴力破解md5
---CentOS 7安全加固
---zabbix忘记登录密码重置方法
---一次输出多列
---Linux scp命令
---写入硬件时间
---统计Apache或nginx日志里访问次数最多的前十个IP
---Linux查看进程启动及运行时间
---Shell中去除字符串前后空格的方法
---查看内存、交换分区、磁盘、CPU信息和网卡
---邮件服务
---Linux系统优化
---所有端口的文件
---Linux安装tab命令补全
---Linux CentOS7安装并启动Google(谷歌)浏览器
---将两个或多个目录或文件绑定成一个文件夹(文件内容同步和目录同步)(临时的，重启系统后失效)
---Ubuntu安装包命令
---查看命令对应的包、所有进程、文件类型和命令所在目录
---vim的窗口切换(分屏)
---ssh远程执行多行的命令
---linux的远程端口修改方法
---配置无密码SSH连接和显示日历表
---查看目录数型结构
---添加网关的命令
---限制IP SSH(远程) 登录
########以上是新增知识点########
---IP地址的分类
---IP地址由网络位与主机位，两部来组成
---Linux系统简介
---CentOS,社区企业操作系统
---Linux基本操作
---查看及切换目录
---真机列出CPU处理器信息
---可以永久设置主机名与IP地址与子网掩码与网关地址与DNS服务器地址
---创建文档
---如何编写命令行
---命令行的一般格式
---快速编辑技巧
---mount挂载操作:　让目录成为设备的访问点
---目录和文件管理
---ls 列出文档及属性
---使用通配符
---别名的定义:简化复杂的命令
---mkdir 创建目录
---mv 移动/改名
---cp 复制
---使用vim创建/修改文件内容
---重定向输出操作：将前面命令的输出，写入到后面文本文件中
---管理用户和组
---设置登录密码
---用户密码信息存放在 /etc/shadow 文件
---修改用户属性
---删除用户
---管理组账号
---删除组
---tar备份与恢复
---权限和归属
---查看权限
---设置基本权限
---设置文档归属
---附加权限（特殊权限）
---acl访问控制列表(ACL策略)
---查看权限
---软件包管理(wget)
---导入新的红帽签名
---升级Linux内核
---Yum软件包管理
---分区规划及使用
---永久挂载（开机自动挂载）
---综合分区，/dev/vdb继续分区
---rpm包管理器
---逻辑卷的制作
---逻辑卷的使用
---逻辑卷的扩展
---卷组划分空间的单位:PE 
---逻辑卷的删除
---find高级使用
---type 类型(l快捷方式、d目录、f文本文件)
---find扩展使用
---查看当前系统时间:date
---NTP时间同步
---cron计划任务
---卷组没有足够空间
---家目录漫游
---重定向输出操作：将前面命令的输出，写入到后面文本文件中
---管道操作:连接或桥梁
---新建逻辑卷
---创建卷组: vgcreate 卷组名 空闲分区
---创建逻辑卷: lvcreate -L 大小 -n 名称 卷组名
---逻辑卷的扩展
---Shell脚本基础
---条件测试
---if选择结构
---if多分支处理
---for循环结构:解决反复执行重复性的操作
---Shell的使用方式
---Shell脚本创建用户
---Shell使用变量
---read交互
---shell预定义变量
---shell：if条件
---shell：比较整数大小
---shell：字符串对比
---shell：if选择条件
---shell：if多分支处理
---for循环结构: 反复执行类似的操作
---配置用户环境
---防火墙策略管理
---防火墙策略(firewall)
---防火墙默认区域的修改(firewall)
---永久的防火墙规则  永久(permanent)
---SELinux运行模式的切换
---alias别名设置
---搭建基本Web服务
---搭建FTP服务
---拒绝别人远程自己
---防火墙默认区域修改
---永久的防火墙规则
---端口转发(firewall):
---触发挂载
---swap分区(交换分区)
---iSCSI服务基础
---iptables基本管理


========
top动态查看系统负荷

[root@web ~]# top -n 1  #显示后退出

[root@web ~]# top -n 1 |grep Cpu  #获取cpu占用情况
Cpu(s):  1.9%us,  1.3%sy,  0.0%ni, 95.9%id,  0.6%wa,  0.1%hi,  0.2%si,  0.0%st
解释：
1.9%us是用户占用cpu情况
1.3%sy是系统占用cpu情况
得到具体列的值：
[root@web ~]# top -n 1 |grep Cpu | cut -d "," -f 1 | cut -d ":" -f 2 
1.9%us
[root@web ~]# top -n 1 |grep Cpu | cut -d "," -f 2
1.3%sy

[root@web ~]# top -n 1 |grep Mem  #获得内存占用情况
[root@web ~]# top -n 1 |grep Mem | cut -d "," -f 1 | cut -d ":" -f 2  #获得内存情况指定列
[root@web ~]# top -n 1 |grep Mem | cut -d "," -f 2


========
Linux设置与网络同步的时间

#设置Linux时间与网络时间同步
[root@jumpserver ~]# yum install -y ntp       #安装命令
[root@jumpserver ~]# ntpdate ntp1.aliyun.com  #同步网络时间


========
重置linux网卡流量统计

[root@web ~]# yum -y install ethtool  #安装
格式：ethtool -i 网卡名称
[root@web ~]# ethtool -i ens33  #显示模块信息
[root@web ~]# e=$(ethtool -i ens33 | head -1 | awk '{print $2}')  #获得模块名称
[root@web ~]# modprobe -r ${e}; modprobe ${e};systemctl restart network   #重置网卡流量
modprobe -r ${e}  #是卸载该驱动
modprobe ${e}      #重加载该驱动


========
Linux下简单的磁盘报警脚本/crontab无法获取变量

脚本内容:
#!/bin/bash

source /etc/profile  #先加载环境变量，再执行脚本
......


========
CentOS7禁止ping和允许ping

[root@backup ~]# sysctl -w net.ipv4.icmp_echo_ignore_all=1  #禁止ping
[root@backup ~]# sysctl -w net.ipv4.icmp_echo_ignore_all=0  #允许ping


========
Linux清屏命令(3种方式)

1、这个命令将会刷新屏幕，本质上只是让终端显示页向后翻了一页，如果向上滚动屏幕还可以看到之前的操作信息。一般都会用这个命令。
[root@zyq ~]# clear

2、ctrl+l（等价clear）

3、这个命令将完全刷新终端屏幕，之前的终端输入操作信息将都会被清空，这样虽然比较清爽，但整个命令过程速度有点慢，使用较少。
[root@zyq ~]# reset


========
CentOS添加开机自启动命令和脚本


一、添加开机自启脚本
方法一：

1、编写脚本，赋予脚本可执行权限
[root@web ~]# cat /root/nginx.sh  
#!/bin/bash
/usr/local/nginx/sbin/nginx  #启动web小游戏
date >> /1.txt
[root@web ~]# chmod +x /root/nginx.sh  

2、打开/etc/rc.d/rc.local或/etc/rc.local文件，在末尾增加如下内容
[root@web ~]# vim /etc/rc.d/rc.local
......
/root/nginx.sh

3、在centos7中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限
[root@web ~]# chmod +x /etc/rc.d/rc.local


方法二:

1、将脚本移动到/etc/rc.d/init.d目录下
[root@web ~]# cat /root/nginx.sh  #编辑脚本(最上面的三行是中，第二，第三行是必须的，否则在运行chkconfig --add auto_run时，会报错)
#!/bin/bash
#chkconfig: 2345 80 90
#description:auto_run

/usr/local/nginx/sbin/nginx  #启动web小游戏
date >> /1.txt
[root@web ~]# mv /root/nginx.sh /etc/rc.d/init.d/

2、增加脚本的可执行权限
[root@web ~]# chmod +x /etc/rc.d/init.d/nginx.sh

3、添加脚本到开机自动启动项目中
[root@web ~]# cd /etc/rc.d/init.d
[root@web init.d]# chkconfig --add nginx.sh
[root@web init.d]# chkconfig nginx.sh on


二、自定义服务文件，添加到系统服务，通过Systemctl管理

1、写服务文件
[Unit]:服务的说明
Description:描述服务
After:描述服务类别

[Service] 服务运行参数的设置
Type=forking 是后台运行的形式
ExecStart 为服务的具体运行命令
ExecReload 为重启命令
ExecStop 为停止命令
PrivateTmp=True 表示给服务分配独立的临时空间
注意：启动、重启、停止命令全部要求使用绝对路径
[Install] 服务安装的相关设置，可设置为多用户


示例：nginx.service
[root@web ~]# vim /usr/lib/systemd/system/nginx.server  #保存目录
[Unit]
Description=nginx - high performance web server
After=network.target remote-fs.target nss-lookup.target

[Service]
Type=forking
ExecStart=/usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf
ExecReload=/usr/local/nginx/sbin/nginx -s reload
ExecStop=/usr/local/nginx/sbin/nginx -s stop

[Install]
WantedBy=multi-user.target
redis.service

[Unit]
Description=Redis
After=network.target remote-fs.target nss-lookup.target

[Service]
Type=forking
ExecStart=/usr/local/bin/redis-server /etc/redis.conf
ExecStop=kill -INT `cat /tmp/redis.pid`
User=www
Group=www

[Install]
WantedBy=multi-user.target
[root@web ~]# chmod 754 /usr/lib/systemd/system/nginx.server  #以754的权限保存在目录
[root@web ~]# systemctl start nginx.service      #启动nginx服务
[root@web ~]# systemctl status nginx.service   #查看服务当前状态
[root@web ~]# systemctl restart nginx.service  #重新启动服务


========
修改dns地址

[root@ftp ~]# vim /etc/resolv.conf
nameserver 114.114.114.114

[root@ftp ~]# systemctl restart network


========
Centos查看外网IP


Curl 纯文本格式输出:
[root@zyq ~]# curl icanhazip.com
121.35.187.175
[root@zyq ~]# curl ifconfig.me
121.35.187.175
[root@zyq ~]# curl ipinfo.io/ip
121.35.187.175
[root@zyq ~]# curl ipecho.net/plain
121.35.187.175
[root@zyq ~]# curl www.trackip.net/i

curl JSON格式输出:
[root@zyq ~]# curl ipinfo.io/json
[root@zyq ~]# curl ifconfig.me/all.json
[root@zyq ~]# curl www.trackip.net/ip?json

curl XML格式输出:
[root@zyq ~]# curl ifconfig.me/all.xml

curl 得到所有IP细节 （挖掘机）
[root@zyq ~]# curl ifconfig.me/all

使用 Wget 代替 Curl
[root@zyq ~]# wget http://ipecho.net/plain -O - -q ; echo
121.35.187.175


========
ssh远程linux服务器时不需要输入密码

1、安装sshpass服务（centeros 7上可直接yum安装，而centeros 6必须下载文件编译安装）
[root@zyq ~]# yum -y install sshpass  

2、使用sshpass命令登陆远程服务器
格式：
sshpass -p '密码' ssh root@192.168.0.1
sshpass -p '密码' scp 文件名称 root@192.168.0.1:/root
例：
[root@zyq ~]# sshpass -p '123456' ssh root@192.168.1.6                    #直接远程目标主机
[root@zyq ~]# sshpass -p '123456' scp /1.txt root@192.168.1.6:/root  #将本机1.txt文件上传给目标主机


========
centos查看目录或文件占用最大的硬盘空间

[root@zyq ~]# du -sh /opt   #系统只显示当前文件夹所占用的总空间
[root@zyq ~]# du -ah /opt  #显示的是所有的文件.包括子文件夹下所有文件也显示


========
看远程连接到centos服务器的ip地址 

[root@backup ~]# last  #可以查看之前登录过的用户和IP
[root@backup ~]# w    #查看当前用户 


========
shell中实现字符串反转的三种简单方法

1、使用rev命令
[root@zyq ~]# echo "123456" | rev
654321

2、使用python工具
[root@zyq ~]# echo "123456" | python -c 'print raw_input()[::-1]'
654321

3、使用awk
[root@zyq ~]# echo "123456" | awk '{for(i=1; i<=length;i++) {line = substr($0, i, 1) line}} END{print line}'
654321


========
shell字符串大小写转换

1、typeset 
有两个选项：-l 是代表小写， -u 是代表大写。
用法：
[root@zyq ~]# typeset -u name
[root@zyq ~]# name='zhaiyanquan'  #zhaiyanquan赋值给name后转换成ZHAIYANQUAN
[root@zyq ~]# echo $name
ZHAIYANQUAN

[root@zyq ~]# typeset -l name02
[root@zyq ~]# name02='ZHAIYANQUAN'  #zhaiyanquanZHAIYANQUAN赋值给name后转换成zhaiyanquan
[root@zyq ~]# echo $name02
zhaiyanquan

2、利用表达式
[root@zyq ~]# echo 'hello' | tr 'a-z' 'A-Z'  #将小写转换成大写
HELLO
[root@zyq ~]# echo 'HELLO' | tr 'A-Z' 'a-z'  #将大写转换成小写
hello

3、用tr需要新增变量，用declare或typeset需要在变量赋值前或者赋值后单独声明
[root@zyq ~]# test="abcDEF"
[root@zyq ~]# echo ${test^}     #把变量中的第一个字符换成大写
AbcDEF
[root@zyq ~]# echo ${test^^}  #把变量中的所有小写字母，全部替换为大写
ABCDEF
[root@zyq ~]# echo ${test,}      #把变量中的第一个字符换成小写
abcDEF
[root@zyq ~]# echo ${test,,}     #把变量中的所有大写字母，全部替换为小写
abcdef


========
Linux 查看哪些IP正在远程服务器和查看近期远程情况

[root@ftp ~]# netstat -ntu | awk '{print $5}'| cut -d: -f1 |sort| uniq -c | sort -n

参数解释：
-tun ：-tu是显示tcp和udp连接，n是以IP地址显示
cut -d：-f1 ：cut是一个选择性显示一行的内容命令，-d指定：为分隔符，-f1显示分隔符后的第一个字段。
uniq -c ：报告或删除文中的重复行，-c在输出行前面加上出现的次数
sort -n ：根据不同类型进行排序，默认排序是升序，-r参数改为降序，-n是根据数值的大小进行排序

[root@zyq ~]# cat /var/log/secure | grep -i "accepted password"  #查看近期远程情况


========
shell 中的 set -e 和 set +e的区别

区别：
set -e ： 执行的时候如果出现了返回值为非零，整个脚本 就会立即退出 
set +e： 执行的时候如果出现了返回值为非零将会继续执行下面的脚本 


========
Shell去除空行的4种方法

使用tr命令、sed命令、awk命令、grep命令

1、用tr命令
格式：cat 文件名 |tr -s ‘\n'
例：
[root@zyq ~]# cat /test.txt  #原文
11111

555556
yyyyyyy

d3edddd
[root@zyq ~]# cat /test.txt | tr -s '\n'  #去除空行，只是去除屏幕输出内容的空行
11111
555556
yyyyyyy
d3edddd


2、用sed命令
格式：sed -i '/^$/d'  文件名
例：
[root@zyq ~]# cat /test.txt  #原文
11111

555556
yyyyyyy
[root@zyq ~]# sed -i '/^$/d' /test.txt  #真正去除空行
[root@zyq ~]# cat /test.txt
11111
555556
yyyyyyy
d3edddd


3、用awk命
格式：
awk '{if($0!="")print}' 文件名
awk '{if(length !=0) print $0}' 文件名

例：
[root@zyq ~]# cat /test.txt  原文
11111

555556
yyyyyyy

d3edddd
[root@zyq ~]# awk '{if($0!="")print}' /test.txt  #只是去除屏幕输出内容的空行
11111 
555556
yyyyyyy
d3edddd
[root@zyq ~]# awk '{if(length !=0) print $0}' /test.txt  #只是去除屏幕输出内容的空行
11111
555556
yyyyyyy
d3edddd


4、用grep命令
格式：grep -v "^$" 文件名

例：
[root@zyq ~]# cat /test.txt
11111

555556
yyyyyyy

d3edddd
[root@zyq ~]# grep -v "^$" /test.txt  #只是去除屏幕输出内容的空行
11111
555556
yyyyyyy
d3edddd


========
shell中脚本之间函数的调用

1、创建目标函数
[root@zyq ~]# cat /test01.sh
#!/bin/bash

yuanhanshu() {

   echo "123456789"

}

2、在另一个脚本里调用目标函数
[root@zyq ~]# cat /test02.sh
#!/bin/bash

source /test01.sh  #引入

yuanhanshu  #调用目标函数

[root@zyq ~]# . /test02.sh
123456789


========
base64 加密解密文本或文件

用法：base64 [选项]... [文件]
使用 Base64 编码/解码文件或标准输入输出。

-d, --decode             解码数据
-i, --ignore-garbag   解码时忽略非字母字符
-w, --wrap=字符数    在指定的字符数后自动换行(默认为76)，0 为禁用自动换行
--help                       显示此帮助信息并退出
--version                  显示版本信息并退出

1、加密和解密文本
[root@zyq ~]# echo zhaiyanquan | base64  #加密
emhhaXlhbnF1YW4K
[root@zyq ~]# echo emhhaXlhbnF1YW4K | base64 -d  #解密
zhaiyanquan

2、加密和解密文本的内容
[root@zyq ~]# cat /1.txt  #原明文
zhaiyanqnuan9
hellow world)e3
563454635[]k(
fdkslfjldksjf
[root@zyq ~]# base64 /1.txt  #加密文本中的内容
emhhaXlhbnFudWFuOQpoZWxsb3cgd29ybGQpZTMKNTYzNDU0NjM1W11rKApmZGtzbGZqbGRrc2pm
Cg==

[root@zyq ~]# cat /2.txt  #原密文
emhhaXlhbnFudWFuOQpoZWxsb3cgd29ybGQpZTMKNTYzNDU0NjM1W11rKApmZGtzbGZqbGRrc2pm
Cg==
[root@zyq ~]# base64 -d /2.txt  #解密文本中的内容
zhaiyanqnuan9
hellow world)e3
563454635[]k(
fdkslfjldksjf


========
crontab 配置文件

1、系统配置文件 /etc/crontab
[root@zyq ~]# vim /etc/crontab
SHELL=/bin/bash                             #代表用bash去执行shell command line
PATH=/sbin:/bin:/usr/sbin:/usr/bin  #代表crontab 默认的环境变量
MAILTO=root                                  #crontab每执行一个任务都会给系统root用户发送一个邮件

# For details see man 4 crontabs

# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name  command to be executed

2、系统用户crontab配置文件保存目录(crontab -e)
/var/spool/cron
   root: /var/spool/cron/root
   user01: /var/spool/cron/user01
[root@zyq ~]# crontab -e             #给当用户设置
[root@zyq ~]# crontab -e root      #给当root用户设置
[root@zyq ~]# crontab -e user01  #给当user01用户设置


========
rsync+SSH同步文件指定服务器端口

格式：
[root@zyq ~]# rsync -av -e  "ssh -p 远程主机端口"  远程主机用户@远程主机IP:/远程主机资源目录/  /本地目录

例：
[root@zyq ~]# rsync -av -e "ssh -p 220" root@192.168.1.79:/zhai/ /zhai


========
列出最新时间的文件排在最前

[root@zyq ~]# ls -l /a  
总用量 0
-rw-r--r--. 1 root root 0 12月 21 18:46 1a.txt
-rw-r--r--. 1 root root 0 12月 21 18:46 1b.txt
-rw-r--r--. 1 root root 0 12月 21 18:46 1d.txt
-rw-r--r--. 1 root root 0 12月 21 18:46 2a.txt
-rw-r--r--. 1 root root 0 12月 21 18:46 2b.txt
-rw-r--r--. 1 root root 0 12月 21 18:46 2d.txt
-rw-r--r--. 1 root root 0 12月 21 18:46 3a.txt
-rw-r--r--. 1 root root 0 12月 21 18:46 3b.txt
-rw-r--r--. 1 root root 0 12月 21 18:46 3d.txt
[root@zyq ~]# ls -lt /a
总用量 0
-rw-r--r--. 1 root root 0 12月 21 18:46 3b.txt
-rw-r--r--. 1 root root 0 12月 21 18:46 2b.txt
-rw-r--r--. 1 root root 0 12月 21 18:46 1b.txt
-rw-r--r--. 1 root root 0 12月 21 18:46 3d.txt
-rw-r--r--. 1 root root 0 12月 21 18:46 2d.txt
-rw-r--r--. 1 root root 0 12月 21 18:46 1d.txt
-rw-r--r--. 1 root root 0 12月 21 18:46 3a.txt
-rw-r--r--. 1 root root 0 12月 21 18:46 2a.txt
-rw-r--r--. 1 root root 0 12月 21 18:46 1a.txt


========
Linux 设置静态IP

[root@zyq ~]# vim /etc/sysconfig/network-scripts/ifcfg-ens33
# Generated by dracut initrd
DEVICE="ens33"
ONBOOT="yes"
NM_CONTROLLED="no"
TYPE="Ethernet"
BOOTPROTO="static"
PERSISTENT_DHCLIENT="yes"
IPADDR=192.168.1.128
NEMASK=255.255.255.0
GATEWAY=192.168.1.1

[root@zyq ~]# systemctl restart network


========
Linux系统盘扩容

查看文件系统是否扩容完毕：
Linux:
[root@zyq ~]#  df -TH

Linux
步骤1：安装growpart
CentOS：
[root@zyq ~]#  yum install -y epel-release
[root@zyq ~]#  yum install -y cloud-utils

Ubuntu：
sudo apt-get install cloud-initramfs-growroot

步骤2：扩容块设备并重启
[root@zyq ~]#  LANG=en_US.UTF-8
[root@zyq ~]#  growpart /dev/vda 1
[root@zyq ~]#  reboot   #这步可以不重启

步骤3：扩容文件系统
虚拟机重启后执行:
resize2fs /dev/vda1 (ext4文件系统)
xfs_growfs /dev/vda1 (xfs文件系统)
例：
[root@zyq ~]# xfs_growfs /dev/vda1

步骤4：确认
查看是否扩容完成：
[root@zyq ~]# df -TH

========
查看服务器系统版本信息

[root@nova02 ~]# getconf LONG_BIT
64


========
在Linux服务器上部署禅道

适用于Ubuntu17+，centos7.4+

禅道官网：https://www.zentao.net/
官网软件包：https://www.zentao.net/download/80185.html
Linux版本下载地址：http://dl.cnezsoft.com/zentao/11.7/ZenTaoPMS.11.7.stable.zbox_64.tar.gz

1、查看Linux服务器版本信息
[root@nova02 tmp]# cat /etc/centos-release
CentOS Linux release 7.6.1810 (Core) 

2、禅道开源版安装包下载
[root@nova02 ~]# wget http://dl.cnezsoft.com/zentao/11.7/ZenTaoPMS.11.7.stable.zbox_64.tar.gz

3、直接解压安装包到/opt目录下
[root@nova02 ~]# tar -zxvf ZenTaoPMS.11.7.stable.zbox_64.tar.gz -C /opt

4、启动禅道服务
[root@nova02 ~]# /opt/zbox/zbox start
Start Apache success
Start Mysql success
注：你可以通过/opt/zbox/zbox stop命令终止以上服务，也可通过/opt/zbox/zbox restart命令重启以上服务。

5、设置禅道服务自动启动，以保证每次服务器重启后禅道能够正常运行
1）编辑rc.local文件，在文件末尾添加禅道重启命令，保存后退出
[root@nova02 ~]# vim /etc/rc.local
......
/opt/zbox/zbox start

2）重启服务器后，使用ps命令查看禅道服务是否自动启动
[root@nova02 ~]# ps aux | grep zbox

6、打开浏览器，输入以下网址即可访问禅道
http://IP/zentao/
管理员登录的默认账号和密码：admin；123456
至此，禅道软件在Linux服务器上的部署已全部完成。

部署脚本
#!/bin/bash
wget http://dl.cnezsoft.com/zentao/11.7/ZenTaoPMS.11.7.stable.zbox_64.tar.gz   #禅道开源版安装包下载
tar -zxvf ZenTaoPMS.11.7.stable.zbox_64.tar.gz -C /opt                                        #直接解压安装包到/opt目录下
/opt/zbox/zbox start                                                                                            #启动禅道服务
echo '/opt/zbox/zbox start' >> /etc/rc.local                                                         #设置开机禅道服务自动启动
ps aux | grep zbox                                                                                                #重启服务器后，使用ps命令查看禅道服务是否自动启动


修改apache端口和mysql端口的操作(需要时可以修改端口，非必需操)
1、修改禅道自带apache、mysql端口
为了不占用Server上默认的80、3306端口，我们修改禅道自带的apache、mysql端口。你可以根据自己的喜好来修改端口。
1）修改禅道自带的apache端口：
[root@nova02 ~]# /opt/zbox/zbox -ap 9000
2）修改禅道自带的mysql端口：
[root@nova02 ~]# /opt/zbox/zbox -mp 9001

2. 配置iptables防火墙规则，允许端口访问
[root@nova02 ~]# yum -y install iptables-services   #安装iptabales
[root@nova02 ~]# systemctl restart iptables.service
[root@nova02 ~]# systemctl enable iptables.service  #查看运行状态
[root@nova02 ~]# iptables -A INPUT -p tcp --dport 9000 -j ACCEPT
[root@nova02 ~]# iptables -A INPUT -p tcp --dport 9001 -j ACCEPT

3、 重启防火墙，使上述规则生效(iptables)
[root@nova02 ~]# service iptables save
iptables: Saving firewall rules to /etc/sysconfig/iptables:[  确定  ]
[root@nova02 ~]# systemctl restart iptables.service


========
利用yum下载软件包的三种方法

方法一：yum-utils中的yumdownloader

1、安装yum-utils
[root@ecs-proxy ~]# yum -y install yum-utils

2、使用yumdownloader下载软件包httpd
格式：yumdownloader 软件包名
[root@ecs-proxy ~]# yumdownloader httpd


方法二：downloadonly插件

1、安装插件
[root@ecs-proxy ~]# yum -y install yum-download 

2、下载httpd软件包到当前文件夹内
格式：yum -y install 软件包名  -downloadonly -downloaddir=./
[root@ecs-proxy ~]# yum -y install httpd -downloadonly -downloaddir=./
注：此方法实测阿里云Centos 7.3未找到安装包，可能镜像源没有。


方法三：利用yum的缓存功能
　　默认情况下,yum在安装软件包后会自动清理软件包,修改配置,使yum不再清理软件包
　　vim /etc/yum.conf中修改keepcache = 0改为keepcache = 1
　　/etc/init.d/yum-updatesd restart
　　yum -y install httpd
　　这时软件包已经安装下载,目录为/var/cache/yum


脚本：利用yum下载yum源里所有rpm包
#!/bin/bash

yum -y install yum-utils

for i in $(yum list)
do
     yumdownloader $i  #下载软件包，存放位置在/root
done


========
sed以变量的方式删除文件内容

[root@zyq ~]# cat /aa.txt
aaa
bbb
ccc
ddd
dddffdl
dafdsfitrje

[root@zyq ~]# n=bbb
[root@zyq ~]# sed "s/${n}//" /aa.txt
aaa

ccc
ddd
dddffdl
dafdsfitrje


========
linux shell 用sed命令在文本的行尾或行首添加字符

1、在每行的头添加字符
[root@nw ~]# cat /test.txt  #查看当前内容
123
abc
[root@nw ~]# sed -i 's/^/head&/g' /test.txt  #在每行的头添加字符，比如"head"
[root@nw ~]# cat /test.txt  #查看添加之后的内容
head123
headabc

2、在每行的行尾添加字符
[root@nw ~]# sed -i 's/$/&tall/g' /test.txt  #在每行的行尾添加字符，比如“tall”
[root@nw ~]# cat /test.txt
head123tall
headabctall

几点说明：
1."^"代表行首，"\$"代表行尾
2.'s/$/&TAIL/g'中的字符g代表每行出现的字符全部替换，如果想在特定字符处添加，g就有用了，否则只会替换每行第一个，而不继续往后找了


========
Centos7 使用chrony做时间同步

一、chrony工具安装
[root@yum ~]# rpm -qa | grep chrony  #使用rpm -qa | grep chrony查看系统是否已安装chrony，可看到默认已安装chrony的包
[root@yum ~]# yum install chrony  #如果没有安装环境可使用yum install chrony命令安装或者离线下载rpm包安装


二、Chrony服务启停检查
[root@yum ~]# systemctl start chronyd.service  #启动chrony服务
或
[root@yum ~]# systemctl start chronyd

[root@yum ~]# systemctl enable chronyd.service  #设置开机同步时间
或
[root@yum ~]# systemctl enable chronyd

[root@yum ~]# systemctl status chronyd.service  #查看服务状态
或
[root@yum ~]# systemctl status chronyd

[root@yum ~]# systemctl stop chronyd.service  #停止chrony服务
或
[root@yum ~]# systemctl stop chronyd


三、服务端和客户端chrony配置

1、服务端配置
1）、配置文件修改
[root@yum ~]# vim /etc/chrony.conf
......
 18 # Enable hardware timestamping on all interfaces that support it.
 19 #hwtimestamp *
 20 
 21 # Increase the minimum number of selectable sources required to adjust
 22 # the system clock.
 23 #minsources 2
 24 
 25 # Allow NTP client access from local network.
 26 allow 192.168.1.0/24  #修改第26行，配置本机IP网段,同步的网段
 27 
 28 # Serve time even if not synchronized to a time source.
 29 local stratum 10  #修改第29行设置同步，打开注释即可，同步数量
 30 
 31 # Specify file containing keys for NTP authentication.
 32 #keyfile /etc/chrony.keys
......

2）、重启下服务端chrony服务，使用systemctl restart chronyd.service重启即可。
[root@yum ~]# systemctl restart chronyd.service  #重启chrony服务
或
[root@yum ~]# systemctl restart chronyd

2、客户端配置
1）、配置文件修改
[root@yum ~]# vim  /etc/chrony.conf  #修改server即可，注释其他的，添加一个即可，配置IP地址为服务端地址即可
# Use public servers from the pool.ntp.org project.
# Please consider joining the pool (http://www.pool.ntp.org/join.html).
#server 0.centos.pool.ntp.org iburst
#server 1.centos.pool.ntp.org iburst
#server 2.centos.pool.ntp.org iburst
server 192.168.1.74 iburst  #192.168.1.74是服务端IP

# Record the rate at which the system clock gains/losses time.
driftfile /var/lib/chrony/drift

# Allow the system clock to be stepped in the first three updates
# if its offset is larger than 1 second.
makestep 1.0 3

# Enable kernel synchronization of the real-time clock (RTC).
rtcsync

# Enable hardware timestamping on all interfaces that support it.
#hwtimestamp *
......

2）、重启下服务端chrony服务，使用systemctl restart chronyd.service重启即可。
[root@yum ~]# systemctl restart chronyd.service  #重启chrony服务
或
[root@yum ~]# systemctl restart chronyd

3）、使用timedatectl命令查看时间即可。
[root@nova01 ~]# chronyc sources -v  
210 Number of sources = 1

  .-- Source mode  '^' = server, '=' = peer, '#' = local clock.
 / .- Source state '*' = current synced, '+' = combined , '-' = not combined,
| /   '?' = unreachable, 'x' = time may be in error, '~' = time too variable.
||                                                 .- xxxx [ yyyy ] +/- zzzz
||      Reachability register (octal) -.           |  xxxx = adjusted offset,
||      Log2(Polling interval) --.      |          |  yyyy = measured offset,
||                                \     |          |  zzzz = estimated error.
||                                 |    |           \
MS Name/IP address         Stratum Poll Reach LastRx Last sample               
===============================================================================
^* 192.168.1.74                 11   6    17     9    +43us[ +599us] +/- 3840us  # *表示已同步


========
awk根据指定的字符串分割字符串

以从字符串"hello-kitty-red-for-you"中获取-for前面的内容为例:
[root@localhost ~]# echo "hello-kitty-red-for-you" |awk -F '-for' '{print $1}'  #此时-F指定的-for为纯粹的字符串

那么将'-for'换成'[-for]'之后呢?
[root@localhost ~]# echo "hello-kitty-red-for-you" |awk -F '[-for]' '{print $1}' #此时-F指定的[-for]就不仅仅是某个字符串了，此时会以-或f或o或r分割字符串,o首先出现在字符串中，那么就会以o为分割线对字符串进行分割


========
Centos7 最小化安装后网络链接配置

[root@localhost ~]# cd /etc/sysconfig/network-scripts
[root@localhost network-scripts]# vi ifcfg-ens33 #修改ifcfg-ens33文件
TYPE=Ethernet
PROXY_METHOD=none
BROWSER_ONLY=no
BOOTPROTO=dhcp
DEFROUTE=yes
IPV4_FAILURE_FATAL=no
IPV6INIT=yes
IPV6_AUTOCONF=yes
IPV6_DEFROUTE=yes
IPV6_FAILURE_FATAL=no
IPV6_ADDR_GEN_MODE=stable-privacy
NAME=ens33
UUID=c284f95a-a28f-45b8-a24d-989f6a1a09c2
DEVICE=ens33
ONBOOT=yes  #将ONBOOT=no 修改为 ONBOOT=yes

[root@localhost network-scripts]# service network restart  #重启网卡
或
[root@localhost network-scripts]# systemctl restart network

[root@localhost ~]# yum install net-tools  #安装网络工具后可使用ifconfig
[root@localhost ~]# ifconfig               #查看ip


========
Linux中查看开启了哪些服务的命令
[root@ftp ~]# service --status-all
[root@ftp ~]# chkconfig --list
[root@ftp ~]# ps aux
[root@ftp ~]# netstat -lntp

如果未找到命令
[root@ftp ~]# yum provides 命令


========
Nginx添加多个站点或网站 

可以配置多个server，一个server就是一个站点。例如：
[root@ecs-proxy ~]# vim /usr/local/nginx/conf/nginx.conf
......
 #第一个网站使用80端口
 server { 
         listen       80;
          server_name  a.playgame918.com;  #a.playgame918.com是自己的域名，用来访问该网站
          #charset koi8-r;

          #access_log  logs/host.access.log  main;

          location / {
              root html;  #默认的网站路径html,可以根据需要修改路径
  
              index  index.html index.php index.htm;
          }   
    } 
	
  server {  #隐藏转发的端口号
      listen [::]:1023;
  }	
  server {  #第二个网站使用1023端口，端口可以自定义
         listen       80;  #80端口不做改动
          server_name  www.playgame918.com;  #www.playgame918.com是自己的域名，用来访问该网站
          #charset koi8-r;

          #access_log  logs/host.access.log  main;

          location / {
              #root html;
              root   /root/zhai;  #自己的web服务资源路径
              index  index.html index.php index.htm;
          }
	   
    }
	
   server {  #隐藏转发的端口号
	listen [::]:1025;  
    }
    server {  #第三个网站使用1025端口，端口可以自定义
        listen       80;  #80端口不做改动
        server_name  b.playgame918.com;  #b.playgame918.com是自己的域名，用来访问该网站
        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            #root html  
            root   /zyq/ekae;  #自己的web服务资源路径
            index  index.html index.php index.htm;
        }
    }
......


========
Nginx隐藏转发的端口号

[root@ecs-proxy ~]# vim /usr/local/nginx/conf/nginx.conf  #添加个server
......
   server {  #添加这个三行，设置隐藏转发的端口号
        listen [::]:8099;  #设置该web服务的端口
    }
    server {  #要在这个server上方添加上面三行
        listen       80;  #这里80端口不变
        server_name  localhost;

        #charset koi8-r;

        #access_log  logs/host.access.log  main;

        location / {
            root   html,rar;
            charset utf-8;
            proxy_pass http://webserver;
                                                  
......

访问：可以直接使用IP或域名


========
nginx设置成服务并开机自动启动


方法1：
[root@ecs-proxy ~]# yum -y install chkconfig  #安装chkconfig包

[root@ecs-proxy ~]# vim /etc/init.d/nginx  #在/etc/init.d下创建文件nginx
#!/bin/bash
# nginx - this script starts and stops the nginx daemon
#
# chkconfig:   - 85 15
# description:  NGINX is an HTTP(S) server, HTTP(S) reverse \
#               proxy and IMAP/POP3 proxy server
# processname: nginx
# config:      /etc/nginx/nginx.conf
# config:      /etc/sysconfig/nginx
# pidfile:     /var/run/nginx.pid
# 注意：上面的注释内容要保留，因为执行"chkconfig nginx on"命令时才能成功
/usr/local/nginx/sbin/nginx  #这个是自己nginx启动服务程序的路径
date +"%Y-%m-%d %H:%M:%S" >> /BootTime.txt  #记录开机服务器或重启服务器时间

[root@ecs-proxy ~]# chkconfig --add /etc/init.d/nginx  #先将nginx服务加入chkconfig管理列表

[root@ecs-proxy ~]# chkconfig nginx on   #最后设置开机自动启动（开机时执行nginx脚本）

[root@ecs-proxy ~]# chkconfig nginx off  #这项是关闭开机自启（开机时不执行nginx脚本）

[root@ecs-proxy ~]# touch /BootTime.txt  #创建记录开机服务器或重启服务器时间文件


方法2：
[root@ecs-proxy ~]# vim /lib/systemd/system/nginx.service  #通过源码安装的（添加）
[Unit]
Description=nginx
After=network.target
  
[Service]
Type=forking
ExecStart=/usr/local/nginx/sbin/nginx
ExecReload=/usr/local/nginx/sbin/nginx -s reload
ExecStop=/usr/local/nginx/sbin/nginx -s quit
PrivateTmp=true
  
[Install]
WantedBy=multi-user.target

[root@ecs-proxy ~]# systemctl enable nginx  #设置开机启动


========
nginx的日志切割

nginx的日志不会每天自动分割日志文件，导致日志文件会越来大，不方便开发人员阅读日志。所以需要对日志进行切割

先写一个sh文件，我写在nginx目录下
[root@zyq ~]# vim /usr/local/nginx/cut_nginx_log.sh
#!/bin/bash


#此脚本用于自动分割Nginx的日志，包括access.log和error.log

#每天00:00执行此脚本 将前一天的access.log重命名为access-xxxx-xx-xx.log格式，并重
新打开日志文件


LOG_PATH=/usr/local/nginx/logs/  #Nginx日志文件所在目录


YESTERDAY=$(date -d "yesterday" +%Y-%m-%d)
  #获取昨天的日期


PID=/usr/local/nginx/logs/nginx.pid
  #获取pid文件路径


#分割日志

mv ${LOG_PATH}access.log ${LOG_PATH}access-${YESTERDAY}.log

mv ${LOG_PATH}error.log ${LOG_PATH}error-${YESTERDAY}.log


kill -USR1 `cat ${PID}`  #向Nginx主进程发送USR1信号，重新打开日志文件


给sh文件执行的权限
[root@zyq ~]# chmod a+x /usr/local/nginx/cut_nginx_logs.sh


同时对access.log和error.log进行处理,再进行定时设置
[root@zyq ~]# crontab -e 
#执行的命令段，格式如下：
#minute hour day month week command

#其中：
#minute： 表示分钟，可以是从0到59之间的任何整数。

#hour：表示小时，可以是从0到23之间的任何整数。

#day：表示日期，可以是从1到31之间的任何整数。

#month：表示月份，可以是从1到12之间的任何整数。

#week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。

#command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。


0 0 * * * /bin/bash /usr/local/nginx/cut_nginx_log.sh



========
查看swap内存被哪些进程占用
[root@openstack ~]# for i in `cd /proc;ls |grep "^[0-9]"|awk ' $0 >100'` ;do awk '/Swap:/{a=a+$2}END{print '"$i"',a/1024"M"}' /proc/$i/smaps ; done 2>&1 | sort -k2nr | head
网址：https://jingyan.baidu.com/article/a3aad71af9409fb1fb009636.html


========
Centos7开放及查看端口

centos7默认没有 netstat 命令，需要安装 net-tools 工具，yum install -y net-tools

1、开放端口
[root@openstack ~]# firewall-cmd --zone=public --add-port=5672/tcp --permanent     #开放5672端口
[root@openstack ~]# firewall-cmd --zone=public --remove-port=5672/tcp --permanent  #关闭5672端口
[root@openstack ~]# firewall-cmd --reload                                          #配置立即生效

2、查看防火墙所有开放的端口
[root@openstack ~]# firewall-cmd --zone=public --list-ports

3.、关闭防火墙
如果要开放的端口太多，嫌麻烦，可以关闭防火墙，安全性自行评估
[root@openstack ~]# systemctl start firewalld.service

4、查看防火墙状态
[root@openstack ~]# firewall-cmd --state

5、查看监听的端口
[root@openstack ~]# netstat -lnpt

6、检查端口被哪个进程占用
[root@openstack ~]# netstat -lnpt |grep 5672

7、查看进程的详细信息
[root@openstack ~]# ps 6832

8、中止进程
[root@openstack ~]# kill -9 6832


========
监控(glances)
[root@nw ~]# yum -y install glances  #安装glances
[root@nw ~]# glances                 #运行显示监控界面


========
CentOS_7 时间与网络时间同步

1、安装ntpdate工具
[root@ftp ~]# yum -y install ntp ntpdate

2、设置系统时间与网络时间同步
[root@ftp ~]# ntpdate 0.asia.pool.ntp.org

3、将系统时间写入硬件时间(这里是为了防止系统重启后时间被还原，因此需要写到硬件设备中去。)
[root@ftp ~]# hwclock --systohc


========
配置GRE VPN(配置Linux服务器不同网段的实现成内网通讯)


主机列表：
client服务器内网IP：201.1.2.10/24
proxy服务器内网IP：201.1.2.5/24

client和proxy都需要操作
[root@client ~]# systemctl stop firewalld  #关闭防火墙
[root@client ~]# vim /etc/selinux/config   #设置selinux为宽松模式(永久设置)
SELINUX=permissive
[root@client ~]# setenforce 0  #临时设置(立即生效)
[root@client ~]# getenforce    #getenforce: 查看当前模式


步骤一：启用GRE模块（client和proxy都需要操作）

1）查看计算机当前加载的模块
[root@client ~]# lsmod		       #显示模块列表
[root@client ~]# lsmod  | grep ip_gre  #确定是否加载了gre模块

2)加载模块ip_gre
[root@client ~]# modprobe  ip_gre 

3）查看模块信息
[root@client ~]# modinfo ip_gre
filename:       /lib/modules/3.10.0-693.el7.x86_64/kernel/net/ipv4/ip_gre.ko.xz
alias:          netdev-gretap0
alias:          netdev-gre0
alias:          rtnl-link-gretap
......

4）关闭模块（如果不需要了，可以关闭）
[root@client ~]# rmmod ip_gre


步骤二：Client主机创建VPN隧道

1）创建隧道
[root@client ~]# ip tunnel help  #查看模板帮助
[root@client ~]# ip tunnel add tun0  mode gre remote 201.1.2.5 local 201.1.2.10  #201.1.2.5是远程公网IP(对方公网IP),201.1.2.10是本地公网IP
# ip tunnel add创建隧道（隧道名称为tun0），ip tunnel help可以查看帮助
# mode设置隧道使用gre模式
# local后面跟本机的IP地址，remote后面是与其他主机建立隧道的对方IP地址

2）启用该隧道（类似与设置网卡up）
[root@client ~]# ip link show
[root@client ~]# ip link set tun0 up #设置UP
[root@client ~]# ip link show

3）为VPN配置隧道IP地址
[root@client ~]# ip addr add 10.10.10.10/24 peer 10.10.10.5/24 dev tun0  # 10.10.10.10/24是本地私网（自定义），10.10.10.5/24是远程私网IP(对方私网IP)（自定义）
#为隧道tun0设置本地IP地址（10.10.10.10.10/24）
#隧道对面的主机IP的隧道IP为10.10.10.5/24
[root@client ~]# ip a s  #查看IP地址
或
[root@client ~]# ip addr show tun0 #只查看一个网卡地址


步骤三：Proxy主机创建VPN隧道

1）查看计算机当前加载的模块
[root@client ~]# lsmod		       #显示模块列表
[root@client ~]# lsmod  | grep ip_gre  #确定是否加载了gre模块

2)加载模块ip_gre
[root@client ~]# modprobe  ip_gre

3）创建隧道
[root@proxy ~]# ~]# ip tunnel add tun0 mode gre remote 201.1.2.10 local 201.1.2.5
#ip tunnel add创建隧道（隧道名称为tun0），ip tunnel help可以查看帮助
#mode设置隧道使用gre模式
#local后面跟本机的IP地址，remote后面是与其他主机建立隧道的对方IP地址

4）启用该隧道（类似与设置网卡up）
[root@proxy ~]# ip a  s
[root@proxy ~]# ip link set tun0 up #设置UP
[root@proxy ~]# ip a  s

5）为VPN配置隧道IP地址
[root@proxy ~]# ip addr add 10.10.10.5/24 peer 10.10.10.10/24 dev tun0
#为隧道tun0设置本地IP地址（10.10.10.10.5/24）
#隧道对面的主机IP的隧道IP为10.10.10.10/24
[root@proxy ~]# ip a s  #查看IP地址

6)测试连通性
[root@client ~]#  ping 10.10.10.5
[root@proxy ~]#   ping 10.10.10.10


========
在线解密解密暴力破解md5
https://www.somd5.com/
https://pmd5.com/


========
[root@zyq ~]# echo -n 123456     #不换行
123456[root@zyq ~]# echo 123456  #换行
123456


========
CentOS 7安全加固：https://www.cnblogs.com/hai-long/p/10744053.html

本次实验使用的centos 7 版本
[root@ecs-proxy ~]# cat /etc/centos-release
CentOS Linux release 7.6.1810 (Core)


一、查找系统中是否存在空密码账户

1、使用命令: awk -F: '($2==""){print $1}' /etc/shadow 直接查看。可以看到系统中没有空密码账户
[root@ecs-proxy ~]# awk -F: '($2==""){print $1}' /etc/shadow
[root@ecs-proxy ~]# 

2、验证一下。添加一个账户qwe， 命令：useradd qwe（此时qwe虽然没有密码但是他还不能使用空密码登录）
[root@ecs-proxy ~]# useradd qwe
[root@ecs-proxy ~]# 

3、使用root账户清除qwe密码，passwd -d qwe
[root@ecs-proxy ~]# passwd -d qwe
Removing password for user qwe.
passwd: Success

4、再次使用 awk -F: '($2==""){print $1}' /etc/shadow 命令查看系统中空密码账户
[root@ecs-proxy ~]# awk -F: '($2==""){print $1}' /etc/shadow 
qwe


二、密码策略

1、修改 /etc/login.defs文件中相应参数
[root@ecs-proxy ~]# vim /etc/login.defs
......
PASS_MAX_DAYS   99999  #密码有效期
PASS_MIN_DAYS   0      #修改密码的最短期限
PASS_MIN_LEN    5      #密码最短长度
PASS_WARN_AGE   7      #密码过期提醒
......


2、修改密码策略

修改vi /etc/pam.d/system-auth文件，将password requisite pam_pwquality.so try_first_pass local_users_only retry=3 authtok_type= 注释并在其下面新增1行 password requisite pam_cracklib.so try_first_pass minlen=8 difok=5 dcredit=-1 lcredit=-1 ocredit=-1 retry=1 type= 
[root@ecs-proxy ~]# vim /etc/pam.d/system-auth
......
15 #password    requisite     pam_pwquality.so try_first_pass local_users_only retry=3 authtok_type=
16 password requisite pam_cracklib.so try_first_pass minlen=8 difok=5 dcredit=-1 lcredit=-1 ocredit=-1 retry=1 type=
......

备注:
try_first_pass而当pam_unix验证模块与password验证类型一起使用时，该选项主要用来防止用户新设定的密码与以前的旧密码相同。
minlen=8    最小长度8位
difok=5     新、旧密码最少5个字符不同
dcredit=-1  最少1个数字
lcredit=-1  最少1个小写字符，（ucredit=-1:最少1个大写字符)
ocredit=-1  最少1个特殊字符
retry=1     1次错误后返回错误信息
type=xxx    此选项用来修改缺省的密码提示文本


3、新口令不能与10个最近使用的相同
修改vi /etc/pam.d/system-auth文件，在password sufficient pam_unix.so sha512 shadow nullok try_first_pass use_authtok 所在行的后面添加 remember=11
[root@ecs-proxy ~]# vim /etc/pam.d/system-auth
 15 #password    requisite     pam_pwquality.so try_first_pass local_users_only retry=3 authtok_type=
 16 password requisite pam_cracklib.so try_first_pass minlen=8 difok=5 dcredit=-1 lcredit=-1 ocredit=-1 retry=1 type=
 17 password    sufficient    pam_unix.so sha512 shadow nullok try_first_pass use_authtok remember=11


4、设置会话超时
修改vim /etc/profile文件在最后添加参数export TMOUT=600。（600秒等于十分钟）
[root@ecs-proxy ~]# vim /etc/profile
......
export TMOUT=600

5、账户锁定策略（终端登录）
修改vim /etc/pam.d/system-auth文件，在# User changes will be destroyed the next time authconfig is run.行的下面，添加 auth required pam_tally2.so deny=5 unlock_time=1800 even_deny_root root_unlock_time=1800（终端登录失败5次，锁定半小时）
[root@ecs-proxy ~]# vim /etc/pam.d/system-auth
#%PAM-1.0
# This file is auto-generated.
# User changes will be destroyed the next time authconfig is run.
auth required pam_tally2.so deny=5 unlock_time=1800 even_deny_root root_unlock_time=1800
......

备注:
deny=5  5次 
unlock_time=1800       锁定半小时（1800秒）
root_unlock_time=1800


========
zabbix忘记登录密码重置方法


1、生成一个MD5加密的密码
[root@ecs-proxy ~]# echo -n  zyq123456  | openssl md5  # zyq123456是新设置秘密
(stdin)= e93ed625e2801ed7dfd7bbade77b5234

2、zabbix连接的是mysql数据库
[root@ecs-proxy ~]# mysql -uroot -p  #连接数据库

3、进入zhai数据库以后查询users表
mysql> use zhai;                     #进入zhai库
mysql> select userid,alias,passwd from users;
+--------+-------+----------------------------------+
| userid | alias | passwd                           |
+--------+-------+----------------------------------+
|      1 | Admin | 21232f297a57a5a743894a0e4a801fc3 |
|      2 | guest | d41d8cd98f00b204e9800998ecf8427e |
+--------+-------+----------------------------------+

4、然后update表数据，userid=1的这个用户
mysql> update users set  passwd='e93ed625e2801ed7dfd7bbade77b5234' where userid = '1'; #1表示第一个用户
Query OK, 1 row affected (0.00 sec)

5、刷新重新加载权限表
mysql> flush privileges;
Query OK, 0 rows affected (0.00 sec)


========
一次输出多列
[root@ecs-proxy ~]# cat /2.txt
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
1 2 3 4 5
[root@ecs-proxy ~]# cut -d" " -f 2-3 file /2.txt   #输出2到3列
cut: file: 没有那个文件或目录
2 3
2 3
2 3
2 3
2 3
2 3


========
Linux scp命令


Linux scp命令用于Linux之间复制文件和目录。
scp是 secure copy的缩写, scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。

语法
scp [-1246BCpqrv] [-c cipher] [-F ssh_config] [-i identity_file]
[-l limit] [-o ssh_option] [-P port] [-S program]
[[user@]host1:]file1 [...] [[user@]host2:]file2

简易写法:
scp [可选参数] file_source file_target 

参数说明：
-1： 强制scp命令使用协议ssh1
-2： 强制scp命令使用协议ssh2
-4： 强制scp命令只使用IPv4寻址
-6： 强制scp命令只使用IPv6寻址
-B： 使用批处理模式（传输过程中不询问传输口令或短语）
-C： 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）
-p：保留原文件的修改时间，访问时间和访问权限。
-q： 不显示传输进度条。
-r： 递归复制整个目录。
-v：详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。
-c cipher： 以cipher将数据传输进行加密，这个选项将直接传递给ssh。
-F ssh_config： 指定一个替代的ssh配置文件，此参数直接传递给ssh。
-i identity_file： 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。
-l limit： 限定用户所能使用的带宽，以Kbit/s为单位。
-o ssh_option： 如果习惯于使用ssh_config(5)中的参数传递方式，
-P port：注意是大写的P, port是指定数据传输用到的端口号
-S program： 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。

实例
1、从本地复制到远程 
命令格式：
scp local_file remote_username@remote_ip:remote_folder 
或者 
scp local_file remote_username@remote_ip:remote_file 
或者 
scp local_file remote_ip:remote_folder 
或者 
scp local_file remote_ip:remote_file 

第1,2个指定了用户名，命令执行后需要再输入密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名； 
第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名； 

应用实例：
scp /home/space/music/1.mp3 root@www.runoob.com:/home/root/others/music 
scp /home/space/music/1.mp3 root@www.runoob.com:/home/root/others/music/001.mp3 
scp /home/space/music/1.mp3 www.runoob.com:/home/root/others/music 
scp /home/space/music/1.mp3 www.runoob.com:/home/root/others/music/001.mp3 

复制目录命令格式： 
scp -r local_folder remote_username@remote_ip:remote_folder 
或者 
scp -r local_folder remote_ip:remote_folder 
第1个指定了用户名，命令执行后需要再输入密码； 
第2个没有指定用户名，命令执行后需要输入用户名和密码； 

应用实例：
scp -r /home/space/music/ root@www.runoob.com:/home/root/others/ 
scp -r /home/space/music/ www.runoob.com:/home/root/others/ 
上面命令将本地 music 目录复制到远程 others 目录下。

2、从远程复制到本地 
从远程复制到本地，只要将从本地复制到远程的命令的后2个参数调换顺序即可，如下实例 

应用实例：
scp root@www.runoob.com:/home/root/others/music /home/space/music/1.mp3 
scp -r www.runoob.com:/home/root/others/ /home/space/music/

说明
1.如果远程服务器防火墙有为scp命令设置了指定的端口，我们需要使用 -P 参数来设置命令的端口号，命令格式如下： 
#scp 命令使用端口号 4588
scp -P 4588 remote@www.runoob.com:/usr/local/sin.sh /home/administrator
2.使用scp命令要确保使用的用户具有可读取远程服务器相应文件的权限，否则scp命令是无法起作用的。

========
写入硬件时间
[root@db01 ~]# hwclock -w  #写入硬件时间
[root@db01 ~]# hwclock -r  #查看当前硬件时间


========
统计Apache或nginx日志里访问次数最多的前十个IP： https://www.cnblogs.com/matengfei123/p/10359257.html

根据访问IP统计UV（访客数量）
[root@ecs-proxy ~]# awk '{print $1}' /usr/local/nginx/logs/access.log | uniq -c | wc -l  #一天之内，访问您网站的访客数量

统计访问URL统计PV（访问量）
[root@ecs-proxy ~]# awk '{print $7}' /usr/local/nginx/logs/access.log | wc -l

查询访问最频繁的URL
[root@ecs-proxy ~]# awk '{print $7}' /usr/local/nginx/logs/access.log | uniq -c | sort -nk 1 -r | more

查询访问最频繁的URL
[root@ecs-proxy ~]# awk '{print $7}' /usr/local/nginx/logs/access.log | sort |uniq -c | sort -nk 1 -r | more

查询访问最频繁的IP
[root@ecs-proxy ~]# awk '{print $1}' /usr/local/nginx/logs/access.log | sort |uniq -c | sort -nk 1 -r | more


统计nginx日记里访问次数最多的前十个IP
[root@ecs-proxy ~]# awk '{print $1}' /usr/local/nginx/logs/access.log | uniq -c | sort -nk 1 -r | head
或
[root@ecs-proxy ~]# awk '{print $1}' /usr/local/nginx/logs/access.log | sort |uniq -c | sort -nk 1 -r | more | head


UV(Unique Visitor)：独立访客，将每个独立上网电脑（以cookie为依据）视为一位访客，一天之内（00:00-24:00），访问您网站的访客数量。
                         一天之内相同cookie的访问只被计算1次
PV（Page View）：访问量,即页面浏览量或者点击量,用户每次对网站的访问均被记录1次。用户对同一页面的多次访问，
                     访问量值累计统计独立IP：00:00-24:00内相同IP地址只被计算一次,做网站优化的朋友最关心这个

awk '{ print $1}'：取数据的低1域（第1列）

sort：对IP部分进行排序。

uniq -c：打印每一重复行出现的次数。（并去掉重复行）

sort -nr -k1：按照重复行出现的次序倒序排列,-k1以第一列为标准排序。

head -n 10：取排在前5位的IP。


========
Linux查看进程启动及运行时间

ps -eo lstart 启动时间

ps -eo etime 运行多长时间.

ps -eo pid,lstart,etime | grep 5176

 参数说明：
 pid：进程ID
 tty：终端
 user：用户
 comm：进程名
 lstart：开始时间
 etime：运行时间

[root@ecs-proxy ~]# ps -eo pid,tty,user,comm,lstart,etime | grep nginx


========
Shell中去除字符串前后空格的方法
[root@local ~]# echo "  A BC  "
   A  BC

或者
[root@local ~]# eval echo "  A BC  "
A BC

或者
[root@linux ~]# echo ' A BC  ' | python -c "s=raw_input();print(s.strip())"
A BC

或者
[root@linux ~]# echo ' A BC ' | sed -e 's/^[ ]*//g' | sed -e 's/[ ]*$//g'
A BC

或者
[root@linux ~]# echo " A BC  " | awk '$1=$1'
A BC
或者
[root@linux ~]# echo " A BC  " | sed -r 's/^[ \t]+(.*)[ \t]+$//g'
A BC

删除行首空格
sed ‘s/^[ \t]*//g'

或者
[root@linux ~]# echo ' A BC  ' | awk '{sub(/^ */, "");sub(/ *$/, "")}1'


========
查看内存、交换分区、磁盘、CPU信息和网卡

命令示例：
free [-k]   # 以 kb  为单位显示内存使用状况
free -g     # 以 G 为单位显示内存使用状况
free -m    # 以 M 为单位显示内存使用状况
free -t     # 以总和的形式显示内存的使用信息
free -s 1  # 每一秒显示内存使用情况

说明–对这些数值的解释：
total:总计物理内存的大小。
used: 已使用多大。
free: 可用有多少.
Shared: 多个进程共享的内存总额。

如何看额定值：
cat /proc/meminfo

Buff/cache:磁盘缓存的大小。

查看内存与交换分区信息
[root@zyq ~]# free
[root@zyq ~]# swapon -s

查看磁盘与CPU利用率
[root@zyq ~]# df  #查看磁盘信息

[root@node ~]# lscpu    #查看cpu信息
[root@node ~]# free -m  #查看内存信息

查看CPU平均负载
[root@zyq ~]# uptime  #查看CPU负载（1，5，15分钟）
09:01:20 up 34 min,  3 users,  load average: 0.00, 0.01, 0.05
 现在时间      开机时间   用户个数       平均负载       1分钟，5分钟，15分钟 
[root@zyq ~]# uptime | awk '{print $NF}'  #仅查看CPU的15分钟平均负载

查看网卡信息、端口信息、网络连接信息
[root@zyq ~]# ifconfig enp1s0  
[root@zyq ~]# ifconfig enp1s0 | awk '/inet /{print $2}'  #查看IP地址信息
[root@zyq ~]# ifconfig enp1s0 | awk '/RX p/{print $5}'   #网卡接受数据包流量
[root@zyq ~]# ifconfig enp1s0 | awk '/TX p/{print $5}'   #网卡发送数据包流量

[root@zyq ~]# cat /proc/cpuinfo | grep "physical id" | uniq | wc -l   #查看CPU个数
[root@zyq ~]# cat /proc/cpuinfo | grep "cpu cores" | uniq              #查看CPU核数
[root@zyq ~]# cat /proc/cpuinfo | grep 'model name' |uniq           #查看CPU型号


========
邮件服务

[root@ecs-web-0003 ~]# yum -y install postfix                  #安装软件包
[root@ecs-web-0003 ~]# systemctl restart postfix               #重启服务
[root@ecs-web-0003 ~]# systemctl enable postfix                #设置为开机自启
[root@ecs-web-0003 ~]# useradd zhai                            #创建用户
[root@ecs-web-0003 ~]# mail -s "fdsfa7777" zhai < /etc/passwd  #给用户发送邮件
[root@ecs-web-0003 ~]# su - zhai                               #切换用户
[zhai@ecs-web-0003 ~]$ mail                                    #收邮件


========
Linux系统优化

一、禁止root账户远程登录
1、修改sshd_config文件
[root@kibana ~]# sed -i 's/#PermitRootLogin yes/PermitRootLogin no/' /etc/ssh/sshd_config
2、重启ssh服务
[root@kibana ~]# systemctl restart sshd


========
所有端口的文件
[root@ecs-5501 ~]# cat /etc/services


========
Linux安装tab命令补全
[root@zhai ~]# yum -y install bash-completion  bash-completion-extras


========
Linux CentOS7安装并启动Google(谷歌)浏览器

1.在火狐浏览器打开网站：https://www.google.cn/chrome/
2.点击“下载Chrome” ，在”下载Chrome（Llinux版）“界面，选择下载： "64 位.rpm（适用于 Fedora/openSUSE）"
3.比如我下载在桌面： google-chrome-stable_current_x86_64.rpm
[root@zyq 桌面]# rpm -qa | grep google-chrome  #
[root@zyq 桌面]# rpm -ivh google-chrome-stable_current_x86_64.rpm  #在root用户下安装
[root@zyq 桌面]# rpm -qa | grep google-chrome                      #查看安装的包
google-chrome-stable-75.0.3770.142-1.x86_64
4.在桌面左上角点击“应用程序”，找到“互联网”，用鼠标将“Google Chrome”拖到桌面，右击“Googlehrome”图标，
点击”属性“，在”属性“界面的“基本”里，将“命令“由原来的字符串/usr/bin/google-chrome-stable %U修改为：
/usr/bin/google-chrome-stable %U --no-sandbox 


========
将两个或多个目录或文件绑定成一个文件夹(文件内容同步和目录同步)(临时的，重启系统后失效)

[root@docker32 ~]# mount --bind /webroot /zhai  #将webroot文件夹和zhai文件绑定成一个文件夹
[root@docker32 ~]# touch /webroot/1.txt
[root@docker32 ~]# ls /zhai
1.txt
[root@docker32 ~]# touch /zhai/2.txt
[root@docker32 ~]# ls /webroot
1.txt  2.txt
[root@docker32 ~]# ls /zhai
1.txt  2.txt


========
Ubuntu安装包命令

apt-get--->yum
dpkg--->rpm
root@9cafbd03e21a:/# apt-get install vim  在ubuntu容器安装vim和rpm


========
查看命令对应的包、所有进程、文件类型和命令所在目录

[root@zyq ~]# yum provides ifconfig  #查看没安装的包
[root@zyq ~]# ps -ef                 #查看所有进程
[root@docker31 ~]# file busybox.tar  #查看文件类型
busybox.tar: POSIX tar archive
[yan@web1 ~]$ which systemctl        #查看命令所在目录


========
vim的窗口切换(分屏)

当用vim写代码的时候，我喜欢一边看着头文件中结构的定义，一边编写实现的代码，这样就经常用到多窗口来编辑，查看文档。
1、同时打开多个文件，并横向排列
vim -o t.c t.h
例:
[root@room9pc01 ~]# vim -o /etc/passwd /etc/hosts  #横向分屏

2、同时打开多个文件后纵向排列，如果没有使用参数o，那么可以在打开文件后操作
vim t.c t.h
:all  #横向
或者
:vertical all  #纵向
例:
[root@room9pc01 ~]# vim /etc/passwd /etc/hosts
:all

3、同一文件分割窗口。如果有一个很长的文件（几千行：）），你想看着前面，来写后面，就要用到这个
#在文件内
:split 或者 :sp

4、关闭窗口
#关闭当前窗口
:close
#保留当前窗口，关闭其他窗口
:only

5、打开一个文件后，又想打开别的文件
按 Ctrl+C 复制代码
#横向打开一个文件
:sp 文件名
#纵向打开一个文件
:vsplit(vsp) 文件名
#打开一个新窗口，注意这时是看不到的
:new 文件名
#纵向打开它
:vnew 文件名
按 Ctrl+C 复制代码

6、在窗口间跳转
ctrl+w j 向下移动
ctrl+w k 向上移动
ctrl+w h 向左移动
ctrl+w l  向右移动
ctrl+w t 移动到顶端
ctrl+w b 移动到底端

7、移动窗口
Ctrl + w + r：向右或向下方交换窗口，而Ctrl + w + R则和它方向相反。
Ctrl + w + x：交换同列或同行的窗口的位置。vim默认交换当前窗口的与它下一个窗口的位置，如果下方没有窗口，则试着与上一个窗口交换位置。亦可在此命令前加上数量，与制定的窗口交换位置。


========
ssh远程执行多行的命令
[root@room9pc01 ~]# ssh root@176.121.212.102  "df -h; ls /etc/"  #远程执行多行条命令
或
[root@room9pc02 ~]# ssh -X root@176.121.212.102 "
> df -h
> ls /etc/ | wc -l
> df -Th
> cat -n /etc/fstab
> "


========
linux的远程端口修改方法

[root@room9pc01 ~]# vim /etc/ssh/sshd_config
17 Port 220                                 #修改端口
[root@room9pc01 ~]# systemctl restart sshd  #重启服务
[root@room9pc01 ~]# systemctl enable sshd   #设置开机自启
[root@room9pc01 ~]# systemctl status sshd   #查看进程信息


========
配置无密码SSH连接和显示日历表

配置目录: /root/.ssh/
[root@node1 ~]# ssh-keygen -f /root/.ssh/id_rsa -N ''
[root@room12pc2 ~]# ssh-copy-id 176.121.212.102
                                             对方IP地址
[root@A ~]# scp /root/.ssh/id_rsa.pub root@192.168.1.181:/root/.ssh/authorized_keys  #将公钥上传给对方
或
[root@cenos57 ~]# ssh-keygen                                                 #创建秘钥对
[root@cenos57 ~]# for i in 51 52 53; do ssh-copy-id root@192.168.4.$i; done  #拷贝公钥给目标主机

上传之后公钥，添加在远程服务器的/root/.ssh/authorized_keys配置文件里

测试(如果秘钥对名称是自定义，远程时要指定私钥路径)
[root@cenos57 ~]# ssh /root/.ssh/zhai root@192.168.4.24

[root@web1 ~]# cal  #显示日历表
      六月 2019     
日 一 二 三 四 五 六
                   1
 2  3  4  5  6  7  8
 9 10 11 12 13 14 15
16 17 18 19 20 21 22
23 24 25 26 27 28 29
30


========
[root@client81 ~]# tree /dome  #查看目录数型结构
/dome
├── source1
│   ├── find
│   └── test.sh
└── source2
    ├── find
    ├── test2.sh
    ├── test.sh
    └── tmp.sh


========
添加网关的命令

[root@client281 ~]# systemctl stop NetworkManager
[root@web81 ~]# route -n                               #查看网关
[root@client281 ~]# route add default gw 192.168.2.80  #添加网关(当前有效)
[root@porxy80 ~]# sysctl -a | grep -i ip_forward 
net.ipv4.ip_forward = 1  #1表示网卡开启中
net.ipv4.ip_forward_use_pmtu = 0
[root@client281 ~]# route del default gw 192.168.2.80  #删除网关, 192.168.2.80是网关(当前删除有效)
或
[root@nfs430 ~]# nmcli connection modify eth0 ipv4.gateway 192.168.4.10  #配置永久网关
[root@nfs430 ~]# nmcli connection up eth0                                #激活网关


========
限制IP SSH(远程) 登录

[root@nfs430 ~]# vim /etc/hosts.deny  
sshd:ALL  #允许全部的 ssh 登录 

[root@nfs430 ~]# vim /etc/hosts.allow  
sshd:192.168.4.12:allow    #允许  这个192.168.4.12 IP地址 ssh 登录
sshd:192.168.0.1/24:allow  #允许 192.168.0.1/24 这段 IP 地址的用户登录

注意:
1、/etc/hosts.deny要配置允许全部的ssh登录
2、如果配置文件/etc/hosts.deny 允许全部的 ssh 登录，
而配置文件/etc/hosts.allow没做配置，等于拒绝所有IP远程


############################################################################
1.Admin

Admin_day01=================================================================
﻿牛犇

 第一阶段课程内容共19天
 云计算系统管理、 云计算应用管理、系统&服务管理进阶

 云计算系统管理	
	DAY01	开学典礼、云网络基础			
   	DAY02	Linux系统简介、安装Linux系统、Linux基本操作		
	DAY03	命令行基础、目录和文件管理			
	DAY04	管理用户和组、tar备份与恢复、cron计划任务		
	DAY05	教学环境介绍、权限和归属			
	DAY06	软件包管理、分区规划及使用、NTP时间同步	
	DAY07	LVM逻辑卷、综合串讲、综合练习		

		
 云计算应用管理	
	DAY01	Shell脚本基础、使用变量、条件测试及选择、列表式循环
	DAY02	系统安全保护、配置用户环境、防火墙策略管理			
	DAY03	ISCSI共享存储、数据库服务基础、管理表数据	
	DAY04	配置NFS共享、HTTP服务基础		
	DAY05	网页内容访问、部署动态网站、安全Web服务	
	DAY06	综合串讲、综合练习		


 系统&服务管理进阶	
	DAY01	扩展的几个应用、发布网络YUM源、vim编辑技巧、源码编译安装	
	DAY02	KVM构建及管理、virsh控制工具、镜像管理、虚拟机快建技术
	DAY03	DNS服务基础、特殊解析、DNS子域授权、缓存DNS
	DAY04	Split分离解析、RAID磁盘阵列、进程管理、日志管理、systemctl控制
	DAY05	批量装机环境、配置PXE引导、kickstart自动应答	
	DAY06	rsync同步操作、inotify实时同步、Cobbler网络装机		
			
##################################################################################################

  准备笔记本与笔（默写），U盘（后期存储备份教学数据）
  先讲解后练习，勤奋的练习


##################################################################
一 教学环境
1.真机是Linux   账户:student  密码:tedu
      
2.虚拟化软件: 虚拟众多的硬件
      虚拟机被损坏,与真机无关


########################################
典型服务模式
• C/S,Client/Server架构
– 由服务器提供资源或某种功能
– 客户机使用资源或功能


##############################################
TCP/IP协议简介
• TCP/IP是最广泛支持的通信协议集合
 – 包括大量Internet应用中的标准协议
 – 支持跨网络架构、跨操作系统平台的通信

• 主机与主机之间通信的三个要素　　　　　
 – IP地址(IP address)
  – 子网掩码(subnet mask)
 – IP路由(IP router):涉及路由器

#################################################
IP地址(IP address):唯一标识网络中一个节点地址
• 地址组成(点分十进制):
– 一共32个二进制数
　11110000.00001111.10101010.11111100

　　 11111111 = 255

  例子： 　1.2.3.4   192.168.1.1    10.11.12.13

#################################################

为虚拟机win2008配置IP地址
利用管理员进行登录，密码为：tedu


配置IP地址：　　192.168.1.1　　子网掩码：255.255.255.0
– 右击桌面网络 --＞属性 --＞更改适配器设置
– 双击“本地连接” --＞ 属性
– 双击“Internet协议版本4(TCP/IPv4)”　　　
– 配置完成后,单击“确定”完成

查看IP地址：　
– 右击桌面网络 --＞属性 --＞更改适配器设置
– 双击“本地连接” --＞ 详细信息

采用ipconfig命令的方式，查看IP地址：
   　windows键　＋　ｒ＝　开始＋运行
　　　输入cmd-->敲回车--＞输入　ipconfig-->敲回车
　　　--＞输入　exit　关闭命令行界面

################################################
• IP地址的分类
– A类:1 ~ 127       　网+主+主+主
– B类:128 ~ 191  　 网+网+主+主
– C类:192 ~ 223   　网+网+网+主

• 组播及科研专用
– D类:224 ~ 239 组播
– E类:240 ~ 254 科研


   192.168.1.1=只看ip地址的第一个数字,进行判别分类


################################################
IP地址由网络位与主机位，两部来组成
 网络位=座机号码的区号，标识一个网络
 主机位=编号

子网掩码：用来区分IP地址的网络位与主机位
　　　　　利用二进制的１标识网络位
　　　　　利用二进制的0标识主机位
　192.168.1.1＝11000000.10101000.00000001.00000001
                        11111111.11111111.11111111.00000000
                         255.255.255.0

　座机号码：区号－号码（编号）
　　北京：010－12345678＝北京区域，编号为12345678的座机
　　石家庄：0311－7354444＝石家庄区域,编号为7354444的座机

　区号：标识区域

　192.168.1.1　＝　192.168.1网络，编号为１的主机
　192.168.１.2　＝　192.168.１网络，编号为２的主机
　相同网络通信，网络位相同

　192.168.1.1  255.255.255.0 = 192.168.1.1/24

   192.168.1.1/24 :该IP地址有24个网络位

　1.该IP地址是哪一类 　 2.判别网络位与主机位
################################################
克隆虚拟机win2008　　　　　　　　　　
1.关闭虚拟机win2008
2.进行虚拟机克隆
　双击＂虚拟系统管理器＂--＞右击＂win2008＂--＞克隆--＞克隆

3.修改win2008-clone桌面背景
  双击＂控制面板＂--＞显示--＞更改桌面背景---＞保存修改

4.配置win2008-clone的IP地址：192.168.1.2  255.255.255.0
　
 – 右击桌面网络 --＞属性 --＞更改适配器设置
 – 双击“本地连接” --＞ 属性
 – 双击“Internet协议版本4(TCP/IPv4)”　　　
 – 配置完成后,单击“确定”完成

采用ipconfig命令的方式，查看IP地址：
   　windows键　＋　ｒ＝　开始＋运行
　　　输入cmd-->敲回车--＞输入　ipconfig-->敲回车
　　　--＞输入　exit　关闭命令行界面

################################################
采用命令方式，测试网络联通性：
　　ping　　命令
　　ping  　对方IP地址　　　ping命令是双向，有去有回
　　ping 　192.168.1.1　

　　ping 　192.168.1.２　

###############################################
　ftp://172.40.50.114

###############################################
网关地址:一个网络到另一个网络的关口　（解决不同网络通信）

DNS服务器：将网站的域名解析为,对应的IP地址
  
         www.qq.com-------＞腾讯的服务器
         www.baidu.com-------＞百度的服务器

###############################################

Admin_day02============================================================================

###############################################
Linux系统简介

什么是Linux?
Linux是一种操作系统：可以让计算机硬件正常工作

Unix/Linux发展史
• UNIX诞生，1970-1-1

Linux的诞生                                            
• Linux之父,Linus Torwalds
– 1991年10月,发布0.02版(第一个公开版)内核
– 1994年03月,发布1.0版内核
– 标准读音:　哩呐科斯

版本号:主版本.次版本.修订号

Linux发行版本
• 发行版的名称/版本由发行方决定
– Red Hat Enterprise Linux（RHEL） 5/6/7
– Suse Linux Enterprise 12
– Debian Linux 7.8
– Ubuntu Linux 14.10/15.04
– ......
################################################
• CentOS,社区企业操作系统
– Community Enterprise Operating System
– http://www.centos.org/

• 基于Linux的企业服务器
• 嵌入式系统
• 高性能大型运算

###############################################
安装Linux系统
CentOS,社区企业操作系统,建议2G以上内存

 Ctrl + Alt = 鼠标回到真机

#################################################
预备知识

Linux目录结构：树型结构
• 最顶层为根目录(/)
– Unix/Linux的基本哲学理念:一切皆文件

　　根目录(/)：所有的数据都在此目录下（Linux系统的起点）

      路径：/abc/nsd/1.txt
   /dev：存放设备(硬盘或键盘或鼠标或显示器.....)相关的数据

Linux管理员用户为:root  　　进行登录


Linux磁盘表示

　hd,表示IDE设备
　sd,表示SCSI设备
　vd,表示虚拟设备

　/dev/sda:表示SCSI设备，第一块
　/dev/sdb:表示SCSI设备，第二块
　/dev/sdc:表示SCSI设备，第三块
　/dev/sdd:表示SCSI设备，第四块
#################################################
Linux基本操作

命令行基本操作
获取命令行界面
• 虚拟控制台切换( Ctrl + Alt + Fn 组合键)
– tty1:图形桌面
– tty2~tty6:字符控制台

• 右键 "打开终端"
    编辑--->配置文件首选项--->修改字体大小

• 命令行提示标识的含义
– [当前用户@主机名 工作目录]$

– 若当前用户是root,则最后一个字符为 #
[root@svr7 桌面]#
– 否则,最后一个字符为 $
[teacher@svr7 桌面]$

 Ctrl  shift 　+ =　终端字体变大
 Ctrl  － =　终端字体变小

##################################################
查看及切换目录

• pwd — Print Working Directory
– 用途:查看当前工作目录

• cd — Change Directory
– 用途:切换工作目录
– 格式:cd [目标文件夹位置]

• ls — List
– 格式:ls [选项]... [目录或文件名]...


[root@localhost ~]# pwd        #显示当前所在位置
[root@localhost ~]# cd /abc　　　　＃切换到/abc目录
bash: cd: /abc: 没有那个文件或目录
[root@localhost ~]# cd   /　　　　　＃切换到　/　目录
[root@localhost /]# pwd
[root@localhost /]# ls　　　　　＃显示当前目录内容

[root@localhost /]# cd /boot
[root@localhost /boot]# pwd
[root@localhost /boot]# ls

[root@localhost /]# cd /opt
[root@localhost /opt]# pwd
[root@localhost /opt]# ls
　颜色：
　　蓝色：目录
　　黑色：文件
  
[root@localhost /]# ls
[root@localhost /]# ls /root
[root@localhost /]# ls /home
[root@localhost /]# ls /opt
[root@localhost /]# ls /boot
[root@localhost /]# ls /root

]# ls /root/anaconda-ks.cfg
]# cat /root/anaconda-ks.cfg  #查看文件内容
]# cat /etc/passwd　　　#查看文件内容
]# cat /etc/hosts　　　　#查看文件内容
]# cat /etc/fstab　　　　#查看文件内容
]# cat /etc/redhat-release　#查看当前系统版本

###############################################
以 / 开始的绝对路径

以当前为参照的相对路径

[root@localhost /]# cd /etc/pki/
[root@localhost pki]# pwd
[root@localhost pki]# ls
[root@localhost pki]# cd /etc/pki/CA    #绝对路径
[root@localhost CA]# pwd

[root@localhost CA]# cd /etc/pki/
[root@localhost pki]# pwd
[root@localhost pki]# ls
[root@localhost pki]# cd CA　　　　＃相对路径
[root@localhost CA]# pwd

[root@localhost CA]# cd /
[root@localhost /]# ls root     #相对路径
[root@localhost /]# ls /root    #绝对路径

###############################################
 　　.. :表示上一级目录　　　　　　　　　

[root@localhost /]# cd ..   　　　　#后退
[root@localhost /]# cd /etc/pki/
[root@localhost pki]# pwd
/etc/pki
[root@localhost pki]# cd ..
[root@localhost etc]# pwd
/etc
[root@localhost etc]# cd ..
[root@localhost /]# pwd
/
[root@localhost /]# cd /etc/pki/
[root@localhost pki]# cd ../..　　　＃一次性后退两层
[root@localhost /]# pwd
#################################################
• 真机列出CPU处理器信息
[root@svr7 桌面]# lscpu
.......
CPU(s):                4
.......
型号名称：        Intel(R) Core(TM) i5-4430S CPU @ 2.70GHz
.......

• 真机检查内存大小、空闲情况
[root@svr7 桌面]# cat /proc/meminfo
MemTotal:       16330728 kB
.......

查看主机名和IP信息
• 列出当前系统的主机名称
[root@localhost /]# hostname　　#查看当前主机名
localhost.localdomain
[root@localhost /]# hostname　 A.tedu.cn  #临时设置

[root@localhost /]# hostname　　#查看当前主机名

[root@localhost /]# exit   　　 #关闭当前终端
开启一个新的终端进行验证：
[root@A /]#　hostname

• 列出已激活的网卡连接信息
[root@A ~]# ifconfig　　　　　　　　　　　#查看IP地址信息
[root@A ~]# ifconfig eth0 192.168.1.1　#临时设置IP地址
[root@A ~]# ifconfig eth0

[root@A ~]# ping  192.168.1.1
按Ctrl + c 结束正在运行的命令

lo: 本地回环接口，专用于测试
        inet 127.0.0.1  netmask 255.0.0.0

　　127.0.0.1：永久代表本机

[root@A ~]# ping  127.0.0.1
按Ctrl + c 结束正在运行的命令

##########################################
可以永久设置主机名与IP地址与子网掩码与网关地址与DNS服务器地址

修改主机名：设置系统主机名-->输入新的名字-->确定-->确定
[root@A ~]# nmtui
[root@nsd1903 ~]# hostname
nsd1903.tedu.cn
[root@nsd1903 ~]# 

修改IP地址与子网掩码　
[root@A ~]#　nmtui
　编辑连接 -->eth0-->编辑ipv4-->显示-->将自动修改手动
　-->按空格　勾选　自动连接    　    #每次开机自动生效
　-->按空格　勾选　对所有用户有效  

激活配置
[root@A ~]#　nmtui
　启用连接 -->eth0-->敲回车　禁用-->敲回车　激活
　最终eth0前面有一个＊代表激活状态

###############################################

创建文档
• mkdir — Make Directory
– 格式:mkdir  [/路径/]目录名...
[root@nsd1903 ~]# mkdir nsd01 　　  #当前创建目录
[root@nsd1903 ~]# pwd
/root
[root@nsd1903 ~]# ls
[root@nsd1903 ~]# mkdir /opt/nsd02　＃在指定路径下创建
[root@nsd1903 ~]# ls /opt/
• touch命令
– 用途:新建空文件　格式:touch 文件名...
[root@nsd1903 ~]# touch  1.txt　　　　#当前创建文件
[root@nsd1903 ~]# ls
[root@nsd1903 ~]# touch  /opt/2.txt　＃在指定路径下创建
[root@nsd1903 ~]# ls /opt/


文本内容操作
• less分屏阅读工具
• 格式:less [选项] 文件名...

– 优势:支持前后翻页
• 基本交互操作
– 按 / 键向后查找(n、N切换)

[root@nsd1903 ~]# less /etc/passwd
　　按键盘　上　下　可以进行滚动
　　/a   　　#全文查找ａ　(n、N切换)
　　按ｑ退出

• head、tail 命令
– 格式:　head -n 数字 文件名
　　　　tail -n 数字 文件名

[root@nsd1903 ~]# head -2 /etc/passwd  #显示头两行内容
[root@nsd1903 ~]# head -3 /etc/passwd

[root@nsd1903 ~]# tail -2 /etc/passwd　＃显示尾两行内容
[root@nsd1903 ~]# tail -3 /etc/passwd


• grep工具
– 用途:输出包含指定字符串的行
– 格式:grep 　'查找条件' 　　目标文件

[root@nsd1903 ~]# grep　 root  　/etc/passwd

[root@nsd1903 ~]# grep 　a　 /etc/passwd

#############################################
关机及重启操作
• 关机:poweroff
[root@svr7 ~]# poweroff

• 重启:reboot
[root@svr7 ~]# reboot

#############################################
编辑命令或路径的技巧：　Tab可以进行补全       
[root@nsd1903 ~]# if(tab)(tab)
if         ifdown     ifup
ifcfg      ifenslave  
ifconfig   ifstat     
[root@nsd1903 ~]# ifco(tab)

[root@nsd1903 ~]# cat /et(tab)/red(tab)
CentOS Linux release 7.5.1804 (Core)
 
]# ls /etc/sysconfig/network-scripts/ifcfg-eth0 

]# ls /et(tab)/sysco(tab)/netw(tab)-(tab)/ifc(tab)-e(tab)

Admin_day03===========================================================================================

如何编写命令行　　　　　　　　

• Linux命令
– 用来实现某一类功能的指令或程序
　　在Linux中执行大多数命令，都要找到相应的程序，将程序运行

– 命令的执行依赖于解释器(默认的解释器：/bin/bash)

　绿色：可以执行的程序

　内核：可以调配计算机硬件资源

　用户的指令------＞解释器------＞内核------＞调配计算机硬件

################################################
命令行的一般格式

• 基本用法
– 命令字     [选项]...     [参数1]    [参数2]...

– 短选项:-l、-A、-c、-d、.. ..
– 多个短选项-->复合选项:-lh、-lA、-ld、.. ..
– 长选项:--help、.. ..


查看命令的帮助信息
　　格式： 命令　 --help
 
[root@nsd1903 ~]# cat  --help
[root@nsd1903 ~]# cat  -n  /etc/passwd      #添加行号
[root@nsd1903 ~]# cat  -n  /etc/redhat-release 

[root@nsd1903 ~]# head -2 /etc/passwd
[root@nsd1903 ~]# tail -3 /etc/passwd

#################################################
快速编辑技巧

• Tab键自动补全
 – 可补齐命令字、选项、参数、文件路径、软件名、服务名

• 快捷键　　　　　　　　　　　　　　
 – Ctrl + l:清空整个屏幕
 – Ctrl + c:废弃当前编辑的命令行（结束正在运行的命令）
 – Esc + . 或 Alt + .:粘贴上一个命令的参数

 – Ctrl + u:清空至行首
 – Ctrl + k:清空至行尾
 – Ctrl + w:往回删除一个单词(以空格界定)

[root@nsd1903 ~]# ls /etc/redhat-release 
/etc/redhat-release
[root@nsd1903 ~]# cat 　Alt + .
[root@nsd1903 ~]# cat -n 　Alt + .
[root@nsd1903 ~]# head -1　 Alt + .

　青色：快捷方式
#################################################
mount挂载操作:　让目录成为设备的访问点

安装软件，前提具备软件的安装包
１.互联网下载
２.从光盘中获得软件安装包

#############################################
Windows读取光盘的内容
 光盘-----＞光驱设备-----＞CD驱动器图标(访问点)


如何让Linux读取光盘的内容
 光盘-----＞光驱设备-----＞访问点(自己创建目录)　　/dvd
          /dev/hdc
          /dev/sr0
 访问点就是一个目录


1.图形利用鼠标，将光盘放入，虚拟光驱设备
2.命令行查看光驱设备
[root@nsd1903 ~]# ls /dev/sr0
/dev/sr0
[root@nsd1903 ~]# ls /dev/cdrom
/dev/cdrom
[root@nsd1903 ~]# ls -l /dev/cdrom   #显示详细信息
lrwxrwxrwx. 1 root root 3 4月   3 10:58 /dev/cdrom -> sr0
３.创建访问点
[root@nsd1903 ~]# mkdir /dvd
[root@nsd1903 ~]# ls /
[root@nsd1903 ~]# ls /dvd

• 使用mount命令
– 格式:mount 　设备路径　　　 挂载点目录
[root@nsd1903 ~]# mount　 /dev/cdrom 　/dvd/

[root@nsd1903 ~]# ls /dvd
[root@nsd1903 ~]# ls /dvd/Packages/

　　煤矿------＞洞口

• 使用umount命令
– 格式:umount 挂载点目录
[root@nsd1903 ~]#　umount /dvd
[root@nsd1903 ~]# ls /dvd
[root@nsd1903 ~]#　mkdir /abc
[root@nsd1903 ~]#　mount /dev/cdrom  /abc
[root@nsd1903 ~]# ls /abc

注意：
　１.当前路径不要在挂载点目录内
[root@nsd1903 dvd]# umount /dvd/
umount: /dvd：目标忙。
        (有些情况下通过 lsof(8) 或 fuser(1) 可以
         找到有关使用该设备的进程的有用信息)

   2.允许一个设备，具有多个不同的挂载点
   3.一个挂载点，不允许挂载多个设备
  ４.挂载点的选择，自己创建的目录

#################################################
目录和文件管理

• pwd — Print Working Directory
– 用途:查看当前工作目录

• cd — Change Directory
– 用途:切换工作目录
– 格式:cd [目标文件夹位置]
   
　　/root：Linux中管理员的家目录
　　/home:存放所有普通用户家目录

    ~:用户家目录
  ~user表示用户user的家目录
[root@nsd1903 /]# useradd  tom   #创建用户tom
[root@nsd1903 /]# ls /home/

[root@nsd1903 /]# useradd dc    #创建用户dc
[root@nsd1903 /]# ls /home/

[root@nsd1903 /]# cd ~dc    #切换到普通用户dc的家目录
[root@nsd1903 dc]# pwd
[root@nsd1903 dc]# cd ~tom
[root@nsd1903 tom]# pwd


  . 表示当前目录,经常与复制命令连用
  .. 表示父目录
################################################
ls 列出文档及属性

• ls — List
– 格式:ls [选项]... [目录或文件名]

• 常用命令选项
 – -l:以长格式显示,显示详细属性
 – -A:包括名称以 . 开头的隐藏文档
 – -d:显示目录本身(而不是内容)的属性
 – -h:提供易读的容量单位(K、M等)

]# ls -l /etc/redhat-release 

]# ls -l /etc/passwd
]# ls -l /etc/fstab 
]# ls -l /etc/sysconfig/network-scripts/ifcfg-eth0 
]# ls -l /root/　　　　＃显示目录内容的详细属性
]# ls -l /

]# ls -l /etc/passwd
]# ls -l -h /etc/passwd
]# ls -lh /etc/passwd　　　#显示详细属性时，加上大小单位
]# ls -lh /var/log/messages  

]# ls -ld  /root    #显示目录本身的详细属性
]# ls -ld  /
　　　　　　　　　　　　　　　
]# ls -A /root　　　　　＃显示目录的全部内容，包括隐藏数据
]# touch /opt/.nsd01.txt
]# ls /opt/
]# ls -A /opt/

#################################################
使用通配符

• 针对不确定的文档名称,以特殊字符表示
– *:任意多个任意字符
– ?:单个字符
[root@nsd1903 ~]# ls /root/a*    #显示/root下以a开头
/root/anaconda-ks.cfg

[root@nsd1903 ~]# ls /boot/vm*

[root@nsd1903 ~]# ls /dev/tty*　　#显示/dev下以tty开头

[root@nsd1903 ~]# ls /etc/*tab  　#显示/etc下以tab结尾
[root@nsd1903 ~]# ls /etc/*.conf

显示以r开头，以.conf结尾
[root@nsd1903 ~]# ls /etc/r*.conf
[root@nsd1903 ~]# ls /dev/tty*
[root@nsd1903 ~]# ls /dev/tty?
[root@nsd1903 ~]# ls /dev/tty??
[root@nsd1903 ~]# ls /dev/tty???

• 针对不确定的文档名称,以特殊字符表示
– [a-z]:多个字符或连续范围中的一个,若无则忽略
– {a,min,xy}:多组不同的字符串,全匹配

[root@nsd1903 ~]# ls /dev/tty[1-8]

[root@nsd1903 ~]# ls /dev/tty[3-6]

[root@nsd1903 ~]# ls /dev/tty{1,3,5,7,9,21}

[root@nsd1903 ~]# ls /dev/tty{38,S0}

##############################################
别名的定义:简化复杂的命令

• 查看已设置的别名
– alias [别名名称]
• 定义新的别名
– alias 别名名称= '实际执行的命令行'
• 取消已设置的别名
– unalias [别名名称]

[root@nsd1903 ~]# hostname      
nsd1903.tedu.cn
[root@nsd1903 ~]# hn
bash: hn: 未找到命令...
[root@nsd1903 ~]# alias hn='hostname'　　＃定义别名
[root@nsd1903 ~]# hn
nsd1903.tedu.cn
[root@nsd1903 ~]# alias      　　 #显示所有有效别名
[root@nsd1903 ~]# unalias hn　　　＃删除hn别名
[root@nsd1903 ~]# hn
bash: hn: 未找到命令...
[root@nsd1903 ~]# 

###############################################
mkdir 创建目录

• mkdir — Make Directory
– 格式:mkdir [-p] [/路径/]目录名...
   -p:创建父目录
[root@server0 ~]#  mkdir -p /vod/movie/cartoon
[root@server0 ~]#　ls /vod
[root@server0 ~]#　ls /vod/movie

[root@nsd1903 ~]#  mkdir -p /opt/aa/bb/cc/dd
[root@nsd1903 ~]#  ls /opt/
[root@nsd1903 ~]#  ls /opt/aa
[root@nsd1903 ~]#  ls /opt/aa/bb/
[root@nsd1903 ~]#  ls /opt/aa/bb/cc/

rm 删除
• rm — Remove
– 格式:rm [选项]... 文件或目录...
• 常用命令选项
– -r、-f:递归删除(含目录)、强制删除
    -r:递归,目录本身以及目录下所有

[root@nsd1903 ~]# mkdir /opt/nsd01
[root@nsd1903 ~]# mkdir /opt/nsd02
[root@nsd1903 ~]# touch /opt/1.txt
[root@nsd1903 ~]# ls /opt/
1.txt  nsd01  nsd02
[root@nsd1903 ~]# rm -rf /opt/1.txt
[root@nsd1903 ~]# ls /opt/
nsd01  nsd02
[root@nsd1903 ~]# rm -rf /opt/* 
[root@nsd1903 ~]# ls /opt/
################################################
mv 移动/改名

• mv — Move
– 格式:mv   原文件      目标路径
[root@nsd1903 ~]# rm -rf /opt/*
[root@nsd1903 ~]# mkdir /opt/nsd
[root@nsd1903 ~]# touch /opt/1.txt
[root@nsd1903 ~]# ls /opt/
[root@nsd1903 ~]# mv /opt/1.txt  /opt/nsd
[root@nsd1903 ~]# ls /opt/
nsd
[root@nsd1903 ~]# ls /opt/nsd

重命名：路径不变的移动
[root@nsd1903 ~]# ls /opt/
[root@nsd1903 ~]# mv /opt/nsd/  /opt/abc
[root@nsd1903 ~]# ls /opt/

[root@nsd1903 ~]# mv /opt/abc/ /opt/student
[root@nsd1903 ~]# ls /opt/
#################################################
cp 复制

• cp — Copy
– 格式:cp [选项]... 原文件     目标路径

• 常用命令选项
– -r:递归,复制目录时必须有此选项

[root@nsd1903 ~]# rm -rf /opt/*
[root@nsd1903 ~]# cp /etc/passwd /opt/
[root@nsd1903 ~]# ls /opt/

[root@nsd1903 ~]# cp /etc/fstab  /opt/
[root@nsd1903 ~]# ls /opt/

[root@nsd1903 ~]# cp -r /home/ /opt/
[root@nsd1903 ~]# ls /opt/

[root@nsd1903 ~]# cp -r /boot/ /opt/
[root@nsd1903 ~]# ls /opt/

复制时出现同名进行覆盖
在本次命令执行，临时取消别名的操作
[root@nsd1903 ~]# cp -r /boot/ /opt/
cp：是否覆盖"/opt/boot/grub2/device.map"？
 按 Ctrl + c　取消操作
[root@nsd1903 ~]# \cp -r /boot/ /opt/
[root@nsd1903 ~]# \cp -r /boot/ /opt/


复制可以支持两个以上的参数，永远会把最后一个参数作为目标，其它的所有参数都会作为源
]# cp -r /root /etc/shadow    /etc/hosts /etc/login.defs  /opt/
]# ls /opt/

复制可以与　．　连用：将源数据，复制到当前路径下
]# cd /opt/
]# pwd
]# cp /etc/resolv.conf  .
]# ls
]# cd /etc/sysconfig/network-scripts/
]# pwd
]# cp /etc/passwd  .
]# ls

复制时，可以重新命名目标路径下的名称

[root@nsd1903 /]# rm -rf /opt/*
[root@nsd1903 /]# cp /etc/passwd /opt/
[root@nsd1903 /]# ls /opt/

[root@nsd1903 /]# cp /etc/passwd /opt/nsd
[root@nsd1903 /]# ls /opt/

[root@nsd1903 /]# cp -r /boot/ /opt/abc
[root@nsd1903 /]# ls /opt/

请描述下列，两次复制的不同：
[root@nsd1903 /]# rm -rf /opt/*
[root@nsd1903 /]# cp -r /home/  　/opt/test
[root@nsd1903 /]# cp -r /home/　 /opt/test
　第一次复制，将/home复制到/opt目录下改名为test
　第二次复制，将/home复制到/opt/test目录下
##############################################
Linux文件的最后必须没有 /  

##############################################


Admin_day04===========================================================================================
使用vim创建/修改文件内容

  三模式：命令模式　　　插入模式（输入模式）　　末行模式

[root@nsd1903 ~]# vim /opt/xiha.txt

	命--------i 键---＞插入模式(Esc 键回到命令模式)
	令
	模
	式--------: 键---＞ 末行模式 (Esc 键回到命令模式)

   末行模式  :wq 　保存并退出
　　　　　　:q! 　强制不保存并退出



查找文本内容
• 根据字符串模式提取文本行
– grep [选项] '匹配模式' 文本文件...
　
• 常用命令选项　　　　　　　　
– -v,取反匹配
– -i,忽略大小写

[root@nsd1903 ~]# grep root /etc/passwd

[root@nsd1903 ~]# grep Root /etc/passwd
[root@nsd1903 ~]# grep -i Root /etc/passwd

]# grep -v root /etc/passwd　　#不包含root的行


• 常用的匹配模式
– word　 包含字符串word
– ^word 　以字符串word开头
– word$ 　以字符串word结尾

[root@nsd1903 ~]# grep root /etc/passwd

[root@nsd1903 ~]# grep ^root /etc/passwd

[root@nsd1903 ~]# grep root$ /etc/passwd
[root@nsd1903 ~]# grep bash$ /etc/passwd

##############################################
重定向输出操作：将前面命令的输出，写入到后面文本文件中

　　>：覆盖重定向
　　＞>：追加重定向
[root@nsd1903 ~]# ls --help
[root@nsd1903 ~]# ls --help > /opt/ls.txt
[root@nsd1903 ~]# less  /opt/ls.txt

[root@nsd1903 ~]# hostname
[root@nsd1903 ~]# hostname > /opt/ls.txt 
[root@nsd1903 ~]# cat /opt/ls.txt
[root@nsd1903 ~]# hostname >> /opt/ls.txt 
[root@nsd1903 ~]# cat /opt/ls.txt

]# cat /etc/redhat-release    >> /opt/ls.txt 
]# cat /opt/ls.txt

[root@nsd1903 ~]# echo 123456

[root@nsd1903 ~]# echo 123456 > /opt/ls.txt 
[root@nsd1903 ~]# cat /opt/ls.txt

[root@nsd1903 ~]# echo NSD1903 >> /opt/ls.txt 
[root@nsd1903 ~]# cat /opt/ls.txt

###############################################
管道操作:连接或桥梁
    | :将前面命令的输出，传递给后面命令，当做后面命令的参数

　/etc/passwd文件的８到12行内容
　]# head -12 /etc/passwd     |　 tail -5 

　]# head -12 /etc/passwd    | tail -5  | cat -n

　]# cat -n /etc/passwd　 |　 head -12　 | 　tail -5
　
　]# ifconfig | head -2
　]# ifconfig | less

################################################
管理用户和组           
  
     用户： 1.登录操作系统　　２.方便对不同用户进行访问控制
　　组:方便管理用户

　　用户唯一标识： UID 
　　组唯一标识： GID 

   　Linux管理员root的UID永远为0

	Linux一个用户至少属于一个组
　　基本组：与用户同名，有系统创建加入完成
　　附加组（从属组）：管理员创建加入完成


添加用户
用户基本信息存放在 /etc/passwd 文件（系统级配置文件）

　root:x:0:0:root:/root:/bin/bash
用户名:密码占位符:UID:基本组的GID:用户描述信息:家目录:解释器

• 使用 useradd 命令
– useradd [选项]... 用户名
• 常用命令选项
– -u 用户id、-d 家目录路径、-s 登录解释器、-G 附加组

[root@nsd1903 ~]# useradd nsd01
[root@nsd1903 ~]# ls /home/

[root@nsd1903 ~]# id nsd01  #查看用户基本信息

[root@nsd1903 ~]# id haxi
id: haxi: no such user

[root@nsd1903 ~]# grep nsd01 /etc/passwd #查看用户信息

[root@nsd1903 ~]# useradd  nsd02
[root@nsd1903 ~]# grep nsd /etc/passwd

[root@nsd1903 ~]# useradd -u 1600 nsd03  ＃指定UID创建
[root@nsd1903 ~]# grep nsd /etc/passwd
[root@nsd1903 ~]# useradd  nsd04
[root@nsd1903 ~]# grep nsd /etc/passwd

]# useradd -d /mnt/abc nsd06　　＃指定用户的家目录创建
]# grep nsd06 /etc/passwd


-s 登录解释器
　/sbin/nologin：禁止用户登录系统的解释器
[root@nsd1903 ~]# useradd -s /sbin/nologin  nsd07
[root@nsd1903 ~]# grep nsd07 /etc/passwd

-G 附加组
[root@nsd1903 ~]# groupadd tarena　　　　＃创建组
[root@nsd1903 ~]# useradd -G tarena nsd08
[root@nsd1903 ~]# id nsd08
uid=1605(nsd08) gid=1606(nsd08) 组=1606(nsd08),1605(tarena)

#############################################
设置登录密码

• 使用 passwd 命令
– passwd [用户名]
[root@nsd1903 ~]# useradd nsd10
[root@nsd1903 ~]# passwd nsd10
更改用户 nsd10 的密码 。
新的 密码：　　　　　　　　　　＃设置新的密码
无效的密码： 密码少于 8 个字符
重新输入新的 密码：　　　　　　　＃重新输入新的密码
passwd：所有的身份验证令牌已经成功更新。
[root@nsd1903 ~]# su - nsd10    #命令行临时切换身份
[nsd10@nsd1903 ~]$ passwd 
更改用户 nsd10 的密码 。
为 nsd10 更改 STRESS 密码。
（当前）UNIX 密码：　　　　　　　　＃输入旧密码
新的 密码：　　　　　　　　　　　　 ＃设置新的密码
重新输入新的 密码：　　　　　　　　 ＃重新输入新的密码
passwd：所有的身份验证令牌已经成功更新。
[nsd10@nsd1903 ~]$ exit



非交互式设置密码
– echo '密码'　　 | 　　passwd 　--stdin　 用户名

[root@nsd1903 ~]# echo 123 | passwd --stdin nsd10
更改用户 nsd10 的密码 。
passwd：所有的身份验证令牌已经成功更新。

[root@nsd1903 ~]# echo redhat | passwd --stdin nsd10
更改用户 nsd10 的密码 。
passwd：所有的身份验证令牌已经成功更新。

###############################################
用户密码信息存放在 /etc/shadow 文件
[root@nsd1903 ~]# tail -1 /etc/shadow
nsd10:$6$pOWNdlhE$z9/irH93UkWigQr0FQgPC.3NmZGfVMtr6oym4
jWMWFCKRGeq4qYOysgXCR.1q9ztNfMJ91HJxGG34
V3Jq3b0n/:17990:０:99999:7:::

 用户名:密码加密字符串:上一次修改密码的时间    

#################################################
修改用户属性

• 使用 usermod 命令
– usermod [选项]... 用户名

• 常用命令选项
– -u 用户id、-d 家目录路径、-s 登录解释器
– -G 附加组

[root@nsd1903 ~]# useradd nsd11
[root@nsd1903 ~]# grep nsd11 /etc/passwd
[root@nsd1903 ~]# id nsd11

]# usermod -u 1700 -d /opt/nsd11 -G tarena -s /sbin/nologin  nsd11

]# id  nsd11

]# grep nsd11 /etc/passwd

]# usermod -l newftp ftp #修改用户名,newftp是新用户名，ftp是旧用户名


#################################################
删除用户

• 使用 userdel 命令
– userdel [-r] 用户名
    -r:连同家目录一并删除

[root@server0 ~]# userdel -r alex
[root@server0 ~]# id alex
id: alex: no such user

###############################################
管理组账号

添加组
组基本信息存放在 /etc/group 文件
[root@nsd1903 ~]# grep  stugrp  /etc/group
 stugrp:x:1610:
  组名:组的密码占位符:组的GID编号:组的成员列表

• 使用 groupadd 命令
– groupadd [-g 组ID] 组名

[root@nsd1903 ~]# groupadd stugrp
[root@nsd1903 ~]# grep stugrp /etc/group
stugrp:x:1610:
[root@nsd1903 ~]# useradd kenji
[root@nsd1903 ~]# useradd jack
[root@nsd1903 ~]# useradd natasha
[root@nsd1903 ~]# useradd kaka

管理组成员
组成员信息存放在 /etc/gshadow 文件
• 使用 gpasswd 命令
– gpasswd -a 用户名 　组名
– gpasswd -d 用户名　 组名

[root@nsd1903 ~]# gpasswd -a kenji stugrp
[root@nsd1903 ~]# grep stugrp /etc/group

[root@nsd1903 ~]# gpasswd -a natasha stugrp
[root@nsd1903 ~]# grep stugrp /etc/group

[root@nsd1903 ~]# gpasswd -a kaka stugrp
[root@nsd1903 ~]# grep stugrp /etc/group

[root@nsd1903 ~]# gpasswd -d kaka stugrp
[root@nsd1903 ~]# grep stugrp /etc/group

[root@nsd1903 ~]# gpasswd -a jack stugrp
[root@nsd1903 ~]# grep stugrp /etc/group

##################################################
删除组

• 使用 groupdel 命令
– groupdel 组名
[root@nsd1903 ~]# groupdel stugrp
[root@nsd1903 ~]# grep stugrp /etc/group

#################################################
tar备份与恢复
  
  Linux压缩格式：
      -z  gzip ----＞　.gz
　　　-j bzip2 ----＞ .bz2
      -J  xz ----＞ .xz


归档和压缩
• 归档的含义
– 将许多零散的文件整理为一个文件
– 文件总的大小基本不变

• 压缩的含义
– 按某种算法减小文件所占用空间的大小
– 恢复时按对应的逆向算法解压

• tar 集成备份工具
– -c:创建tar包
– -x:释放tar包
– -f:指定tar包文件名称
– -z、-j、-J:调用 .gz、.bz2、.xz 格式的工具进行处理
– -t:显示tar包的文件清单
– -C:指定释放路径

tar制作压缩包（tar包）
 
　格式: tar 　选项　 /路径/压缩包的名字     /路径/源文件 ....


 tar 　-zcf　 /路径/压缩包的名字     /路径/源文件 ....

 tar 　-jcf　 /路径/压缩包的名字     /路径/源文件 ....

 tar 　-Jcf　 /路径/压缩包的名字     /路径/源文件 ....
　　 -z gzip .gz    -j bzip2 .bz2      -J  xz .xz
红色：压缩
]# rm -rf /opt/*
]# tar -zcf /opt/file.tar.gz  /home/  /etc/passwd
]# ls /opt/
]# tar -tf /opt/file.tar.gz  #查看包里面内容
]# tar -tf /opt/file.tar.gz  ｜　less

]# tar -jcf /opt/nsd.tar.bz2  /home/  /etc/passwd
]# tar -tf /opt/nsd.tar.bz2  
]# ls /opt/

]# tar -Jcf /opt/abc.tar.xz   /home/  /etc/passwd
]# tar -tf /opt/abc.tar.xz  
]# ls /opt/         



]# mkdir /nsd1903
]# tar -xf　 /opt/abc.tar.xz    -C 　/nsd1903/
]# ls 　/nsd1903/
]# ls 　/nsd1903/home/
]# ls 　/nsd1903/etc/

#################################################
案例2:创建一个备份包
使用 tar 工具完成以下备份任务:
– 创建一个名为 /root/backup.tar.bz2 的归档文件
– 其中包含 /usr/local 目录中的内容
– tar 归档必须使用 bzip2 进行压缩

]# tar -jcf /root/backup.tar.bz2   /usr/local/
]# ls /root/
]# tar -tf /root/backup.tar.bz2   #查看包的内容

###############################################

Admin_day05===========================================================================================

教学环境介绍

• 每个学员机上有三台预先配置好的虚拟机
– server —— 作为练习用服务器
– desktop —— 作为练习用客户机

– classroom —— 提供网关/DNS/软件素材等资源

　开机时，优先开启classroom虚拟机

使用rht-vmctl辅助工具
• 控制教学用虚拟机
– 格式:rht-vmctl 控制指令 虚拟机名

reset(还原)

真机上操作：
]# rht-vmctl reset classroom　　//先重置资源服务器
]# rht-vmctl reset server
]# rht-vmctl reset desktop　　 //再重置答题虚拟机

虚拟机server
  1.利用root用户进入系统，密码为redhat
  2.查看系统版本:RHEL 7.0
  3.查看主机名:server0.example.com
  4.查看虚拟机eth0的IP地址:172.25.0.11

虚拟机desktop
   1.利用root用户进入系统，密码为redhat
　2.查看系统版本:RHEL 7.0
　3.查看主机名:desktop0.example.com
　4.查看虚拟机eth0的IP地址:172.25.0.10

##################################################
利用真机，远程管理

１.真机测试通信
[student@room9pc01 ~]$ ping 172.25.0.11
[student@room9pc01 ~]$ ping 172.25.0.10

2.真机进行远程管理
　　ssh   用户名@对方的IP地址
     -X:在远程管理时，开启对方的图形程序

[student@room9pc01 ~]$ ssh root@172.25.0.11
Last login: Mon Apr  8 10:37:39 2019 from 172.25.0.250
[root@server0 ~]# hostname

[root@server0 ~]# ifconfig | head -2

[root@server0 ~]# exit 　　#退出远程管理

补充快捷键:   Ctrl + shift + t　开启一个新的终端

################################################

[root@server0 ~]# exit　　　　　＃退出远程管理
登出
Connection to 172.25.0.11 closed.

[student@room9pc01 ~]$ ssh -X root@172.25.0.11
Last login: Mon Apr  8 10:46:47 2019
/usr/bin/xauth:  file /root/.Xauthority does not exist
[root@server0 ~]# firefox

[root@server0 ~]# 

##################################################
权限和归属

基本权限
基本权限的类别
• 访问方式(权限)
– 读取:允许查看内容-read    r 
– 写入:允许修改内容-write     w
– 可执行:允许运行和切换-execute  x 

      文本文件:
           r: cat less head tail 
           w: vim 修改并且保存   重定向　>    >>
           x: 写Shell脚本


• 权限适用对象(归属)
 – 所有者:拥有此文件/目录的用户-user  u
 – 所属组:拥有此文件/目录的组-group     g
 – 其他用户:除所有者、所属组以外的用户-other o

　　１.txt      lisi  lisi

################################################
查看权限

• 使用 ls -l 命令
– ls -ld 文件或目录...
  
  以－开头　代表为文本文件
  以ｄ开头　代表为目录
  以 l开头　代表为快捷方式

[root@server0 ~]# ls -ld /etc/

[root@server0 ~]# ls -l /etc/passwd

[root@server0 ~]# ls -ld /home/student

[root@server0 ~]# ls -l /etc/shadow

[root@server0 ~]# ls -ld /tmp
##########################################
设置基本权限

• 使用 chmod 命令
– chmod  归属关系+-=权限类别 　文档...

     [-R]:递归，目录本身及目录下所有

[root@server0 ~]# mkdir /nsd01
[root@server0 ~]# ls -ld /nsd01
[root@server0 ~]# chmod u-w /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# chmod g+w /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# chmod u=rwx /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# chmod o+w /nsd01
[root@server0 ~]# ls -ld /nsd01
[root@server0 ~]# chmod u=rwx,g=rx,o=--- /nsd01
[root@server0 ~]# ls -ld /nsd01

[root@server0 ~]# mkdir -p /opt/aa/bb/cc
[root@server0 ~]# ls /opt/

[root@server0 ~]# chmod -R o=--- /opt/aa
[root@server0 ~]# ls -ld /opt/aa
[root@server0 ~]# ls -ld /opt/aa/bb/
[root@server0 ~]# ls -ld /opt/aa/bb/cc/

###############################################
Linux如何判断一个用户的具备的权限：　　　匹配及停止
　１.查看用户对于该文档，所处的角色      所有者>所属组>其他人
　２.查看相应角色位置的权限
　

###############################################
 Permission denied：权限不足

目录的 r 权限:能够 ls 浏览此目录内容
目录的 w 权限:能够执行 rm/mv/cp/mkdir/touch/等更改目录内容的操作
目录的 x 权限:能够 cd 切换到此目录

#################################################
以root用户新建/nsddir目录，在此目录下新建readme.txt文件
并进一步完成下列操作
 1）使用户lisi能够在此目录下创建子目录  切换用户 su  -  lisi
     chmod o+w  /nsddir/
 2）使用户lisi不能够在此目录下创建子目录
     chmod o-w  /nsddir/
 3）使用户lisi能够修改readme.txt文件内容
     chmod o+w  /nsddir/readme.txt
 4）调整此目录的权限，使所有用户都不能cd进入此目录
     chmod u-x,g-x,o-x  /nsddir/
 5）为此目录及其下所有文档设置权限 rwxr-x---
     chmod -R  u=rwx,g=rx,o=---  /nsddir/
　　　-R：递归设置权限，目录下及目录下所有

###############################################
设置文档归属

• 使用 chown 命令
– chown [-R] 属主 文档...
– chown [-R] :属组 文档...
– chown [-R] 属主:属组 文档...

[root@server0 ~]# mkdir /nsd03
[root@server0 ~]# ls -ld /nsd03

[root@server0 ~]# groupadd tarena
[root@server0 ~]# chown lisi:tarena /nsd03
[root@server0 ~]# ls -ld /nsd03

[root@server0 ~]# chown student /nsd03
[root@server0 ~]# ls -ld /nsd03

[root@server0 ~]# chown :root /nsd03
[root@server0 ~]# ls -ld /nsd03

################################################
利用root用户新建/nsd06目录，并进一步完成下列操作　
1）将属主设为gelin01，属组设为tarena组              
[root@server0 /]# useradd gelin01
[root@server0 /]# useradd gelin02
[root@server0 /]# groupadd tarena
[root@server0 /]# chown gelin01:tarena  /nsd06
2）使用户gelin01对此目录具有rwx权限
      除属主与属组之外的人，对此目录无任何权限
[root@server0 /]# chmod o=--- /nsd06
3）使用户gelin02能进入、查看此目录内容
[root@server0 /]# gpasswd -a  gelin02  tarena
4）将gelin01加入tarena组, 将nsd06目录的权限设为rw-r-x---
      再测试gelin01用户能否进入此目录
[root@server0 /]# gpasswd -a  gelin01  tarena
[root@server0 /]# chmod u=rw,g=rx /nsd06

################################################
实现lisi用户可以读取/etc/shadow文件内容，您有几种办法?

1.修改其他人权限　　
         chmod  o+r  /etc/shadow
2.利用所属组
         chown :lisi /etc/shadow
         chmod  g+r  /etc/shadow
3.利用所有者
         chown  lisi /etc/shadow
         chmod  u+r  /etc/shadow
4.利用ACL策略
　　　　　setfacl -m  u:lisi:r  /etc/shadow


###############################################
附加权限（特殊权限）

Set GID
• 附加在属组的 x 位上
– 属组的权限标识会变为 s
– 适用于目录,Set GID可以使目录下新增的文档自动设
置与父目录相同的属组
– 继承所属组身份

[root@server0 ~]# mkdir /nsd09
[root@server0 ~]# ls -ld /nsd09

[root@server0 ~]# chown :tarena /nsd09
[root@server0 ~]# ls -ld /nsd09
[root@server0 ~]# mkdir /nsd09/test01
[root@server0 ~]# ls -ld /nsd09/test01

[root@server0 ~]# chmod g+s /nsd09/
[root@server0 ~]# ls -ld /nsd09/

[root@server0 ~]# mkdir /nsd09/test02
[root@server0 ~]# ls -ld /nsd09/test02
[root@server0 ~]# mkdir /nsd09/test02/abc
[root@server0 ~]# ls -ld /nsd09/test02/abc
################################################
Set UID
• 附加在属主的 x 位上
– 属主的权限标识会变为 s
– 适用于可执行文件,Set UID可以让使用者具有文件属
主的身份及部分权限

[root@server0 ~]# cp /usr/bin/mkdir /usr/bin/hahadir

[root@server0 ~]# chmod u+s /usr/bin/hahadir 
[root@server0 ~]# ls -l /usr/bin/hahadir

[root@server0 ~]# ls -l /usr/bin/mkdir 

[root@server0 ~]# su - dc

[dc@server0 ~]$ /usr/bin/mkdir dc01
[dc@server0 ~]$ /usr/bin/hahadir dc02
[dc@server0 ~]$ exit
        
###############################################
Sticky Bit
• 附加在其他人的 x 位上
– 其他人的权限标识会变为 t
– 适用于开放 w 权限的目录,可以阻止用户滥用 w 写入
权限(禁止操作别人的文档)

]# mkdir /home/public/
]# chmod ugo=rwx /home/public/ 

]# chmod o+t /home/public/

#############################################
acl访问控制列表(ACL策略)

acl策略的作用
• 文档归属的局限性
– 任何人只属于三种角色:属主、属组、其他人
– 无法实现更精细的控制

• acl访问策略
– 能够对个别用户、个别组设置独立的权限
– 大多数挂载的EXT3/4、XFS文件系统默认已支持

设置acl访问控制策略
• 使用 getfacl、setfacl 命令
– getfacl 文档...
– setfacl  -m u:用户名:权限类别 文档...
– setfacl  -m g:组名:权限类别 文档...
– setfacl  -b 文档...                #删除所有ACL策略
– setfacl  -x u:用户名   文档...    #删除单条指定ACL策略

　　　[-R]：递归设置ACL策略
[root@server0 ~]# chmod o+t /root/public

====================================================
权限和归属
基本权限

权限的类别
---访问方式(权限)
读取: r  例 cat less head tail
写入: w  例 vim修改并且保存退出  重定向 > >> 
运行: x  例 写shell脚本

权限适用对象(归属)
所有者: u  拥有此文件/目录的用户
所属组: g  拥有此文件/目录的组 
其他用户:  o 除了所有者 所属组以外的用户

============================================
查看权限

以-开头   代表文件文本
以d开头  代表目录
以l开头  代表快捷方式

查看父目录的权限
[root@server0 ~]# ls -ld /etc

查看父目录下的所有文档权限
[root@server0 ~]# ls -l /etc

============================================
设置基本权限
chmod 命令

给目录/nsd01其他人添加写入权限
[root@server0 ~]# chmod o+w /nsd01
[root@server0 ~]# chmod ugo=rwx /nsd01

将目录/nsd01下现所有的文档递归添加写入权限
[root@server0 ~]# chmod -R o+w /nsd01

同时给ugo设置权限
[root@server0 ~]# chmod u=rwx,g=rwx,o=--- /nsd01
或
[root@server0 ~]# chmod ugo=rwx /nsd01

===========================================
Linux如何判断一个用户的具备的权限：　　　匹配及停止
　１.查看用户对于该文档，所处的角色      所有者>所属组>其他人
　２.查看相应角色位置的权限

===========================================
设置文档归属
chown 命令
chown [-R] 属主 文档
chown [-R] :属组 文档
chown [-R] 属主:属组 文档

将目录修改属主和属组
[root@server0 ~]# chown  gelin01:tarena /nsd01
                                    属主    属组
将目录修改属主
[root@server0 ~]# chown  gelin01 /nsd01

将目录修改属组
[root@server0 ~]# chown  :gelin01 /nsd01
文件文本操作相同

==========================================
实现lisi用户可以读取/etc/shadow文件内容，您有几种办法?
1.修改其他人权限　
          chmod o+r /etc/shadow

2.利用所属组
       chown lisi /etc/shadow
       chmod u+r /etc/shadow

3.利用所有者
      chown :lisi /etc/shadow
      chmod g+r /etc/shadow

4.利用ACL策略
      sefacl -m u:lisi:r /etc/shadow

===================================================
附加权限(特殊权限)
Set GID
附加在属组的 X 位置上
属组的权限标识会变为s
适用于目录,Set GID 父目录下新建的文档自动设置与父目录的属组
继承所属组身份
例:
[root@server0 ~]# chmod g+s /nsd01

====================================================
Set UID
附加在属主的 x 位上
属主的权限会变为s
适用于可执行文件,Set UID可以让使用者具有文件属
主的身份及部分权限
例:
[root@server0 ~]# cp /usr/bin/mkdir /usr/bin/zhai  #第一次复制修改目录名称
[root@server0 ~]# chmod u+s /usr/bin/zhai  #附加属主权限给目录zhai
[root@server0 ~]# su - zyq
[zyq@server0 ~]$ /usr/bin/zhai /zhaiyanquan

====================================================
Sticky Bit
附加在其他人 x 位上
其他人的权限会变为t
适用于开放 w 权限的目录,可以阻止用户滥用 w 写入
权限(禁止操作别人的文档)
例:
[root@server0 ~]# mkdir /root/public
[root@server0 ~]# chmod ugo=rwx /root/public
[root@server0 ~]# chmod o+t /root/public

====================================================
acl访问控制列表(ACL策略)

acl策略的作用
• 文档归属的局限性
– 任何人只属于三种角色:属主、属组、其他人
– 无法实现更精细的控制

• acl访问策略
– 能够对个别用户、个别组设置独立的权限
– 大多数挂载的EXT3/4、XFS文件系统默认已支持

设置acl访问控制策略
• 使用 getfacl、setfacl 命令
– getfacl 文档...
– setfacl  -m u:用户名:权限类别 文档...
– setfacl  -m g:组名:权限类别 文档...
– setfacl  -b 文档...               #删除所有ACL策略
– setfacl  -x u:用户名   文档...      #删除单条指定ACL策略

setfacl -x u:用户名   文档
删除某个用户的acl策略
[root@server0 ~]# setfacl -x u:harry /nsd01
                                         用户
setfacl -b 文档
删除所有用户的acl策略
[root@server0 ~]# setfacl -b /nsd01

　　　[-R]：递归设置ACL策略
[root@server0 ~]# chmod o+t /root/public

查看acl
[root@desktop0 ~]# getfacl /mnt/nfssecure/project

=============================================
umask值
[root@server0 ~]# umask 0077  #修改umask值为0077
[root@server0 ~]# umask       #查看umask值

查看命令所在位置
[root@server0 ~]# which hostname
/usr/bin/hostname

Admin_day06===========================================================================================

教学环境介绍

– 格式:rht-vmctl 控制指令 虚拟机名

reset(还原)

真机上操作：
　]# rht-vmctl reset classroom　 #先重置资源服务器
　]# rht-vmctl reset server
　]# rht-vmctl reset desktop　　 #再重置练习虚拟机


虚拟机server
  1.利用root用户进入系统，密码为redhat
  2.查看系统版本:RHEL 7.0
  3.查看主机名:server0.example.com
  4.查看虚拟机eth0的IP地址:172.25.0.11   

虚拟机desktop
   1.利用root用户进入系统，密码为redhat
　2.查看系统版本:RHEL 7.0
　3.查看主机名:desktop0.example.com
　4.查看虚拟机eth0的IP地址:172.25.0.10

##################################################
软件包管理(wget)

零散软件管理
1.首先需要具备软件的安装包
2.构建Web服务或FTP服务，共享光盘所有内容
　　　Web服务:提供网页内容的服务

3.将虚拟机classroom已经构建完成Web服务，已经共享光盘所有内容4.真机浏览器，访问测试
　　　	 classroom.example.com

          content/rhel7.0/x86_64/dvd/Packages/
5.下载软件包

• 使用wget下载工具
– wget 软件包的URL网址　　＃默认下载到当前目录下

– wget 软件包的URL网址 　-O(大写) 　/目录路径/新文件名

提供FTP功能的软件包(vsftpd)

当前页面查找:vsftpd

[root@server0 ~]# wget  http://classroom.example.com/content/rhel7.0/x86_64/dvd/Packages/vsftpd-3.0.2-9.el7.x86_64.rpm

[root@server0 ~]# ls

• RPM Package Manager,RPM包管理器
– rpm -q 软件名             　　　   #查询该软件是否已经安装
– rpm -ivh 软件名-版本信息.rpm...　　#安装软件包
– rpm -e 软件名...

[root@server0 ~]# rpm -q firefox    
firefox-24.5.0-1.el7.x86_64
[root@server0 ~]# rpm -q haha
未安装软件包 haha 
[root@server0 ~]# rpm -q bash
bash-4.2.45-5.el7.x86_64
[root@server0 ~]# rpm -q hostname

[root@server0 ~]# rpm -q zip

[root@server0 ~]# rpm -q httpd

]# rpm -ivh /root/vsftpd-3.0.2-9.el7.x86_64.rpm 

]# rpm -q vsftpd　　　#查询是否安装成功

]# rpm -e vsftpd　　　　#卸载软件
]# rpm -q vsftpd　　　#查询是否卸载成功
#################################################
了解:导入新的红帽签名
]# wget http://classroom.example.com/content/rhel7.0/x86_64/dvd/RPM-GPG-KEY-redhat-release

]# rpm --import /root/RPM-GPG-KEY-redhat-release 
]# rpm -q vsftpd

]# rpm -ivh /root/vsftpd-3.0.2-9.el7.x86_64.rpm 

########################################
升级Linux内核

1.下载新的内核软件包
]# wget http://classroom.example.com/content/rhel7.0/x86_64/errata/Packages/kernel-3.10.0-123.1.2.el7.x86_64.rpm

]# ls
 
2.安装新的内核软件包
[root@server0 qw~]# uname -r  #查看内核版本

]# rpm -ivh /root/kernel-3.10.0-123.1.2.el7.x86_64.rpm 

[root@server0 ~]# uname -r
[root@server0 ~]# reboot 

[student@room9pc01 ~]$ ssh -X root@172.25.0.11
[root@server0 ~]# uname -r
3.10.0-123.1.2.el7.x86_64
[root@server0 ~]# 
################################################
安装软件包常见提示:

1.软件包已经安装
]# rpm -ivh /root/vsftpd-3.0.2-9.el7.x86_64.rpm 
准备中...                                            ################################# [100%]
	软件包 vsftpd-3.0.2-9.el7.x86_64 已经安装

[root@server0 ~]# LANG=en　　　　＃讲当前系统语言修改英文
]# rpm -ivh /root/vsftpd-3.0.2-9.el7.x86_64.rpm 
Preparing...                                         ################################# [100%]
	package vsftpd-3.0.2-9.el7.x86_64 is already installed
[root@server0 ~]#
 
2.软件包的依赖关系
]# rpm -ivh /root/bind-chroot-9.9.4-14.el7.x86_64.rpm 
错误：依赖检测失败：
	bind = 32:9.9.4-14.el7 被 bind-chroot-32:9.9.4-14.el7.x86_64 需要

################################################
Yum软件包管理

　　自动解决软件包的依赖关系

Yum配置及使用(Yum软件包仓库)

服务：为客户端自动解决依赖关系安装软件包

服务端：虚拟机classroom　
　　　1.众多的软件包　　2.仓库数据文件　　３.构建web或ftp服务
              　光盘中既具备软件包，又具备仓库数据文件
　　　　　　　软件包	Packages
　　　　　　　仓库数据文件　repodata
　　　总结：构建web或ftp服务，共享光盘所有内容

客户端：指定服务端位置
　　客户端配置文件:/etc/yum.repos.d/*.repo
        　错误的客户端配置文件，会影响正确的客户端配置文件  
　　　[] name  baseurl  enabled  gpgcheck      

[root@server0 ~]# rm -rf /etc/yum.repos.d/*
[root@server0 ~]# vim /etc/yum.repos.d/dvd.repo
[nsd1903]　　　　　　　＃仓库标识　　
name=rhel7　　　　　　＃仓库描述信息
baseurl=http://classroom.example.com/content/rhel7.0/x86_64/dvd　　　　　　　＃指定服务端在哪里
enabled=1　　　　　　　＃启用本文件
gpgcheck=0　　　　　　　＃不检测软件包的签名

[root@server0 ~]# yum repolist   #列出仓库信息
 
源标识              源名称            状态
nsd1903             rhel7             4,305
repolist: 4,305
[root@server0 ~]# 

Yum的使用:
[root@server0 ~]# yum -y install httpd
[root@server0 ~]# rpm -q httpd
httpd-2.4.6-17.el7.x86_64

]# yum -y install sssd
]# yum -y install gcc
]# yum -y install bind-chroot
]# yum -y install vsftpd
]# yum -y install system-config-kickstart 


[root@server0 ~]# yum 　remove　 gcc　  #卸载


[root@server0 ~]# yum clean all　　＃清空缓存

################################################
分区规划及使用
 
  扇区大小默认为512字节

硬盘（块设备）分区管理

一块硬盘的“艺术”之旅
• 识别硬盘 => 分区规划 => 格式化 => 挂载使用
　毛坯楼层 => 打隔断 => 装修 => 入驻

一 识别硬盘
[root@server0 ~]# lsblk 　　　　＃显示当前系统中硬盘
　NAME    　SIZE 　　TYPE 
　vda     　10G 　　 disk 
　└─vda1   10G  　part 
　vdb    　 10G  　　disk 

二 分区规划
     
    GPT
     分区模式：MBR 主引导记录分区模式  
　　• MBR/msdos 分区模式
　　– 1~4个主分区　或者　3个主分区+1个扩展分区(n个逻辑分区)
　　– 最大支持容量为 2.2TB 的磁盘
　　– 扩展分区不能格式化
　　
　　/dev/sda5：该设备标识的含义
　　　　　　　　第一块SCSI接口的设备，第五个分区
　　　　　　　　第一块SCSI接口的设备，第一个逻辑分区


[root@server0 ~]# fdisk  /dev/vdb 
  n 创建新的分区----->回车----->回车---->回车----->在last结束时 +1G
  p 查看分区表
  n 创建新的分区----->回车----->回车---->回车----->在last结束时 +2G
  d 删除分区
  w 保存并退出    

[root@server0 ~]# lsblk
[root@server0 ~]# ls  /dev/vdb[1-2]

三　格式化:赋予空间文件系统
　　文件系统：数据在空间存储的规则

　　Windows: FAT  NTFS
    Linux:
         RHEL6:ext4
         RHEL7:xfs

• mkfs 工具集
– mkfs.ext3 分区设备路径
– mkfs.ext4 分区设备路径
– mkfs.xfs 分区设备路径
– mkfs.vfat -F 32 分区设备路径

[root@server0 ~]# mkfs.ext4 /dev/vdb1　＃格式化文件系统
[root@server0 ~]# blkid /dev/vdb1   #查看文件系统类型

[root@server0 ~]# mkfs.xfs /dev/vdb2　＃格式化文件系统
[root@server0 ~]# blkid /dev/vdb2　　#查看文件系统类型

四　挂载设备进行使用                            
[root@server0 ~]# mkdir /mypart1
[root@server0 ~]# mount /dev/vdb1 /mypart1
[root@server0 ~]# df -h　　　#显示正在挂载设备的使用情况

[root@server0 ~]# mount /dev/vdb2 /mypart2
mount: 挂载点 /mypart2 不存在

[root@server0 ~]# mkdir /mypart2
[root@server0 ~]# mount /dev/vdb2 /mypart2
[root@server0 ~]# df -h　　　#显示正在挂载设备的使用情况
###################################################
五　永久挂载（开机自动挂载）

实现开机自动挂载
• 配置文件 /etc/fstab 的记录格式
   设备路径    挂载点         类型       参数      备份标记     检测顺序

vim命令模式　按o另起新的一行 进入插入模式

[root@server0 ~]# vim /etc/fstab
 /dev/vdb1 /mypart1  ext4  defaults 0 0
 /dev/vdb2 /mypart2  xfs  defaults 0 0

[root@server0 ~]# umount /mypart1  　#保证当前没有挂载
[root@server0 ~]# umount /mypart2　　#保证当前没有挂载

[root@server0 ~]# df -h
[root@server0 ~]# mount -a
   检测/etc/fstab开机自动挂载配置文件,格式是否正确
   检测/etc/fstab中,书写完成,但当前没有挂载的设备,进行挂载 
[root@server0 ~]# df -h
###################################################
综合分区，/dev/vdb继续分区

最终有3个主分区，分别为1G、2G、2G
   创建扩展分区 --->  两个逻辑分区，分别为1G、1G
[root@server0 ~]# fdisk  /dev/vdb
   p 查看分区表
   n 创建主分区----->回车----->回车---->回车----->在last结束时 +2G
   p 查看分区表
   n 创建扩展分区 
          ----->回车---->起始回车----->结束回车   将所有空间给扩展分区
   p 查看分区表
   n 创建逻辑分区----->起始回车------>结束+1G
   n 创建逻辑分区----->起始回车------>结束+1G
   p 查看分区表
   w 保存并退出
[root@server0 ~]# partprobe   #刷新分区表
[root@server0 ~]# lsblk 
#####################################################
总结：
1.识别硬盘　lsblk
2.分区规划    fdisk
3.刷新分区表　　partprobe
4.进行格式化　　mkfs.xfs  mkfs.ext4   blkid
5.挂载使用　mount  /etc/fstab开机自动挂载   mount -a  df -h
####################################################


===================================================

Web服务:专门提供网页内容的服务

===================================================
wget下载工具
wget 软件包的URL网址  #默认下载到当前路径
例如:
[root@server0 ~]# wget http://classroom.example.com/content/rhel7.0/x86_64/dvd/Packages/
                                    软件包的URL网址     

wget 软件包的URL网址  -O(大写的O)   /目录路径/新建目录名称
例如:
[root@server0 ~]# wget -O http://classroom.example.com/content/rhel7.0/x86_64/dvd/Packages/ /home/zhai
                                                  软件包的URL网址                                                    指定下载到该路径

===================================================
rpm包管理器

rmp -q 软件名  #查询软件包是否已安装
例:
[root@server0 ~]# rpm -q firefox

rmp -ivh 软件名-版本信息.rpm  #安装软件包,有进度条
例:
[root@server0 ~]# rpm -ivh vsftpd-3.0.2-9.el7.x86_64.rpm

rmp -e 软件名  #卸载软件包
例:
[root@server0 ~]# rpm -e firefox

===================================================
升级Linux内核

1.下载最新的内核软件包
[root@server0 ~]# wget http://classroom.example.com/content/rhel7.0/x86_64/errata/Packages/kernel-3.10.0-123.1.2.el7.x86_64.rpm

查看当前内核版本
[root@server0 ~]# uname -r
或
[root@server0 ~]# rpm -q kernel

升级内核
[root@server0 ~]# rpm -ivh kernel-3.10.0-123.1.2.el7.x86_64.rpm
[root@server0 ~]# reboot
[root@server0 ~]# uname -r

===================================================
把当前系统改成英文
[root@server0 ~]# LANG=en

===================================================
yun软件包管理

能自动解决软件包的依赖关系

[root@server0 ~]# rm -rf /etc/yum.repos.d/*
[root@server0 ~]# vim /etc/yum.repos.d/dvd.repo
[nsd1903]  #源标识
name=rehl7  #源名称
baseurl=http://classroom.example.com/content/rhel7.0/x86_64/dvd/   #
enabled=1  #1表示该文件有效,0表示无效
gpgcheck=0  #0关闭红帽验证,1打开红帽验证

[root@server0 ~]# yum repolist

yum的使用

清空yum的缓存
[root@server0 ~]# yum clean all

卸载软件包
[root@server0 ~]# yum remove vsftpd

===================================================
分区规则及使用

扇区大小默认为512字节

硬盘分区管理

一块硬盘的"艺术"之旅
识别硬盘=>分区规划=>格式=>挂载使用

MBR/msdos分区模式
1~4个主分区,或0~3个主分区,1个扩展分区,n个逻辑分区
最大支持容量为2.2TB的磁盘
扩展分区不能格式化

使用fdisk分区工具
查看分区列表
例:
[root@server0 ~]# fdisk -l /dev/vdb

修改硬盘的分区表
[root@server0 ~]# fdisk /dev/vdb

识别新分区表(刷新分区表)
[root@server0 ~]# partprobe /dev/vdb
[root@server0 ~]# reboot

Windows: FAT NTFS
Linux:
     RHEL6:ext4
      RHEL7:xfs
       
---格式化分区
常用的格式化工具
mkfs工具集
mkfs.ext4 分区设备路径
mkfs.ext3 分区设备路径
mkfs.xfs 分区设备路径
mkfs.vfat -F 32 分区设备路径
例:
[root@server0 ~]# mkfs.xfs /dev/vdb2
[root@server0 ~]# mkfs.ext4 /dev/vdb1
[root@server0 ~]# mkfs.xfs -f /dev/vdb2 #如有文件系统存在,加-f强制格式化成文件系统xfs

挂载
[root@server0 ~]# mount /dev/vdb1 /mypart1
[root@server0 ~]# mount /dev/vdb2 /mypart2

查看正在挂载设备使用情况
[root@server0 ~]# df -h

删除挂载
[root@server0 ~]# umount /mypart1

===================================================
永久挂载(开机自动挂载)
配置文件 /etc/fstab 的记录格式

[root@server0 ~]# vim /etc/fstab
/dev/vdb1   /mypart1 ext4   defaults                    0                                     0
设备路径       挂载点     类型    参数(defaults表示默认参数)     备份标记(0代表不备份,1代表备份)     检测顺序(0代表不检测,1代表检测)

挂载
[root@server0 ~]# mount -a

===================================================
分区规划及使用
 
  扇区大小默认为512字节

硬盘（块设备）分区管理

一块硬盘的“艺术”之旅
• 识别硬盘 => 分区规划 => 格式化 => 挂载使用
　毛坯楼层 => 打隔断 => 装修 => 入驻

一 识别硬盘
[root@server0 ~]# lsblk 　　　　＃显示当前系统中硬盘
　NAME    　SIZE 　　TYPE 
　vda     　10G 　　 disk 
　└─vda1   10G  　part 
　vdb    　 10G  　　disk 

二 分区规划
     
    GPT
     分区模式：MBR 主引导记录分区模式  
　　• MBR/msdos 分区模式
　　– 1~4个主分区　或者　3个主分区+1个扩展分区(n个逻辑分区)
　　– 最大支持容量为 2.2TB 的磁盘
　　– 扩展分区不能格式化
　　
　　/dev/sda5：该设备标识的含义
　　　　　　　　第一块SCSI接口的设备，第五个分区
　　　　　　　　第一块SCSI接口的设备，第一个逻辑分区


[root@server0 ~]# fdisk  /dev/vdb 
  n 创建新的分区----->回车----->回车---->回车----->在last结束时 +1G
  p 查看分区表
  n 创建新的分区----->回车----->回车---->回车----->在last结束时 +2G
  d 删除分区
  w 保存并退出    

[root@server0 ~]# lsblk
[root@server0 ~]# ls  /dev/vdb[1-2]

三　格式化:赋予空间文件系统
　　文件系统：数据在空间存储的规则

　　Windows: FAT  NTFS
    Linux:
         RHEL6:ext4
         RHEL7:xfs

• mkfs 工具集
– mkfs.ext3 分区设备路径
– mkfs.ext4 分区设备路径
– mkfs.xfs 分区设备路径
– mkfs.vfat -F 32 分区设备路径

[root@server0 ~]# mkfs.ext4 /dev/vdb1　＃格式化文件系统
[root@server0 ~]# blkid /dev/vdb1   #查看文件系统类型

[root@server0 ~]# mkfs.xfs /dev/vdb2　＃格式化文件系统
[root@server0 ~]# blkid /dev/vdb2　　#查看文件系统类型

四　挂载设备进行使用                            
[root@server0 ~]# mkdir /mypart1
[root@server0 ~]# mount /dev/vdb1 /mypart1
[root@server0 ~]# df -h　　　#显示正在挂载设备的使用情况

[root@server0 ~]# mount /dev/vdb2 /mypart2
mount: 挂载点 /mypart2 不存在

[root@server0 ~]# mkdir /mypart2
[root@server0 ~]# mount /dev/vdb2 /mypart2
[root@server0 ~]# df -h　　　#显示正在挂载设备的使用情况

非交互试分区
[root@node1 ~]# parted /dev/vdb mklabel gpt   #分区类型
[root@node1 ~]# parted /dev/vdb mkpart primary 1 50% #分出50%大小
[root@node1 ~]# parted /dev/vdb mkpart primary 50% 100% #再分出50%大小

######################################################################################
五　永久挂载（开机自动挂载）
实现开机自动挂载
• 配置文件 /etc/fstab 的记录格式
   设备路径    挂载点         类型       参数      备份标记     检测顺序

vim命令模式　按o另起新的一行 进入插入模式

[root@server0 ~]# vim /etc/fstab
 /dev/vdb1 /mypart1  ext4  defaults 0 0
 /dev/vdb2 /mypart2  xfs  defaults 0 0

[root@server0 ~]# umount /mypart1  　#保证当前没有挂载
[root@server0 ~]# umount /mypart2　　#保证当前没有挂载

[root@server0 ~]# df -h
[root@server0 ~]# mount -a
   检测/etc/fstab开机自动挂载配置文件,格式是否正确
   检测/etc/fstab中,书写完成,但当前没有挂载的设备,进行挂载 
[root@server0 ~]# df -h

###################################################
综合分区，/dev/vdb继续分区
最终有3个主分区，分别为1G、2G、2G
   创建扩展分区 --->  两个逻辑分区，分别为1G、1G
[root@server0 ~]# fdisk  /dev/vdb
   p 查看分区表
   n 创建主分区----->回车----->回车---->回车----->在last结束时 +2G
   p 查看分区表
   n 创建扩展分区 
          ----->回车---->起始回车----->结束回车   将所有空间给扩展分区
   p 查看分区表
   n 创建逻辑分区----->起始回车------>结束+1G
   n 创建逻辑分区----->起始回车------>结束+1G
   p 查看分区表
   w 保存并退出
[root@server0 ~]# partprobe   #刷新分区表
[root@server0 ~]# lsblk 

#####################################################
总结：
1.识别硬盘　lsblk
2.分区规划    fdisk
3.刷新分区表　　partprobe
4.进行格式化　　mkfs.xfs  mkfs.ext4   blkid
5.挂载使用　mount  /etc/fstab开机自动挂载   mount -a  df -h

Admin_day07===========================================================================================

教学环境介绍

– 格式:rht-vmctl 控制指令 虚拟机名

reset(还原)

真机上操作：
　]# rht-vmctl reset classroom　 //先重置资源服务器
　]# rht-vmctl reset server
　]# rht-vmctl reset desktop　　 //再重置练习虚拟机

虚拟机server
  1.利用root用户进入系统，密码为redhat
  2.查看系统版本:RHEL 7.0
  3.查看主机名:server0.example.com
  4.查看虚拟机eth0的IP地址:172.25.0.11   

虚拟机desktop
   1.利用root用户进入系统，密码为redhat
　2.查看系统版本:RHEL 7.0
　3.查看主机名:desktop0.example.com
　4.查看虚拟机eth0的IP地址:172.25.0.10

##################################################
一 添加硬盘
1.虚拟机server进行关机
[root@server0 ~]# poweroff 
Connection to 172.25.0.11 closed by remote host.
Connection to 172.25.0.11 closed.
[student@room9pc01 ~]$ 

2.远程管理虚拟机server
[student@room9pc01 ~]$ ssh -X  root@172.25.0.11
[root@server0 ~]# lsblk

二 分区规划
  划分可以使用的5个分区,每个分区10G
[root@server0 ~]# fdisk  /dev/vdc
   p 查看分区表
   n 创建主分区----->回车----->回车---->回车----->在last结束时 +10G
         ....... 连续划分3个主分区
   p 查看分区表
   n 创建扩展分区 
          ----->回车---->起始回车----->结束回车   将所有空间给扩展分区
   p 查看分区表
   n 创建逻辑分区----->起始回车------>结束+10G
   n 创建逻辑分区----->起始回车------>结束+10G
   p 查看分区表
   w 保存并退出
[root@server0 ~]# lsblk 


LVM逻辑卷
       作用: 整合分散的空间   大小可以动态扩大

   1.零散空闲存储 (物理卷PV)
   2.整合的虚拟磁盘 (卷组VG)
   3.虚拟的分区 (逻辑卷LV)

   将众多的物理卷(PV),组建成卷组(VG),再从卷组中划分逻辑卷(LV)

####################################################
逻辑卷的制作

successfully(成功)                 
1.创建卷组名为systemvg
    格式: vgcreate 卷组名   设备路径........

[root@server0 ~]# vgcreate systemvg /dev/vdc[1-2]
 
[root@server0 ~]# pvs   #查看物理卷信息
[root@server0 ~]# vgs   #查看卷组信息

2.创建逻辑卷
    格式: lvcreate -n 逻辑卷名字   -L 逻辑卷大小   卷组名

[root@server0 ~]# lvcreate -n vo -L 16G systemvg 
  Logical volume "vo" created

[root@server0 ~]# lvs  #查看当前系统中,所有逻辑卷信息
                                          
[root@server0 ~]# vgs  #查看当前系统中,所有卷组信息
###################################################
逻辑卷的使用       
                                             
1.查看逻辑卷设备文件
[root@server0 ~]# ls /dev/systemvg/vo 
[root@server0 ~]# ls -l /dev/systemvg/vo
[root@server0 ~]# ls /dev/dm-0

2.格式化文件系统,进行挂载
[root@server0 ~]# mkfs.xfs /dev/systemvg/vo 
[root@server0 ~]# blkid /dev/systemvg/vo

[root@server0 ~]# vim /etc/fstab 
 /dev/systemvg/vo  /mylv  xfs defaults 0 0
[root@server0 ~]# mount -a
[root@server0 ~]# df -h

##################################################
逻辑卷的扩展

一 卷组有足够的剩余空间
1.扩展空间的大小
[root@server0 ~]# vgs
[root@server0 ~]# lvextend -L 18G /dev/systemvg/vo 
[root@server0 ~]# lvs

2.扩展文件系统的大小
      扩展ext4: resize2fs 
      扩展xfs: xfs_growfs 
[root@server0 ~]# xfs_growfs /dev/systemvg/vo
[root@server0 ~]# df -h

二 卷组没有足够的剩余空间
1.扩展卷组的空间
[root@server0 ~]# vgextend systemvg /dev/vdc3
[root@server0 ~]# vgs

2.扩展逻辑卷空间的大小
[root@server0 ~]# vgs
[root@server0 ~]# lvextend -L 25G /dev/systemvg/vo 
[root@server0 ~]# lvs

2.扩展逻辑卷文件系统的大小
[root@server0 ~]# xfs_growfs /dev/systemvg/vo
[root@server0 ~]# df -h

###################################################
了解: 逻辑卷可以扩展,也可以缩小

###################################################
卷组划分空间的单位:PE 

   默认1PE为4M大小
[root@server0 ~]# vgdisplay systemvg   #显示卷组详细信息

  PE Size               4.00 MiB

 请划分一个250M的逻辑卷,命名为lvtest01
[root@server0 ~]# vgchange -s 1M systemvg  #修改PE的大小
[root@server0 ~]# vgdisplay systemvg

[root@server0 ~]# lvcreate -n lvtest01 -L 250M systemvg 
[root@server0 ~]# lvs

• 创建卷组的时候设置PE大小
– vgcreate -s PE大小 卷组名 空闲分区...

• 创建逻辑卷的时候指定PE个数
– lvcreate -l PE个数  -n 逻辑卷名 卷组名

################################################
逻辑卷的删除

 lvremove   vgremove   pvremove

  优先删除逻辑卷,再去删除卷组,最后删除物理卷

[root@server0 ~]# lvremove /dev/systemvg/vo 
  Logical volume systemvg/vo contains a filesystem in use.
[root@server0 ~]# umount /mylv/
[root@server0 ~]# lvremove /dev/systemvg/vo 
Do you really want to remove active logical volume vo? [y/n]: y
  Logical volume "vo" successfully removed
[root@server0 ~]# lvs

  删除卷组,需要首先删除,基于此卷组创建的所有逻辑卷
   命令格式:vgremove  卷组名
####################################################
find高级使用

查找文件
• 根据预设的条件递归查找对应的文件
– find [目录] [条件1] [-a|-o] [条件2] ...

– 常用条件表示:
  -type 类型(l快捷方式、d目录、f文本文件)
  -name "文档名称"
  -size +|-文件大小(k、M、G)
  -user 用户名
  -mtime 根据文件修改时间

############################################
  -type 类型(l快捷方式、d目录、f文本文件)

[root@server0 ~]# find /boot/ -type l
[root@server0 ~]# ls /boot/grub/menu.lst 
[root@server0 ~]# ls -l /boot/grub/menu.lst

[root@server0 ~]# find /boot/ -type d
[root@server0 ~]# find /boot/ -type f

[root@server0 ~]# find /root -type d
[root@server0 ~]# find /root -type f

[root@server0 ~]# man find   #权威帮助信息

################################################
-name '文档名称'

[root@server0 ~]# find /etc/ -name 'passwd'
[root@server0 ~]# find /etc/ -name 'passwd*'
[root@server0 ~]# find /etc/ -name '*passwd*'

[root@server0 ~]# mkdir /root/nsd01
[root@server0 ~]# mkdir /root/nsd1903
[root@server0 ~]# touch /root/nsd01.txt
[root@server0 ~]# find /root/ -name 'nsd*'

[root@server0 ~]# find /root/ -name 'nsd*'  -type f
[root@server0 ~]# find /root/ -name 'nsd*'  -type d

####################################################
  -size +|-文件大小(k、M、G)       百度 EB单位

[root@server0 ~]# find /boot/ -size +10M
[root@server0 ~]# find /boot/ -size +300k

  -user 用户名
[root@server0 ~]# find /  -user  student
[root@server0 ~]# ls -ld /home/student

[root@server0 ~]# find /  -user  student -type f

###################################################
 -mtime 根据文件修改时间
  所有的时间都是过去时间

 -mtime +10  #十天之前创建或修改的数据

 -mtime -10  #最近十天之内创建或修改的数据

 -mtime +90  #三个月之前创建或修改的数据

[root@server0 ~]# find /var/log/ -mtime +90
[root@server0 ~]# find /var/log/ -mtime +1000

[root@server0 ~]# ls -l /var/log/yum.log 
[root@server0 ~]# date    #查看当前系统时间
##################################################
find扩展使用

• 使用find命令的 -exec 操作
– find .. .. -exec 处理命令 {} \;
– 优势:以 {} 代替每一个find的查找结果,逐个处理,遇 \; 结束

]# find /boot/ -name 'vm*'
]# find /boot/ -name 'vm*' -exec  cp  {}  /opt  \;
]# ls /opt/

]# find /boot/ -size +10M
]# find /boot/ -size +10M  -exec  cp  {}  /opt  \;
]# ls /opt/

###################################################
案例4:查找并处理文件
• 使用find命令完成以下任务
– 请创建目录/root/findfiles/ 
– 找出所有 用户 student 拥有的文件
– 把它们拷贝到 /root/findfiles/ 文件夹中

]# mkdir /root/findfiles

]# find /  -user student -type f   -exec cp  {} /root/findfiles/  \;

]# ls -A /root/findfiles/

#################################################
查看当前系统时间:date

修改时间: date  -s  '年-月-日    时:分:秒'

[root@server0 ~]# date
[root@server0 ~]# date -s '2008-10-1  10:12:02'

[root@server0 ~]# date
[root@server0 ~]# date -s '2019-4-10 15:43'
[root@server0 ~]# date

################################################
NTP时间同步

NTP网络时间协议
• Network Time Protocol
– NTP服务器为客户机提供标准时间
– NTP客户机需要与NTP服务器保持沟通

NTP服务器:虚拟机classroom

NTP客户机:虚拟机server
1.安装chrony软件包
[root@server0 ~]# yum -y install chrony
    
软件包 chrony-1.29.1-1.el7.x86_64 已安装并且是最新版本
无须任何处理

[root@server0 ~]# rpm -q chrony
chrony-1.29.1-1.el7.x86_64

2.修改配置文件/etc/chrony.conf
[root@server0 ~]# vim  /etc/chrony.conf
  以#开头的行,为注释行
 #server 0.rhel.pool.ntp.org iburst
 #server 1.rhel.pool.ntp.org iburst
 #server 2.rhel.pool.ntp.org iburst
 server classroom.example.com iburst

3.重启服务(程序)
[root@server0 ~]# systemctl restart chronyd
[root@server0 ~]# systemctl enable chronyd  #开机自启

  daemon
    英 [ˈdi:mən] 美 ['di:mən]
    守护神;（希腊神话中）半人半神的精灵;[计]守护进程(程序)

4.验证
[root@server0 ~]# date -s '2008-10-1'
2008年 10月 01日 星期三 00:00:00 CST
[root@server0 ~]# date

[root@server0 ~]# systemctl restart chronyd
[root@server0 ~]# date
[root@server0 ~]# date
[root@server0 ~]# date
[root@server0 ~]# date

#################################################
cron计划任务

cron任务概述
• 用途:按照设置的时间间隔为用户反复执行某一项固
定的系统任务

• 软件包:cronie、crontabs
• 系统服务:crond
• 日志文件:/var/log/crond

如何编写crontab任务记录
• 配置格式可参考 /etc/crontab 文件
   分   时   日   月   周     任务命令行(绝对路径)

   *    *     *     *    *        #每分钟都执行一次

   30    8    *     *    *        #每天早晨八点半 执行一次

   0     21   *     *    1-5      #周一至周五 晚上的九点正

   0     21   *     *    1,3,5,7  #周一 周三 周五 周日 晚上的九点正

   1     8    1      *     1      #周一与每月一号都会执行

   0     */2   *     *    *       #每隔2个小时执行一次


	 *:匹配范围内任意时间
	,:分隔多个不连续的时间点
	-:指定连续时间范围
	/n:指定时间频率,每n ...


	执行周期 配置说明
	   分钟 从0到59之间的整数
	   小时 从0到23之间的整数
	   日期 从1到31之间的整数
	   月份 从1到12之间的整数
	   星期 0~7之间的整数,0或7代表星期日

管理计划任务策略
• 使用 crontab 命令
– 编辑:crontab -e [-u 用户名]
– 查看:crontab -l [-u 用户名]
– 清除:crontab -r [-u 用户名]

 每分钟记录当前系统的时间,写入到/opt/time.txt
[root@server0 ~]# date

[root@server0 ~]# date >>  /opt/time.txt
[root@server0 ~]# cat /opt/time.txt

[root@server0 ~]# crontab -e -u root
* * * * *  date >> /opt/time.txt
* * * * *  /sbin/reboot        #设置定时重启
* * * * *  /usr/sbin/reboot  #每分钟重启一次

[root@server0 ~]# crontab -l -u root

[root@server0 ~]# ls /var/spool/cron/
[root@server0 ~]# cat /var/spool/cron/root #生成的任务文件

[root@server0 ~]# cat /opt/time.txt 

###############################################

=================================================
新建逻辑卷
LVM工作方式
在"分区-->格式化" 中间增加的一个逻辑层
-----零散空闲存储 ------整合的虚拟磁盘-------------虚拟的分区
       物理卷              卷组                逻辑卷

LVM逻辑卷
     作用: 整合分散的空间
将众多的物理卷,组建成卷组,再从卷组划分成逻辑卷

LVM快速部署及使用
基本思路
准备至少一个空闲分区(/dev/vdb1)
创建卷组: vgcreate 卷组名 空闲分区
创建逻辑卷: lvcreate -L 大小 -n 名称 卷组名

===============================================
创建卷组: vgcreate 卷组名 空闲分区
例:
[root@server0 ~]# vgcreate systemvg /dev/vdc[1-2]
查看卷组信息                        卷组名    空闲分区
[root@server0 ~]# vgs
查看物理卷信息
[root@server0 ~]# pvs
I AM KING.

新建卷组systemvg,指定PE大小为16MiB
例:
[root@server0 ~]# vgcreate -s 16M systemvg /dev/vde1
新建逻辑卷,大小设置为50个PE
[root@server0 ~]# lvcreate -l 50 -n vo /dev/systemvg

===============================================
创建逻辑卷: lvcreate -L 大小 -n 名称 卷组名
例:
[root@server0 ~]# lvcreate -L 16G -n    vo     systemvg
                                       大小      逻辑卷名      卷组
查看逻辑卷信息
[root@server0 ~]# lvs
格式化逻辑卷
例:
[root@server0 ~]# mkfs.xfs  /dev/systemvg/vo
设置开机自动挂载
[root@server0 ~]# vim /etc/fstab
/dev/systemvg/vo /myvo xfs defaults 0 0
[root@server0 ~]# mkdir /myvo
挂载
[root@server0 ~]# mount -a

===============================================
逻辑卷的扩展

1.卷组有足够的空间
第一步
逻辑卷原大小是16G
[root@server0 ~]# lvextend -L 18G /dev/systemvg/vo
或
[root@server0 ~]# lvextend -L +2G /dev/systemvg/vo

第二步
扩展文件系统的大小
       扩展ext4: resize2fs
       扩展xfs: xfs_growfs
例:
[root@server0 ~]# blkid /dev/systemvg/vo
[root@server0 ~]# xfs_growfs /dev/systemvg/vo
[root@server0 ~]# df -h
[root@server0 ~]# df -Th #有显示类型
[root@server0 ~]# df -ａ #显示所有挂载

===============================================
2.卷组没有足够空间

卷组的扩展
vgextend 
例:
[root@server0 ~]# vgextend systemvg /dev/vdc3
逻辑卷扩展同上面第一步和第二步

修改卷组PE值(存在的卷组)
[root@server0 ~]# vgchange -s 1M systemvg
查看卷组详细的信息
[root@server0 ~]# vgdisplay systemvg

===============================================
删除逻辑组:先取消该逻辑卷挂载,再删除逻辑卷
[root@server0 ~]# umount /myvo
[root@server0 ~]# lvremove /dev/systemvg/vo
                                  
===============================================
删除卷组: 先删除该卷组下的所有逻辑卷,再删除卷组
例:
[root@server0 ~]# lvremove /dev/systemvg/vo
[root@server0 ~]# vgremove systemvg

===============================================
find查找
find高级使用(查找位置):递归查找
[root@server0 ~]# date -s '12:40:34'

-type 类型(l快捷方式,d目录,f文件文本)
find 目录路径 -type 选项
例:
[root@server0 ~]# find /root/ -type l
[root@server0 ~]# find /root/ -type f
[root@server0 ~]# find /root/ -type d

-name "文档名称"
find 目录路径 -name "文档名称"
例:
[root@server0 ~]# find /etc/ -name "passwd"
[root@server0 ~]# find /etc/ -name "passwd*"  #查找以passwd开头
[root@server0 ~]# find /etc/ -name "*passwd"  #查找以passwd结尾
[root@server0 ~]# find /etc/ -name "*passwd*" #查找包含passwd

-type与-name同时使用
例:
[root@server0 ~]# find /etc/ -name "passwd"  -type f     #两条件要同时满足
[root@server0 ~]# find /etc/ -name "passwd"  -o -type f  #一个条件满足即可

-size +|- 文件大小(k M G)
find 目录路径 -szie +|- 文件大小(k M G)
例:
[root@server0 ~]# find /boot/ -size +10M  #查找大于10M的文档
[root@server0 ~]# find /boot/ -size -10M  #查找小于10M的文档

-user 用户名
find 目录路径 -user 用户名
例:
[root@server0 ~]# find / -user student

-mtime 根据文件修改时间
所有的时间都是过去时间
-mtime +10 #十天之前创建或修改的数据
-mtime -10 #最近十天之内创建或修改的数据
-mtime +90 #三个月之前创建或修改的数据
find 目录路径 -mtime 时间大小
例:
[root@server0 ~]# find /var/log -mtime +10  
[root@server0 ~]# find /var/log -mtime -10

find扩展使用
使用find命令的-exec 操作
find 目录路径 __ -exec 处理命令 {}  \;
例:
[root@server0 ~]# find /boot/ -name "vm*" -exec cp {} /opt/ \;
或
[root@server0 ~]#　\cp -p $(find /boot/ -name "vm*") /opt

===============================================
查看当前系统时间:date

修改时间: date -s '年-月-日 时:分:秒'
例:
[root@server0 ~]# date -s '2016-10-12 12:12:12
或
[root@server0 ~]# date -s '12:40:34'

===============================================
NTP时间同步(chrony)
NTP网络时间协议
• Network Time Protocol
– NTP服务器为客户机提供标准时间
– NTP客户机需要与NTP服务器保持沟通

配置文件: /etc/chrony.conf
[root@server0 ~]# vim /etc/chrony.conf
#server 0.rhel.pool.ntp.org iburst   #开头加上#号，变成注释
#server 1.rhel.pool.ntp.org iburst   #开头加上#号，变成注释
#server 2.rhel.pool.ntp.org iburst   #开头加上#号，变成注释
server classroom.example.com iburst
             NTP服务器
安装软件包: chrony
[root@server0 ~]# yun -y install chrony
[root@server0 ~]# systemctl restart chronyd #重启服务(重启程序)
[root@server0 ~]# systemctl enable chronyd  #设置开机自启

测试时间同步
[root@server0 ~]# date -s '2009-12-9'
[root@server0 ~]# systemctl restart chronyd  #重启服务(重启程序)

===============================================
cron计划任务

周期性任务
cron任务概述
• 用途:按照设置的时间间隔为用户反复执行某一项固定的系统任务

• 软件包:cronie、crontabs
• 系统服务:crond
• 日志文件:/var/log/crond

管理计划任务策略
• 使用 crontab 命令
– 编辑:crontab -e [-u 用户名]
– 查看:crontab -l [-u 用户名]
– 清除:crontab -r [-u 用户名]

如何编写crontab任务记录
配置格式可参考 /etc/crontab 文件
分  时  日  月   周   任务命令行(绝对路径）
*   *   *   *    *    #每分钟执行一次   
0　８　*　 * 　*　　  ＃每天８点正执行一次
30　８　*　 * 　*　　 ＃每天８点半执行一次
２３１４　１　*　３　 ＃每月１号１４：23点或每周１４：２３点击执行一次
0 */2 * * * 　　　　　#每间隔２小时执行一次

*:匹配范围内任意时间
	,:分隔多个不连续的时间点
	-:指定连续时间范围
	/n:指定时间频率,每n ...

以root身份设置周期任务
[root@server0 ~]# crontab -e -u root



实际举例
crontab文件的一些例子：
30 21 * * * /etc/init.d/nginx restart              #每晚的21:30重启 nginx。
45 4 1,10,22 * * /etc/init.d/nginx restart       #每月1、 10、22日的4 : 45重启nginx。
10 1 * * 6,0 /etc/init.d/nginx restart             #每周六、周日的1 : 10重启nginx。
0,30 18-23 * * * /etc/init.d/nginx restart       #每天18 : 00至23 : 00之间每隔30分钟重启nginx。
0 23 * * 6 /etc/init.d/nginx restart                #每星期六的11 : 00 pm重启nginx。
* */1 * * * /etc/init.d/nginx restart                #每一小时重启nginx
* 23-7/1 * * * /etc/init.d/nginx restart           #晚上11点到早上7点之间，每 隔一小时重启nginx
0 11 4 * mon-wed /etc/init.d/nginx restart   #每月的4号与每周一到周三 的11点重启nginx
0 4 1 jan * /etc/init.d/nginx restart               #一月一号的4点重启nginx
*/30 * * * * /usr/sbin/ntpdate 210.72.145.20  #每半小时同步一下时间

 * 1 * * * /opt/script/backup.sh ：从1:0到1:59 每隔1分钟 执行
 15 05 * * * /opt/script/backup.sh ：05:15 执行
*/10 * * * * /opt/script/backup.sh ：每隔10分 执行
0 17 * * 1 /opt/script/backup.sh ：每周一的 17:00 执行
2 8-20/3 * * * /opt/script/backup.sh  8:02,11:02,14:02,17:02,20:02 执行

===============================================
家目录漫游

[root@server0 ~]# yum -y install authconfig-gtk sssd
[root@server0 ~]# authconfig-gtk
验证服务的基本DN是：dc=example,dc=com
系统classroom.example.com提供的LDAP服务
证书可以在下面的链接下载：http://classroom.example.com/pub/example-ca.crt
[root@server0 ~]# showmount -e classroom.example.com
[root@server0 ~]# mount classroom.example.com:home/guests /home/guests

================================================================================
2.Engineer

Engineer_day01========================================================================================

教学环境介绍

– 格式:rht-vmctl 控制指令 虚拟机名

reset(还原)

真机上操作：
　]# rht-vmctl reset classroom　 //先重置资源服务器
　]# rht-vmctl reset server
　]# rht-vmctl reset desktop　　 //再重置练习虚拟机
##################################################
Shell脚本基础

     脚本:一个可以执行的文件,运行可以实现某种功能

    创建用户zhangsan ------->  useradd zhangsan
   
1. 编写一个面世问候 /root/hello.sh 脚本
– 显示出一段话 “Hello World”
[root@server0 ~]# vim  /root/hello.sh
echo Hello World

[root@server0 ~]# chmod +x /root/hello.sh  #赋予执行权限
[root@server0 ~]# /root/hello.sh   #以绝对路径运行
 
规范Shell脚本的一般组成
• #! 环境声明,以下代码由那个程序进行运行
• # 注释文本
• 可执行代码

2. 编写一个能输出系统信息的 /root/sysinfo 脚本
1)输出当前红帽系统的版本信息
2)输出当前使用的内核版本
3)输出当前系统的主机名

[root@server0 ~]# vim /root/sysinfo
 #!/bin/bash
 cat /etc/redhat-release
 uname -r
 hostname
 ifconfig | head -2

[root@server0 ~]# chmod +x /root/sysinfo
[root@server0 ~]# /root/sysinfo

################################################
重定向输出

      >: 只收集前面命令的正确输出
     2>: 只收集前面命令的错误输出
     &>: 收集前面命令的所有输出
[root@server0 ~]# echo 123 > /opt/1.txt
[root@server0 ~]# cat /opt/1.txt
[root@server0 ~]# cat /a
[root@server0 ~]# cat /opt/1.txt  /a

[root@server0 ~]# cat /opt/1.txt  /a   > /opt/b.txt
[root@server0 ~]# cat /opt/b.txt

[root@server0 ~]# cat /opt/1.txt  /a   2> /opt/b.txt 
[root@server0 ~]# cat /opt/b.txt

[root@server0 ~]# cat /opt/1.txt  /a  &> /opt/b.txt 
[root@server0 ~]# cat /opt/b.txt

##################################################
补充:
    单引号 '  ' :屏蔽所有的特殊符号,原样输出

  [root@server0 ~]# echo  ' * ? | . .. &  '

   $( ) 或 反撇号 ` `:将命令输出结果,直接参与下一次运行

[root@server0 opt]# cd /opt/
[root@server0 opt]# mkdir $(hostname)

[root@server0 opt]# date +%F
[root@server0 opt]# mkdir mydir-$(date +%F)

#################################################
 案例:书写一个创建用户,设置密码的脚本user.sh  
     /dev/null:黑洞设备	  

[root@server0 /]# vim /root/user.sh
 #!/bin/bash
 useradd nsd04 &> /dev/null
 echo 用户nsd04创建成功
 echo 123 | passwd --stdin  nsd04 &> /dev/null
 echo 用户nsd04密码设置成功

[root@server0 /]# chmod +x /root/user.sh
[root@server0 /]# /root/user.sh

  为了让脚本适应多变的环境与多种不同需求,所以使用变量

   变量:会变化的量      容器=存放可以变化的量

    以不变的名称,存放可以变化的值
    变量名=存放的值

• 以不变的名称存放的可能会变化的值         
 – 变量名=变量值
 – 方便以固定名称重复使用某个值
 – 提高对任务需求、运行环境变化的适应能力

[root@server0 /]# cat /root/user.sh 
 #!/bin/bash
 a=nsd07                     #定义变量a,储存值nsd07
 useradd  $a &> /dev/null
 echo  用户$a创建成功
 echo  123  |  passwd --stdin  $a  &>  /dev/null
 echo  用户$a密码设置成功


定义/赋值变量
• 设置变量时的注意事项
– 等号两边不要有空格
– 变量名只能由字母/数字/下划线组成,区分大小写
– 变量名不能以数字开头,不要使用关键字和特殊字符
– 若指定的变量名已存在,相当于为此变量重新赋值

查看/引用变量
– 引用变量值:$变量名
– 查看变量值:echo $变量名、echo ${变量名}
[root@server0 /]# a=redhat
[root@server0 /]# echo $a
[root@server0 /]# echo $a7
[root@server0 /]# echo ${a}7

变量的种类

环境变量:变量名为大写,变量的值有系统定义完成

   USER=存储当前登录系统的用户
[root@server0 /]# echo $USER
root
[root@server0 /]# su - student
[student@server0 ~]$ echo $USER
student
[student@server0 ~]$ exit
logout
[root@server0 /]# 

位置变量
• 在执行脚本时提供的命令行参数
– 表示为 $n,n为序号
– $1、$2、.. .. ${10}、${11}、.. ..

[root@server0 /]# vim /root/1.sh 
#!/bin/bash
echo $1
echo $2
[root@server0 /]# chmod +x /root/1.sh
[root@server0 /]# /root/1.sh dc tc

[root@server0 /]#  vim /root/user.sh
#!/bin/bash
#a=nsd07
useradd $1 &> /dev/null
echo 用户$1创建成功
echo 123 | passwd --stdin  $1 &> /dev/null
echo 用户$1密码设置成功
[root@server0 /]#  /root/user.sh dc


[root@server0 /]# vim /root/cat.sh
 #!/bin/bash
 cat -n  $1  |  head -$2

[root@server0 /]# chmod +x /root/cat.sh
[root@server0 /]# /root/cat.sh /etc/passwd   3
[root@server0 /]# /root/cat.sh /etc/shadow   2

  降低脚本的使用难度,可以产生交互
   read  -p '屏幕提示信息'

         1.直接产生交互
         2.记录用户在键盘上的输入内容
         3.将 用户在键盘上的输入内容,赋值给一个变量储存

[root@server0 /]# cat /root/user.sh 
#!/bin/bash
read -p '请输入您要创建的用户名:'   a
read -p '请输入您要设置的密码:'   b
useradd $a &> /dev/null
echo 用户$a创建成功
echo $b | passwd --stdin  $a &> /dev/null
echo 用户$a密码设置成功
[root@server0 /]# 



预定义变量
• 用来保存脚本程序的执行信息
– 直接使用这些变量
– 不能直接为这些变量赋值

   $# 已加载的位置变量的个数
   $? 程序退出后的状态值,0表示正常,其他值异常

[root@server0 /]# vim /root/1.sh 
 #!/bin/bash
 echo $1
 echo $2
 echo $#

[root@server0 /]# /root/1.sh  haha  xixi 
[root@server0 /]# /root/1.sh  haha  xixi dc tc
[root@server0 /]# /root/1.sh  

##################################################
条件测试

     [   测试表达式   ]


常用的测试选项
• 检查文件状态
  -e:文档存在为真
  -d:文档存在,且必须为目录才为真
  -f:文档存在,且必须为文件才为真
[root@server0 /]# [  -e   /etc/passwd  ]
[root@server0 /]# echo $?

[root@server0 /]# [  -d   /etc/passwd  ]
[root@server0 /]# echo $?

[root@server0 /]# [  -d   /etc/  ]
[root@server0 /]# echo $?

[root@server0 /]# [  -f   /etc/fstab  ]
[root@server0 /]# echo $?


• 比较整数大小
   -gt:大于
   -ge:大于等于
   -eq:等于
   -ne:不等于
   -lt:小于
   -le:小于等于
[root@server0 /]# [  1  -eq  1  ]
[root@server0 /]# echo $?
0
[root@server0 /]# [  1  -gt  1  ]
[root@server0 /]# echo $?
1
[root@server0 /]# [  1  -ge  1  ]
[root@server0 /]# echo $?
0

• 字符串比对 
     ==: 两个字符串一样为真
     !=: 两个字符串不一样为真
[root@server0 /]# [  haha  !=  student ]
[root@server0 /]# echo $?
0
[root@server0 /]# [ haha  ==  haha  ]
[root@server0 /]# echo $?
0
[root@server0 /]# [ $USER  == root  ]
[root@server0 /]# echo $?
0
##################################################
if选择结构

双分支
	if  [条件测试];then
	  命令序列xx
	else
	  命令序列yy
	fi

[root@server0 /]# vim /root/if01.sh 
 #!/bin/bash
 if  [  $1  -eq  1  ];then
   echo hello
 else
   echo hi
 fi
[root@server0 /]# /root/if01.sh  1
[root@server0 /]# /root/if01.sh  2

[root@server0 /]# vim /root/if02.sh   
 #!/bin/bash
 if [ $# -eq 0  ];then
   echo 您没有输入参数
 else
   echo 您一共输入了 $# 个参数
 fi

[root@server0 /]# /root/if02.sh dc tc
 您一共输入了2个参数
[root@server0 /]# /root/if02.sh 
 您没有输入参数

##################################################
if多分支处理

	if  [条件测试1];then
	  命令序列xx
	elif  [条件测试2];then
	  命令序列yy

	else
	  命令序列zz
	fi

案例:
   利用read 读入用户输入的成绩
   如果用户输入的成绩大于等于90,则输出 优秀
   如果用户输入的成绩大于等于80,则输出 良好
   如果用户输入的成绩大于等于70,则输出 一般
   如果用户输入的成绩大于等于60,则输出 合格
   如果以上条件均不满足,则输出 '再牛的肖邦,也弹不出哥的悲伤'

[root@server0 /]# vim  /root/if03.sh
 #!/bin/bash
 read  -p  '请输入您的成绩:'    num
 if  [ $num -ge 90 ];then
    echo 优秀
 elif [ $num -ge 80 ];then
    echo 良好
 elif [ $num -ge 70 ];then
    echo 一般
 elif [ $num -ge 60 ];then
    echo 合格
 else
    echo '再牛的肖邦,也弹不出哥的悲伤'
 fi 
[root@server0 /]# 

###################################################
案例:书写一个判断用户的脚本
   利用位置变量$1,进行判断:
     如果用户存在,输出用户基本信息(id 用户)
     如果用户不存在,则创建该用户,输出用户创建成功
   
[root@server0 /]# vim  /root/if04.sh 
 #!/bin/bash
 id $1 &> /dev/null
 if  [ $? -eq 0 ];then
  echo 用户已存在
  id $1
 else
  useradd $1
  echo 用户创建成功
 fi


案例:
   利用read 读入用户输入的IP地址
     如果本机能够ping通该IP地址,则输出 可以通信        
     如果本机不能够ping通该IP地址,则输出 不可以通信
    ping  -c选项:指定ping几个包结束
[root@server0 /]# vim  /root/if05.sh
 #!/bin/bash
 read -p  '请输入您要测试的IP地址:'   ip
 ping -c 2  $ip &> /dev/null
 if  [ $? -eq 0 ];then
   echo $ip可以通信
 else
   echo $ip不可以通信
 fi

##################################################

for循环结构:解决反复执行重复性的操作


	for  变量名  in 值列表
	do
	    命令序列
	done

[root@server0 /]# vim /root/for01.sh
 #!/bin/bash
 for  a  in  lisi  zhangsan  wangwu  dc  tc
 do
  useradd $a  &> /dev/null
  echo  $a创建成功
 done
[root@server0 /]# 

  值的列表可以不参与循环体
[root@server0 /]# cat /root/for01.sh
 #!/bin/bash
 for a  in  {1..10}
 do
  echo I LOVE DC
 done

  造数工具:  {起始..结束}    {3..27} = 制造连续的数字 3到27

[root@server0 /]# cat /root/for02.sh
 #!/bin/bash
 for  a  in  {1..10}
 do
  useradd nsd$a  &> /dev/null
  echo nsd$a创建成功
 done

####################################################
案例4:编写一个判断脚本
在 server0 上创建 /root/foo.sh 脚本
1)当运行/root/foo.sh redhat,输出为fedora
2)当运行/root/foo.sh fedora,输出为redhat
3)当没有任何参数或者参数不是 redhat 或者fedora时,
其错误输出产生以下信息: /root/foo.sh redhat|fedora

####################################################

案例5:编写一个批量添加用户脚本
在 server0 上创建 /root/batchusers 脚本
1)此脚本要求提供用户名列表文件作为参数
2)如果没有提供参数,此脚本应该给出提示
 Usage: /root/batchusers,退出并返回相应值
3)如果提供一个不存在的文件,此脚本应该给出提
示 Input file not found,退出并返回相应值
4)新用户的登录Shell为 /bin/false,无需设置密码
5)用户列表测试文件:
http://classroom/pub/materials/userlist
###################################################


==================================================
Shell的使用方式
交互方式
人工干预　智能化程度高
条解释执行，效率低

非交互方式
需要提前设计　智能化难度大
批量执行　效率高
方便在后台静悄悄运行

规范Shell脚本的一般组成：
#! 环境声明（Sha-Bang）
# 注释文本
可执行代码

Shell脚本基础
脚本：一个可以执行的文件，运行可以实现某种功能
例：
[root@server0 ~]# vim /hello.sh
#!/bin/bash
echo "Hello World"
[root@server0 ~]# chmod +x /hello.sh
或
[root@server0 ~]# chmod ugo+x /hello.sh
[root@server0 ~]# /hello.sh   #执行脚本
 
＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
重定向输出
＞：　只收集前面命令的正确输出
２＞：只收集前面命令的错误输出
＆＞：收集正确及错误输出

＞：　只收集前面命令的正确输出
例如：
[root@server0 ~]# cat /opt/1.txt /zhai > /opt/2.txt　＃将正确信息输出收集
cat: /zhai: 没有那个文件或目录

２＞：只收集前面命令的错误输出
例如：
[root@server0 ~]# cat /opt/1.txt /zhai 2> /opt/2.txt　＃将错误信息输出收集
zhaiyanquan

＆＞：收集正确及错误输出　
例如：
[root@server0 ~]# cat /opt/1.txt /zhai &> /opt/2.txt　＃将错误信息和正确信息输出收集

补充
单引号＇＇：屏蔽所有的特殊符号，原样输出.
例如：
[root@server0 ~]# echo '*'
*

$()或``：将命令输出的结果，直接参与下一次执行
例如：
[root@server0 ~]# mkdir myzhai-$(date +%F)
[root@server0 ~]# mkdir myzhai-`date +%F`

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
Shell脚本创建用户

/dev/null:黑洞设备
例如：
[root@server0 ~]# vim /root/user.sh
#!/bin/bash
useradd zhai　&> /dev/null
echo 用户zhai创建成功

echo zhai | passwd --stdin zhai &> /dev/null

echo 用户zhai密码设置成功

[root@server0 ~]# chmod +x  /root/user.sh
[root@server0 ~]# /root/user.sh

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
Shell使用变量

什么是变量
以不变的名称存放的可能会变化的值
变量名＝变量值　＃等号两边不能有空格

定义/赋值变量

设置变量是的注意事项
若指定的变量名已存在，相当于为此变量重新赋值
等号两边不要有空格
变量名由字母／数字／下划线组成，区分大小写
变量名不能以数字开头，不要使用关键子和特殊符号

变量的种类
环境变量：变量名为大写，用来设置用户/系统环境
USER：存储当前登录系统的用户
[root@server0 ~]# echo $USER

位置变量
在执行脚本是提供的命令行参数
表示为$n, n为序号
$1 $2 ${10} ${11}
例:
#!/bin/bash
cat -n $1 | head -$2
[root@server0 ~]#  /root/cat.sh /etc/passwd 3
                                              $1        $2 

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
read交互

降低脚本的使用难度,可以产生交互
read -p "屏幕提示信息"
直接产生交互
记录用户在键盘上的输入内容
将用户在键盘上的输入内容,赋值给一个变量存储
例:
[root@server0 ~]# vim /root/user.sh
#!/bin/bash
read -p "请您输入用户名:" u
stty -echo  #隐藏显示
read -p "请您输入密码:" m
stty echo   #显示输入
useradd $u &> /dev/null
echo 用户$u创建成功

echo 1234 | passwd --stdin $u &> /dev/null

echo 用户$u密码设置成功

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
shell预定义变量

作用:用来保存脚本程序的执行信息
直接使用这些变量
不能直接为这些变量赋值
$#: 已加载的位置变量的个数
$*: 所有位置变量的值
$?: 程序退出的状态值,0表示正常,其他值异常

$#: 已加载的位置变量的个数
例:
[root@server0 ~]# vim /root/1.sh
#!/bin/bash
echo $1
echo $2
echo $#   #统计输入的参数个数
[root@server0 ~]# chmod +x /root/1.sh
[root@server0 ~]#  /root/1.sh fd  d
fd
d
2

$?: 程序退出的状态值,0表示正常,其他值异常
例:
[root@server0 ~]# cat /tab
cat: /tab: 没有那个文件或目录
[root@server0 ~]# echo $?
1

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
shell：if条件

-e: 文档存在为真
-d: 文档存在,且必须为目录为真
-f: 文档存在,且必须为文件为真

-e: 文档存在为真
例:
[root@server0 ~]# [ -e /etc/passwd ]
[root@server0 ~]# echo $?
0   #为真
[root@server0 ~]# [ -e /yy ]
[root@server0 ~]# echo $?
1  #为假

-d: 文档存在,且必须为目录为真
例:
[root@server0 ~]# [ -d /etc/passwd ]
[root@server0 ~]# echo $?
1
[root@server0 ~]# [ -d /etc ]
[root@server0 ~]# echo $?
0

-f: 文档存在,且必须为文件为真
例:
[root@server0 ~]# [ -f /etc/passwd ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ -f /etc/ ]
[root@server0 ~]# echo $?
1

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
shell：比较整数大小

-gt: 大于           
-ge: 大于等于       
-eq: 相等
-ne: 不等于
-lt: 小于
-le: 小于等于

-gt: 大于
例:
root@server0 ~]# [ 100 -gt 99 ]
[root@server0 ~]# echo $?
0

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
shell：字符串对比

== : 两个字符串一样为真
!= : 两个字符串不一样为真

== : 两个字符串一样为真
例:
[root@server0 ~]# [ zhai == zhai ]
[root@server0 ~]# echo $?
0

!= : 两个字符串不一样为真
例:
[root@server0 ~]# [ zhai != zhaiyanquan ]
[root@server0 ~]# echo $?
127

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
shell：if选择条件

if [ 条件测试];then
命令序列yy
else
命令序列dd
fi

例:
[root@server0 ~]# vim /root/if01.sh
#!/bin/bash

if [ $1 -eq 8 ];then
echo hello
else
echo hi
fi

[root@server0 ~]# chmod +x  /root/if01.sh
[root@server0 ~]# /root/if01.sh 9
hi

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
shell：if多分支处理

if [条件测试1];then
命令序列yy
elif [条件测试2]
命令序列dd
else
命令序列cc
fi

例:
[root@server0 ~]# vim /root/if03.sh
#!/bin/bash
read -p "请输入你的成绩:" num
if [ $num -ge 90 ];then
echo 优秀
elif [ $num -ge 80 ];then
echo 良好 
elif [ $num -ge 70 ];then
echo 一般
elif [ $num -ge 60 ];then
echo 及格
else
echo 再来玩一次
fi
[root@server0 ~]# chmod +x /root/if03.sh

例:
[root@server0 ~]# vim /root/if07.sh
#!/bin/bash
read -p "请输入要测试的ip地址:" ip
ping -c 2 $ip &> /dev/null

if [ $? -eq 0 ];then
echo $ip可以ping通
else
echo $ip不能ping通
fi

[root@server0 ~]# chmod +x /root/if07.sh

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
for循环结构: 反复执行类似的操作

for 变量名 in 值列表
do 
   命令序列
done

例:
[root@server0 ~]# vim /root/for01.sh
#!/bin/bash

for a in zhangsan lisi dc tc zhai yan quan
do

useradd $a &> /dev/null
echo 用户$a创建成功

done
[root@server0 ~]# chmod +x /root/for01.sh

{1..20}=制造造数工具
例:
#!/bin/bash
for a in {1..1000} #1到1000个
do
useradd $a &> /dev/null
echo 用户$a创建成功
done

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
>&2: 将正确输出变成错误输出信息
echo '/root/foo.sh redhat|fedora' >&2

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
本例要求在虚拟机 server0 上创建 /root/foo.sh 脚本，任务目标如下：
当运行/root/foo.sh redhat，输出为fedora
当运行/root/foo.sh fedora，输出为redhat
当没有任何参数或者参数不是 redhat 或者 fedora时，其错误输出产生以下信息： /root/foo.sh redhat|fedora

[root@server0 ~]# vim /root/batchusers
#!/bin/bash

if [ $# -eq 0 ];then #判断是否输入参数

   echo '/root/foo.sh redhat|fedora' >&2 #输出错误信息
   exit 88

elif [ $1 == redhat ];then  #判断输入的参数是否是redhat

   echo fedora 

elif [ $1 ==  fedora ];then #判断输入的参数是否是fedora

   echo redhat

else

   echo '/root/foo.sh redhat|fedora' >&2 #输出错误信息
   exit 99

fi

[root@server0 ~]# chmod +x  /root/batchusers

Engineer_day02========================================================================================

教学环境介绍

– 格式:rht-vmctl 控制指令 虚拟机名

reset(还原)

真机上操作：
　]# rht-vmctl reset classroom　 //先重置资源服务器
　]# rht-vmctl reset server
　]# rht-vmctl reset desktop　　 //再重置练习虚拟机

####################################################
案例4:编写一个判断脚本
在 server0 上创建 /root/foo.sh 脚本
1)当运行/root/foo.sh redhat,输出为fedora
2)当运行/root/foo.sh fedora,输出为redhat
3)当没有任何参数或者参数不是 redhat 或者fedora时,
   其错误输出产生以下信息: /root/foo.sh redhat|fedora

[root@server0 ~]# vim /root/foo.sh    
 #!/bin/bash
 if [ $# -eq 0 ];then
  echo '/root/foo.sh redhat|fedora' >&2 #输出变成错误输出
  exit 38     #程序退出返回值
 elif [ $1 == redhat ];then
  echo fedora
 elif [ $1 == fedora ];then
  echo redhat 
 else
  echo '/root/foo.sh redhat|fedora' >&2 #输出变成错误输出
  exit 39     #程序退出返回值
 fi
 
[root@server0 ~]# /root/foo.sh tc  
[root@server0 ~]# echo  $?


####################################################

案例5:编写一个批量添加用户脚本
在 server0 上创建 /root/batchusers 脚本
1)此脚本要求提供用户名列表文件作为参数
2)如果没有提供参数,此脚本应该给出提示
  Usage: /root/batchusers,退出并返回相应值
3)如果提供一个不存在的文件,此脚本应该给出提
示 Input file not found,退出并返回相应值
4)新用户的登录Shell为 /bin/false,无需设置密码
5)用户列表测试文件:
[root@server0 ~]# vim /root/userlist 
duanwu
zhongqiu
zhsan
[root@server0 ~]# vim /root/batchusers
#!/bin/bash
if  [ $# -eq 0 ];then               #判断用户是否输入参数
 echo 'Usage: /root/batchusers' >&2
 exit 2
elif  [ -f $1 ];then      #判断用户输入参数,是否存在且为文件
 for a  in  $(cat  $1)
 do
  useradd  -s /bin/false $a  &> /dev/null
  echo  $a创建成功
 done
else
 echo  'Input file not found' >&2
 exit  3
fi
[root@server0 ~]# /root/batchusers  /root/userlist

###################################################
系统安全保护,SELinux安全机制
• Security-Enhanced Linux
– 美国NSA国家安全局主导开发,一套增强Linux系统安
全的强制访问控制体系
– 集成到Linux内核(2.6及以上)中运行
– RHEL7基于SELinux体系针对用户、进程、目录和文件
提供了预设的保护策略,以及管理工具

• SELinux的运行模式
– enforcing(强制)、permissive(宽松)
– disabled(彻底禁用)

 任何模式变成disabled(彻底禁用)模式,必须修改配置文件重启系统

• 切换运行模式
– 临时切换:setenforce 1|0
– 固定配置:/etc/selinux/config 文件
虚拟机server
[root@server0 ~]# getenforce     #查看当前SELinux状态
[root@server0 ~]# setenforce 0   #修改当前SELinux状态
[root@server0 ~]# getenforce 
[root@server0 ~]# vim /etc/selinux/config  #永久配置文件
   命令模式按大写的C,可以删除光标之后进入插入模式
 SELINUX=permissive   #permissive(宽松)
   
虚拟机desktop
[root@desktop0 ~]# getenforce 
[root@desktop0 ~]# setenforce 0
[root@desktop0 ~]# getenforce #查看SELinux状态
[root@desktop0 ~]# vim /etc/selinux/config 
 SELINUX=permissive
###################################################
配置用户环境

• 影响指定用户的 bash 解释环境
– ~/.bashrc,每次开启 bash 终端时生效

• 影响所有用户的 bash 解释环境
– /etc/bashrc,每次开启 bash 终端时生效

[root@server0 ~]# vim /root/.bashrc 
alias hello='echo hello'
[root@server0 ~]# vim /home/student/.bashrc
alias hi='echo hi'
[root@server0 ~]# vim /etc/bashrc 
alias tcc='echo dcc'
开启一个新的终端,再去测试(退出远程管理,在从新进行远程管理)
[root@server0 ~]# hello
[root@server0 ~]# hi  #执行失败
[root@server0 ~]# tcc

[root@server0 ~]# su - student
[student@server0 ~]$ hello  #执行失败
[student@server0 ~]$ hi
[student@server0 ~]$ tcc
[student@server0 ~]$ exit


真机上的操作:定义别名
[student@room9pc01 ~]$ vim /home/student/.bashrc 
   alias  gos='ssh -X root@172.25.0.11'
   alias  god='ssh -X root@172.25.0.10'

真机上新开一个终端,进行验证

##################################################
防火墙策略管理

一  虚拟机server搭建基本Web服务

Web服务:提供一个页面内容的服务

1.安装httpd软件包
[root@server0 ~]# yum -y install httpd
[root@server0 ~]# rpm -q httpd

2.重启httpd服务
[root@server0 ~]# systemctl restart httpd

3.本机通过浏览器进行测试:
[root@server0 ~]# firefox 172.25.0.11

4.在虚拟机server书写一个页面文件
      默认存放网页文件的路径: /var/www/html
      默认页面文件名称:index.html
marquee是滚动标签，font color=red是字体颜色  红色，h1是字体大小
[root@server0 ~]# vim /var/www/html/index.html
 <滚动标签><字体颜色  红色><字体大小>NSD1903阳光明媚
                     
[root@server0 ~]# firefox 172.25.0.11

二  虚拟机server构建FTP服务器         
   FTP服务:文件传输服务
      默认FTP共享路径:/var/ftp

1.安装vsftpd软件包
[root@server0 ~]# yum -y install vsftpd

2.重启vsftpd服务
[root@server0 ~]# systemctl restart vsftpd

3.验证FTP服务:
[root@server0 ~]# firefox ftp://172.25.0.11

#################################################
防火墙策略(firewall)
      作用:隔离

    硬件防火墙
    软件防火墙
    
firewalld服务基础

Linux的防火墙体系
 • 系统服务:firewalld
 • 管理工具:firewall-cmd、firewall-config


预设安全区域
• 根据所在的网络场所区分,预设保护规则集
– public:仅允许访问本机的sshd  ping  dhcpd服务
– trusted:允许任何访问
– block:阻塞任何来访请求(明确拒绝,客户端有接收回应)
– drop:丢弃任何来访的数据包(直接丢弃,客户端没有接收回应) 节省服务器资源


 数据包: 目标IP地址   源IP地址   数据

防火墙判定的规则:匹配及停止
1.查看请求数据包中源IP地址,然后查询防火墙所有区域,那个区域有该IP地址的规则,则进入该区域

2.进入默认区域public(由root指定)

###############################################
一  防火墙默认区域的修改(firewall)
虚拟机server:
]# firewall-cmd --get-default-zone   #查看默认区域
虚拟机desktop:
]# ping  -c 2 172.25.0.11   #可以通信

虚拟机server:
]# firewall-cmd --set-default-zone=block   #修改默认区域
]# firewall-cmd --get-default-zone        #查看默认区域
虚拟机desktop:
]# ping -c 2 172.25.0.11   #不可以通信,有回应

虚拟机server:
]# firewall-cmd --set-default-zone=drop  #修改默认区域
]# firewall-cmd --get-default-zone      #查看默认区域
虚拟机desktop:
]# ping -c 2 172.25.0.11   #不可以通信,没有回应


二  默认区域public 仅允许访问本机的sshd  ping  dhcpd服务
虚拟机server:
]# firewall-cmd  --set-default-zone=public 
]# firewall-cmd  --get-default-zone 
虚拟机desktop:
]# ping -c 2 172.25.0.11   #可以通信

在区域中添加允许访问的服务或协议
             http:超文本传输协议
             https:安全超文本传输协议
             DNS:域名解析协议
             FTP:文件传输协议
             TFTP:简单文件传输协议
             telnet:远程管理协议
             pop3:邮件协议(用户收邮件协议)
             SMTP:邮件协议(用户发邮件协议)
             SNMP:简单的网络管理协议
虚拟机server:  
# firewall-cmd --zone=public --list-all  #查看区域规则
# firewall-cmd --zone=public --add-service=http #添加协议
# firewall-cmd --zone=public --list-all  #查看区域规则
虚拟机desktop
# firefox 172.25.0.11  #可以访问
# firefox ftp://172.25.0.11  #不可以访问

虚拟机server:
]# firewall-cmd --zone=public --add-service=ftp #添加协议
]# firewall-cmd --zone=public --list-all  #查看区域规则
虚拟机desktop
]# firefox ftp://172.25.0.11  #可以访问

####################################################
永久的防火墙规则  永久(permanent)

虚拟机server
]# firewall-cmd --reload    #重新加载所有防火墙策略
]# firewall-cmd --zone=public --list-all  #查看区域策略

]# firewall-cmd --permanent --zone=public --add-service=http        #永久添加策略

]# firewall-cmd --zone=public --list-all  #查看区域策略

]# firewall-cmd --reload   #重新加载所有防火墙策略
]# firewall-cmd --zone=public --list-all  #查看区域策略

####################################################
补充:
  单独拒绝虚拟机desktop访问虚拟机server所有请求
虚拟机server
]# firewall-cmd --zone=block --add-source=172.25.0.10
]# firewall-cmd --zone=block --list-all 

虚拟机desktop 访问测试 
]#  ping  172.25.0.11 #不可以访问
]#  firefox  172.25.0.11  #不可以访问
真机  访问测试
]#  ping  172.25.0.11 #可以访问
]#  firefox  172.25.0.11  #可以访问
####################################################

=================================================
SELinux运行模式的切换

enforcing：强制启用，内核加载SELinux安全体系，并强制执行保护策略
permissive：宽松模式，内核加载SELinux安全体系，只记录不执行
disabled：彻底禁用，内核在启动时不加载SELinux安全体系

临时切换 : setenforce 1|0   #立即生效
例: 影响当前模式
[root@server0 ~]# setenforce 0  #临时关闭SELinux 

固定配置: /etc/selinux/config   #永久配置文件 (重启后才能生效)
[root@server0 ~]# vim /etc/selinux/config
SELINUX=permissive  #宽松模式

getenforce: 查看当前模式
[root@server0 ~]# getenforce 
Permissive
[root@server0 ~]# firefox 172.25.0.11

==================================================
alias别名设置

命令别名：为一个复杂的命令行建立一个更加简短的命令字，方便重复使用。

基本管理操作：
定义别名：alias 别名='复杂的命令行'
查看别名：alias、alias 别名
取消别名：unalias 别名、unalias -a

用户登录初始化文件：
全局配置：/etc/bashrc
用户自定义配置：~/.bashrc

全局配置：/etc/bashrc  #所有用户都可以使用别名
例:
[root@server0 ~]# vim /etc/bashrc
alias zhai='echo ZHAI'

用户自定义配置：~/.bashrc  #只有student登录下使用该别名(给某个用户设置别名)
例:
[root@server0 ~]# vim /home/student/.bashrc 
alias yan='echo YAN'
[root@server0 ~]# su - student
例:
[root@server0 ~]# vim /root/.bashrc   #给root设置别名

=================================================
搭建基本Web服务

Web服务: 提供一个页面内容的服务

安装httpd软件包
[root@server0 ~]# yum -y install httpd
[root@server0 ~]# rpm -q httpd

重启httpd服务
[root@server0 ~]# systemctl restart httpd
[root@server0 ~]# systemctl enable httpd

本机通过浏览器进行测试
[root@server0 ~]# firefox 172.25.0.11

在虚拟机server书写一个页面文件
默认存放网页文件的路径: /var/www/html
默认页面文件名称: index.html
例:
marquee是滚动标签，font color=red是字体颜色  红色，h1是字体大小
[root@localhost ~]# vim /var/www/html/index.html
<滚动标签><字体颜色  红色><字体大小>zhaiyanquan
  滚动              修改颜色   加粗
[root@localhost ~]# firefox 172.25.0.11  #访问页面

=================================================
搭建FTP服务

在虚拟机servser搭建FTP服务
FTP服务: 文件传输服务
默认FTP共享路径: /var/ftp

安装vsftpd软件包
[root@server0 ~]# yum -y install vsftpd

重启vsftp服务
[root@localhost ~]# systemctl restart vsftpd
[root@localhost ~]# systemctl enable vsftpd

验证FTP服务
[root@server0 ~]# firefox ftp://172.25.0.11

=================================================
防火墙策略

作用: 隔离
分类: 硬件防火墙和软件防火墙

Linux的防火墙体系
系统服务: firewalld
管理工具: firewall-cmd(命令工具), firewall-config(图形工具)

RHEL7的防火墙体系根据所在的网络场所区分，提供了预设的安全区域：
public：仅允许访问本机的sshd ping httpd服务
trusted：允许任何访问 
block：阻塞任何来访请求
drop：丢弃任何来访的数据包(节省服务器资源)

数据包: 目标IP地址 源IP地址  

=================================================
拒绝别人远程自己
[root@server0 ~]# systemctl stop sshd     #关闭服务
[root@server0 ~]# systemctl restart sshd  #开启服务

=================================================
防火墙默认区域修改

例:
虚拟机server:
[root@server0 ~]# firewall-cmd --get-default-zone  #查看默认区域
public
虚拟机desktop:
[root@desktop ~]# ping 172.25.0.11  #可以通信

虚拟机server:
[root@server0 ~]# firewall-cmd --set-default-zone=block  #修改默认区域
[root@server0 ~]# firewall-cmd --get-default-zone        #查看默认区域
虚拟机desktop:
[root@desktop ~]# ping -c 2 172.25.0.11  #不可以通信,有回应

虚拟机server:
[root@server0 ~]# firewall-cmd --set-default-zone=drop  #修改默认区域
[root@server0 ~]# firewall-cmd --get-default-zone       #查看默认区域
虚拟机desktop:
[root@desktop ~]# ping -c 2 172.25.0.11  #不可以通信,没回应

在区域中添加允许访问的服务或协议
     http: 超文本传输协议                80
     https: 安全超文本传输协议          443
     DNS: 域名解析协议                   53
     FTP: 文本传输协议                   21 
     TFTP: 简单文本传输协议             69
     talent: 远程管理协议               23
     pop3: 邮件协议(用户收邮件协议)     110
     SMTP: 邮件协议(用户发送文件协议)   25
     SNMP:简单的网络管理协议            161

虚拟机server:
[root@server0 ~]# firewall-cmd --zone=public --list-all          #查看区域规则
[root@server0 ~]# firewall-cmd --zone=public --add-service=http  #添加协议
[root@server0 ~]# firewall-cmd --zone=public --list-all          #查看区域规则
虚拟机desktop:
[root@desktop ~]# firefox 172.25.0.11        #可以访问
[root@desktop ~]# firefox ftp://172.25.0.11  #不可以访问
 
虚拟机server:
[root@server0 ~]# firewall-cmd --zone=public --list-all         #查看区域规则
[root@server0 ~]# firewall-cmd --zone=public --add-service=ftp  #添加协议
[root@server0 ~]# firewall-cmd --zone=public --list-all         #查看区域规则
虚拟机desktop: 
[root@desktop ~]# firefox ftp://172.25.0.11  #可以访问

============================================================
永久的防火墙规则

#permanent永久添加策略
[root@localhost ~]# firewall-cmd --permanent --zone=public --add-service=ftp
[root@localhost ~]# firewall-cmd --permanent --zone=public --add-service=http
#查看区域策略
[root@localhost ~]# firewall-cmd --zone=public --list-all
#重新加载所有防火墙策略
[root@localhost ~]# firewall-cmd --reload
#查看区域策略
[root@localhost ~]# firewall-cmd --zone=public --list-all

补充
单独拒绝虚拟机server0访问虚拟机server0


============================================================
端口转发(firewall):
编号 标识服务或协议或程序

本地应用的端口重定向(端口1-->端口2)
从客户机访问 端口1 的请求,自动映射到本机 端口2
比如: 访问以下两个地址可以看到相同的页面
客户端访问是: 172.25.0.11 5423----->防火墙------>172.25.0.11 80

虚拟机server:
[root@server0 ~]# firewall-cmd --permanent --zone=public --add-forward-port=port=5423:proto=tcp:toport=80
[root@server0 ~]# firewall-cmd --reload
[root@server0 ~]# firewall-cmd --zone=public --list-all

删除
[root@server0 ~]# firewall-cmd --zone=block --remove-source=172.25.0.0/24


虚拟机desktop:
[root@desktop0 ~]# firefox 172.25.0.11:5423

============================================================
触发挂载

安装autofs可以实现触发挂载软件
[root@server0 ~]# systemctl enable autofs

重启autofs服务
[root@server0 ~]# systemctl enable autofs
[root@server0 ~]# systemctl restart autofs

进行触发挂载
[root@server0 cd]# ls /misc/
[root@server0 cd]# cd /misc/cd
[root@server0 cd]# ls /misc/cd

[root@server0 cd]# ls /etc/auto.master   #触发挂载的主配置文件
[root@server0 cd]# vim /etc/auto.master
/nsd        /etc/test
监控点   指定挂载配置文件的路径

翻译:
设置监控点为/misc,要想知道挂载什么设备,请看/etc/auto.misc文件
[root@server0 cd]# fdisk /dev/vdb
[root@server0 cd]# mkfs.xfs /dev/vdb1
[root@server0 cd]# vim /etc/test
zhai -fstype=xfs,rw  :/dev/vdb1
[root@server0 cd]# systemclt restart autofs
[root@server0 ~]# cd /nsd/zhai
[root@server0 zhai]# df -Th  #查看挂载使用信息

============================================================
swap分区(交换分区)

[root@server0 ~]# mkswap /dev/vdb3   #格式化交换文件系统
[root@server0 ~]# blkid /dev/vdb3    #查看文件系统类型
[root@server0 ~]# vim /etc/fstab     #开机自动挂载
/dev/vdb3 swap swap defaults 0 0 
[root@server0 ~]# swapon -a          #检测/dev/vdb3
[root@server0 ~]# swapon -s          #查看交换分区空间组成,成员信息
[root@server0 ~]# swapon /dev/vdb3   #启用
[root@server0 ~]# swapoff /dev/vdb3  #停用

Engineer_day03========================================================================================

教学环境介绍

– 格式:rht-vmctl 控制指令 虚拟机名

reset(还原)

真机上操作：
　]# rht-vmctl reset classroom  #先重置资源服务器
　]# rht-vmctl reset server
　]# rht-vmctl reset desktop　  #再重置练习虚拟机

####################################################
环境准备:
虚拟机server
]# firewall-cmd --set-default-zone=trusted  #允许所有访问

虚拟机desktop
]# firewall-cmd --set-default-zone=trusted  #允许所有访问

###################################################
在虚拟机server:划分一个3G的主分区
[root@server0 ~]# fdisk /dev/vdb

[root@server0 ~]# lsblk
[root@server0 ~]# ls /dev/vdb1

###################################################
iSCSI服务基础

iSCSI磁盘的工作模式(默认端口:3260)
• Internet SCSI,网际SCSI接口
– 一种基于C/S架构的虚拟磁盘技术
– 服务器提供磁盘空间,客户机连接并当成本地磁盘使用

• backstore,后端存储
– 对应到服务端提供实际存储空间的设备,需要起一个管理名称

• target,磁盘组(木质的箱子)
– 是客户端的访问目标,作为一个框架,由多个lun组成

• lun,逻辑单元(将后端存储放入磁盘组)
– 每一个lun需要关联到某一个后端存储设备,在客户端
会视为一块虚拟硬盘

   /dev/vdb1 (backstore,后端存储)
  
      大冰箱---->纸质的包装      木质的箱子

• ISCSI Qualified Name(iqn) 名称规范
– iqn.yyyy-mm.倒序域名:自定义标识
– 用来识别 target 磁盘组,也用来识别客户机身份

• 名称示例
– iqn.2016-02.com.example:server0
– iqn.2016-02.com.example:desktop0


服务端:虚拟机server 提供磁盘空间

一 所需软件包:targetcli(服务端软件)
[root@server0 ~]# yum -y install targetcli

二 运行targetcli进行配置
[root@server0 ~]# targetcli
   /> ls
 1)创建后端存储(backstore,后端存储)
   /> backstores/block  create  name=nsd dev=/dev/vdb1
   /> ls
 2)创建target,磁盘组(木质的箱子)
[root@server0 ~]# targetcli
   /> iscsi/ create iqn.2019-04.com.example:server0
   /> ls
 3)配置lun,关联(将后端存储放入磁盘组)
   /> iscsi/iqn.2019-04.com.example:server0/tpg1/luns     create /backstores/block/nsd 

   /> ls

  4)配置ACL访问控制,设置客户端声称的名字
/> iscsi/iqn.2019-04.com.example:server0/tpg1/acls create iqn.2019-04.com.example:desktop0

   /> ls
  5)设置本机提供服务端的IP地址与端口
 /> iscsi/iqn.2019-04.com.example:server0/tpg1/portals create   172.25.0.11
   /> ls

   /> exit   #保存并退出

三  重启服务端服务
[root@server0 ~]# systemctl restart target
[root@server0 ~]# systemctl enable target  #设置开机自启动
ln -s '/usr/lib/systemd/system/target.service' '/etc/systemd/system/multi-user.target.wants/target.service'

#提示:会制作一个快捷方式,不是报错

###################################################

客户端:虚拟机desktop 访问使用服务端提供磁盘空间
一 安装客户端软件
• 所需软件包:iscsi-initiator-utils
 Yum仓库软件包的补全:  1.Yum必须要有缓存  2.当前系统没有安装

 Yum必须要有缓存 :yum  repolist  可以生成缓存

[root@desktop0 ~]# rpm -q  iscsi-initiator-utils 
iscsi-initiator-utils-6.2.0.873-21.el7.x86_64

[root@desktop0 ~]# yum -y install  iscs(tab)

二 修改配置文件,指定客户端生成的命令
[root@desktop0 ~]# vim /etc/iscsi/initiatorname.iscsi 
InitiatorName=iqn.2019-04.com.example:desktop0

三 重启iscsid服务,用于识别客户端声称的名字
[root@desktop0 ~]# systemctl restart iscsid
  Warning: Unit file of iscsid.service changed on  
  disk, 'systemctl daemon-reload' recommended.
[root@desktop0 ~]# systemctl daemon-reload
[root@desktop0 ~]# systemctl restart iscsid

四  运行iscsiadm命令,发现服务端共享存储
  Linux查看命令帮助的方法 :  man  iscsiadm 
   全文查找/example   按n项下跳转匹配,看到EXAMPLES

   Ctrl    - ：减小字体
   Ctrl   Shift   + ：变大字体

]# iscsiadm --mode discoverydb --type sendtargets --portal 172.25.0.11 --discover

屏幕显示信息:
172.25.0.11:3260,1 iqn.2019-04.com.example:server0

五 重启iscsi服务(客户端服务),加载服务端共享存储

[root@desktop0 ~]# systemctl restart iscsi
[root@desktop0 ~]# systemctl enable iscsi
[root@desktop0 ~]# lsblk 

#################################################
数据库基本管理

  什么是数据库:存放数据的仓库

  数据库的结构: 在数据库里,有很多的库,在每一个库中有很多的表格

一 部署mariadb数据库服务器(默认的端口 3306)
   mariadb-server:提供服务端有关的系统程序

[root@server0 ~]# yum -y install mariadb-server
[root@server0 ~]# systemctl restart mariadb

二 数据库的基本操作
[root@server0 ~]# mysql        #进入数据库,默认无需密码
MariaDB [(none)]> show  databases;       #查看所有数据库
MariaDB [(none)]> create  database nsd;  #创建库

MariaDB [(none)]> show  databases;    #查看所有数据库
MariaDB [(none)]> drop  database  nsd;    #删除nsd库

MariaDB [(none)]> show databases;     #查看所有数据库

MariaDB [(none)]> create  database nsd1903;  #创建库
MariaDB [(none)]> show databases;  

MariaDB [(none)]> exit               #15:05

三  为数据库管理员设置密码

   数据库管理员为root,数据库所有用户信息,由mysql库中user表
   系统管理员为root,系统所有用户信息,由/etc/passwd

MariaDB [(none)]> exit
Bye
[root@server0 ~]#
 
• 为数据库账号修改密码
– mysqladmin [-u用户名] [-p[旧密码]] password  '新密码'

[root@server0 ~]# mysqladmin -u root  password '123'
[root@server0 ~]# mysql -u root -p    #交互式
Enter password: 

[root@server0 ~]# mysql -u root -p123  #非交互式

四  表格操作: 表记录  表字段

         编号      姓名      性别        联系方式         地址   
     1       dc     女           123              东村
     2       tc     女           456              西村
     3       lisi   男           789              北庄

   四大操作:  增 insert  删 delete   改 update  查 select

[root@server0 ~]# mysql -u root -p123
MariaDB [(none)]> show databases;
MariaDB [test]> use mysql;     #进入mysql库
MariaDB [mysql]> show  tables;  #查看当前库中有那些表格
MariaDB [mysql]> desc  user;   #查看表结构

数据库的导入操作
• 导入/恢复到数据库
]# wget http://classroom.example.com/pub/materials/users.sql

]# ls
导入数据到指定数据库:
]# mysql -u root -p123 nsd1903 < /root/users.sql 
]# mysql -u root -p123
> use nsd1903;
> show tables;                   
  +-------------------+
 | Tables_in_nsd1903 |  
  +-------------------+ 
 | base              |               
 | location          |
  +-------------------+

###################################################
表格的查询:
  select 表字段   from  表名;

]# mysql -u root -p123
> use nsd1903;
> select * from base;

> use mysql;
> select  *  from nsd1903.base;
> use nsd1903;

> select * from location;
> select name from base;
> select id,name from base;

有条件查询:
  查找base中密码为123的人?
> use nsd1903;
> select * from base;
> select * from base where password='123';

> select * from base where password='456';

> select * from base where name='tom';

> select id,name from base where name='tom';
> select name,password from base where name='tom';


• 禁止网络进行连接,只服务于本机
[root@server0 ~]# vim /etc/my.cnf  #主配置文件
[mysqld]
skip-networking   //手写,跳过网络监听
.. ..
[root@server0 ~]# systemctl restart mariadb

###############################################
数据库授权

– 除了 root 用户,此nsd1903数据库,只能被用户lisi查询,
此用户的密码为123

  不需要创建系统用户lisi

– GRANT  权限列表   ON  数据库名.表名   TO  用户名@客户机地址 IDENTIFIED BY '密码';

  grant select  on  nsd1903.*  to  lisi@localhost  identified by '123';

   当lisi从本地localhost进行登录,输入密码123,将会获得nsd1903库所有表的查询权限.
[root@server0 ~]# mysql -u root -p123

> grant select on nsd1903.* to lisi@localhost identified by '123';

> select user,host,password from mysql.user;

[root@server0 ~]# mysql -u lisi -p123
MariaDB [(none)]> exit
Bye

#################################################
案例4:使用数据库查询


2. 在系统 server0 上使用数据库 nsd1903,并使用相
应的 SQL 查询以回答下列问题:
  1)base表密码是 solicitous 的人的名字?
[root@server0 ~]# mysql -u root -p123
> use nsd1903;
> select * from base;
> select * from base where password='solicitous';

  2)有多少人的姓名是 Barbara 同时居住在 Sunnyvale?
> select * from base,location        
  where  base.name='Barbara'  and 
  location.city='Sunnyvale'   and  base.id=location.id; 

> select count(*) from base,location         
  where base.name='Barbara' and 
  location.city='Sunnyvale' and base.id=location.id; 

> insert base values('6','Barbara','789'); #插入表记录
> select * from base;

> insert location values('6','Sunnyvale'); #插入表记录
> select * from location;


1. 禁止空密码root用户访问 mariadb数据库
> use mysql;
> select user,host,password from user;

> select user,host,password from user where password='';
> delete from user where password='';

> select user,host,password from user;

> flush privileges;  #刷新user所有记录


[root@server0 ~]# mysql -u root -h server0.example.com
登录失败

####################################################

==========================================================
iSCSI服务基础

iSCSI磁盘的工作模式(默认端口: 3260)
一种基于C/S架构的虚拟机磁盘技术
服务器提供磁盘空间,客户机连接并当成本地磁盘使用

服务端: 虚拟机server 提供磁盘空间

一.所需软件包: targetcli(服务端软件)
[root@server0 ~]# yum -y install targetcli

二.运行targetcli进行配置
[root@server0 ~]# targetcli
/> ls

1. 创建后端存储backstores,后端存储
/> backstores/block create name=nsd dev=/dev/vdb1
                            创建         取名         磁盘
/> ls

2.创建target,磁盘组(木质的箱子)
[root@server0 ~]# targetcli
/> iscsi/ create iqn.2019-03.com.example:server0  或 /> iscsi/ create iqn.2019-03.a.b:zhai
              创建                                    自定义
/> ls

3. 配置lun,关联(将后端存储放入磁盘组)
/> iscsi/iqn.2019-03.com.example:server0/tpg1/luns create /backstores/block/nsd
/> ls 

4. 配置ACL访问控制,设置客户端声称的名字
/> iscsi/iqn.2019-03.com.example:server0/tpg1/acls create iqn.2019-03.com.example:desktop0 
                                             (iqn.2019-03.com.example:desktop0: 客户机要一样          
/> ls             

5.设置本机提供服务端的ip地址于与端口
/> iscsi/iqn.2019-03.com.example:server0/tpg1/portals create 172.25.0.11
/> ls 

三. 重启服务端服务
[root@server0 ~]# systemctl restart target
[root@server0 ~]# systemctl enable target
ln -s '/usr/lib/systemd/system/target.service' '/etc/systemd/system/multi-user.target.wants/target.service'
#提示: 会制作一个快捷方式,不是报错!


客户端: 虚拟机desktop 访问使用服务端提供的磁盘空间

一. 安装客户端
所需软件包: iscsi-initiator-utils
Yum仓库软件包的补全: 1. Yum必须要有缓存 2.当前系统没有安装

yum必须要有缓存: yum reppolist  可以生成缓存

[root@desktop0 ~]# yum -y install  iscsi-initiator-utils #安装软件包
[root@desktop0 ~]# rpm -q install iscsi-initiator-utils  #查看是否安装

二. 修改配置文件,指定客户端生成的名字 
[root@desktop0 ~]# vim /etc/iscsi/initiatorname.iscsi
InitiatorName=iqn.2019-03.com.example:desktop0

三.重启iscsid服务
[root@desktop0 ~]# systemctl restart iscsid
[root@desktop0 ~]# systemctl daemon-reload  #回车如果有提示,运行此命令
[root@desktop0 ~]# systemctl restart iscsid
[root@desktop0 ~]# systemctl enable iscsid  #设置开机自启

四. 运行iscsiadm命令,发现服务端共享存储
[root@desktop0 ~]# man iscsiadm  #进入后查找/EXAMPLE ,找到以iscsiadm --mode开头复制此行
[root@desktop0 ~]# iscsiadm --mode discoverydb --type sendtargets --portal 172.25.0.11 --discover
172.25.0.11:3260,1 iqn.2019-03.com.example:server0  #屏幕显示

五. 重启iscsi服务(客户端服务),加载服务端共享存储
[root@desktop0 ~]# systemctl restart iscsi
[root@desktop0 ~]# systemctl enable iscsi

删除
/> iscsi/ delete iqn.2019-02.com.example:serve02

==========================================================================
数据库基本管理
什么是数据库: 存放数据的仓库

一. 部署Mariadb数据库服务器(默认端口:3306)
mariadb-server: 提供服务端有关的系统程序
mariadb: 提供客户端及管理工具
安装mariadb-server
[root@server0 ~]# yum -y install mariadb-server
[root@server0 ~]# systemctl restart mariadb

二. 数据库基本操作
MariaDB [(none)]> show databases;       #查看数据库(列出数据库)
MariaDB [(none)]> create database nsd;  #创建库
MariaDB [(none)]> drop database nsd;    #删除库
                                          库名

三. 为数据库管理员设置密码
数据库管理员为root,数据库所有用户信息,由mysql库中user表
系统管理员为root,系统所有用户信息,由/etc/passwd

为数据库账号修改密码
mysqladmin [-u用户名] [-p[旧密码]] password '新密码'
[root@server0 ~]# mysqladmin -u root -p123 password '123456' #有旧密码,修改密码的操作
mysqladmin [-u用户名]  password '新密码'
[root@server0 ~]# mysqladmin -u root password '123'  #没有旧密码,设置密码

用密码登录
[root@server0 ~]# mysql -u root -p
或
[root@server0 ~]# mysql -u root -p123  #123是密码

如果密码忘记了,可以重置,但是属于删根数据库
[root@server0 ~]# yum remove mariadb-server

四. 表格操作: 表记录(行的意思)  表字段(列的意思)
四大操作: 增 insert  删delete  改update  查select

MariaDB [(none)]> use mysql;   #进入mysql库
MariaDB [mysql]> show tables;  #查看当前mysql库中有那些表格
MariaDB [mysql]> desc user;    #查看表格结构

==========================================================================
数据库的导入操作
  导入/恢复到数据库

下载数据库
[root@server0 ~]# wget http://classroom/pub/materials/users.sql
将users.sql库导入nsd1903库,以root的身份导入才可以.
[root@server0 ~]# mysql -u root -p123 nsd1903 < /root/users.sql
                                                  目标库             

==========================================================================
表格的查询
查询nsd1903库里的base表格内容
MariaDB [nsd1903]> select * from base;
                                         库里的base表格
查询nsd1903库里的base表格里name字段内容
MariaDB [nsd1903]> select name from base;
查询nsd1903库里的base表格里id字段和name字段内容
MariaDB [nsd1903]> select id,name from base;

可以在mysql库
MariaDB [mysql]> select * from nsd1903.base;

有条件的查询
在nsd1903库里查询base表里的密码为123的人内容
MariaDB [nsd1903]> select * from base where password='123';
在nsd1903库里查询base表里的名字为james的人内容
MariaDB [nsd1903]> select * from base where name='james';
在nsd1903库里查询base表里的名字为james的人内容查询某个字段内容
MariaDB [nsd1903]> select id,name from b.ase where name='james';

==========================================================================
禁止mariadb服务提供网络监听（只服务于本机）
[root@server0 ~]# vim /etc/my.cnf
[mysqld]
skip-networking

==========================================================================
数据库授权
除了 root 用户,此nsd1903数据库,只能被用户lisi查询.此用户的密码为123.
不需要创建系统用户lisi

[root@server0 ~]# mysql -u root -p123
以root身份给lisi授权nsd1903库
MariaDB [(none)]> grant select on nsd1903.*  to lisi@localhost identified by '123';
查看mysql用户的user,host,password
MariaDB [(none)]> select user,host,password from mysql.user;

==========================================================================
双表联合查询
MariaDB [nsd1903]> select * from base,location where name='Barbara' and location.city='Sunnyvale' and base.id=location.id;
统计
MariaDB [nsd1903]> select count(*) from base,location where name='Barbara' and location.city='Sunnyvale' and base.id=location.id;
追加记录
MariaDB [nsd1903]> insert base values('6','Sunnyvale','789');  #插入表记录
MariaDB [nsd1903]> select * from base;                         #查询表内容

==========================================================================
删除无密码登录
MariaDB [mysql]> select user,host,password from user where password='';
MariaDB [mysql]> delete from user where password='';
MariaDB [mysql]> select user,host,password from user;
MariaDB [mysql]> flush privileges;  #刷新user所有记录
[root@server0 ~]# mysql -u root -h server0.example.com  #登录失败

Engineer_day04========================================================================================

教学环境介绍

– 格式:rht-vmctl 控制指令 虚拟机名

reset(还原)

真机上操作：
　]# rht-vmctl reset classroom　 //先重置资源服务器
　]# rht-vmctl reset server
　]# rht-vmctl reset desktop　　 //再重置练习虚拟机

####################################################
环境准备:
虚拟机server
]# firewall-cmd --set-default-zone=trusted  #允许所有访问

虚拟机desktop
]# firewall-cmd --set-default-zone=trusted  #允许所有访问

####################################################
配置NFS共享

NFS共享概述
• Network File System,网络文件系统
– 用途:为客户机提供共享使用的文件夹
– 协议:NFS(TCP/UDP 2049)、RPC(TCP/UDP 111)

• 所需软件包:nfs-utils
• 系统服务:nfs-server

虚拟机server:
1.安装软件包nfs-utils
[root@serverq0 ~]# rpm -q nfs-utils
nfs-utils-1.3.0-0.el7.x86_64

2.创建共享目录
[root@server0 ~]# mkdir /public
[root@server0 ~]# echo 123 > /public/1.txt
[root@server0 ~]# ls /public/

3.修改配置文件/etc/exports,指定共享的目录
[root@server0 ~]# vim  /etc/exports
[root@server0 ~]# man  exports
– 共享的文件夹路径    客户机地址(权限)    客户机地址(权限) .. ..

  /public     *(ro)

[root@server0 ~]# systemctl restart nfs-server
[root@server0 ~]# systemctl enable nfs-server

#################################################
客户端虚拟机desktop 
1.查看服务端共享路径
[root@desktop0 ~]# showmount -e 172.25.0.11
Export list for 172.25.0.11:
/public  *
[root@desktop0 ~]# 

2.挂载访问
[root@desktop0 ~]# mkdir /mnt/nfs
[root@desktop0 ~]# mount 172.25.0.11:/public  /mnt/nfs/
[root@desktop0 ~]# df -h
[root@desktop0 ~]# ls /mnt/nfs

3.开机自动挂载
  _netdev:声明为网络设备
              开机启动Linux系统时,首先具备网络参数后,再进行挂载本设备

[root@desktop0 ~]# vim /etc/fstab
  设备路径    挂载点    类型     参数    备份标记   检测顺序
172.25.0.11:/public  /mnt/nfs  nfs  defaults,_netdev 0 0

[root@desktop0 ~]# umount /mnt/nfs/
[root@desktop0 ~]# df -h
[root@desktop0 ~]# mount -a
[root@desktop0 ~]# df -h
#####################################################

虚拟机server:
   1.利用NFS服务发布/nsd共享目录
[root@server0 ~]# mkdir /nsd
[root@server0 ~]# echo 123 > /nsd/a.txt
[root@server0 ~]# ls /nsd/
   2.允许所有客户端进行只读访问
[root@server0 ~]# cat /etc/exports
/public   *(ro)
/nsd   *(ro)

虚拟机desktop:
   1.完成开机自动挂载到本机/mnt/test目录
 172.25.0.11:/nsd  /mnt/test nfs defaults,_netdev 0 0

[root@desktop0 ~]# df  -ah  #显示当前系统,所有正在挂载信息
####################################################
HTTP服务基础

一 构建基本Web主机
Web通信基本概念
• 基于 B/S(Browser/Server)架构的网页服务
– 服务端提供网页
– 浏览器下载并显示网页
• Hyper Text Markup Language(html),超文本标记语言
• Hyper Text Transfer Protocol(http),超文本传输协议 默认端口 80

虚拟机server:
]# yum -y install httpd
]# systemctl restart httpd
]# echo '<h1>NSD1903' > /var/www/html/index.html

虚拟机desktop
]# firefox 172.25.0.11

####################################################
web服务器的软件
   httpd(Apache软件基金会)

• 提供的默认配置
– Listen:监听地址:端口(80)
– ServerName:本站点注册的DNS名称(空缺)
– DocumentRoot:网页根目录(/var/www/html)

  DNS服务器:虚拟机classroom提供域名解析
            server0.example.com
            www0.example.com
            webapp0.example.com
测试解析结果:
[root@server0 ~]# nslookup server0.example.com
[root@server0 ~]# nslookup www0.example.com
[root@server0 ~]# nslookup webapp0.example.com

##################################################
DocumentRoot:网页文件根目录(/var/www/html)   

虚拟机server
]# mkdir /var/www/myweb
]# echo '<h1>wo shi myweb' > /var/www/myweb/index.html
]# ls /var/www/myweb/
]# vim /etc/httpd/conf/httpd.conf 

 DocumentRoot "/var/www/myweb"

]# systemctl restart httpd

虚拟机desktop
]# firefox 172.25.0.11   #测试访问结果
#####################################################
网络路径与实际路径

客户端访问:
 firefox 172.25.0.11:80-->服务端  httpd-->DocumentRoot /var/www/myweb-->index.html


客户端 : firefox 172.25.0.11/abc
服务端实际路径: : /var/www/myweb/abc/index.html

客户端 : firefox 172.25.0.11/var/www/myweb/abc
服务端实际路径: /var/www/myweb/var/www/myweb/abc

虚拟机server
]# mkdir /var/www/myweb/abc
]# echo '<h1>wo shi abc' > /var/www/myweb/abc/index.html

虚拟机desktop
]# firefox 172.25.0.11      #测试访问结果
]# firefox 172.25.0.11/abc  #测试访问结果

##################################################
 客户端访问Web: 直接输入IP地址 = 服务端 DocumentRoot

###################################################
配置文件调用
• 配置文件路径
– /etc/httpd/conf/httpd.conf  #主配置文件
– /etc/httpd/conf.d/*.conf    #调用配置文件

###################################################
虚拟Web主机

虚拟主机的含义及类型
• 虚拟Web主机
– 由同一台服务器提供多个不同的Web站点

• 区分方式
 – 基于域名的虚拟主机
 – 基于端口的虚拟主机
 – 基于IP地址的虚拟主机
 
            server0.example.com
            www0.example.com
            webapp0.example.com

<VirtualHost  IP地址:端口>
  ServerName  此站点的DNS名称
  DocumentRoot  此站点的网页根目录
</VirtualHost>

]# vim /etc/httpd/conf.d/nsd01.conf
 <VirtualHost  *:80> #本机所有IP地址的80端口启用虚拟Web主机
   ServerName  server0.example.com  #设置网站访问的域名
   DocumentRoot  /var/www/qq        #设置网页文件根目录
 </VirtualHost>

 <VirtualHost  *:80>
   ServerName  www0.example.com
   DocumentRoot  /var/www/baidu
 </VirtualHost>
]# mkdir /var/www/qq  /var/www/baidu        
]# echo '<h1>QQ' > /var/www/qq/index.html
]# echo '<h1>百度' > /var/www/baidu/index.html

]# systemctl  restart  httpd

###############################################
 DocumentRoot 路径尽量放在/var/www , SELinux策略

###############################################
虚拟Web主机优先级,由上到下优先级递减
一旦使用了虚拟Web主机,所有的页面都必须使用虚拟Web主机来呈现

<VirtualHost  *:80>
  ServerName www0.example.com
  DocumentRoot  /var/www/baidu
</VirtualHost>
<VirtualHost  *:80>
  ServerName server0.example.com
  DocumentRoot  /var/www/qq
</VirtualHost>
<VirtualHost  *:80>
  ServerName  webapp0.example.com
  DocumentRoot  /var/www/myweb
</VirtualHost>
####################################################
补充: Samba共享服务 (Windows平台与Linux平台   跨平台的共享)

      协议:smb(沟通验证身份)   cifs(存储或传输数据)

默认情况下必须通用户验证,才可以访问
专门用于Samba共享服务,验证的用户:Samba共享帐号
1.必须要有相应的本地用户对应           
2.采用独立的密码设置             
                                     

虚拟机server:     
1.安装软件包samba
[root@server0 ~]# yum -y install samba

2.创建Samba共享帐号
]# useradd -s /sbin/nologin harry
]# pdbedit -a harry      #将用户添加为Samba共享帐号
new password:
retype new password:

   pdbedit -x 用户名     #删除Samba共享帐号
   pdbedit -L  #查看当前系统,所有的Samba共享帐号

3.修改配置文件
[root@server0 ~]# vim /etc/samba/smb.conf 
在命令模式下,输入G(大写)到全文的最后一行

[nsd]                #设置共享名
path = /common       #设置实际共享的目录

[root@server0 ~]# mkdir /common
[root@server0 ~]# echo 123 > /common/123.txt
[root@server0 ~]# ls /common/

4.重启smb服务
[root@server0 ~]# systemctl restart smb

5.修改SELinux策略,布尔值策略(功能的开关)
 samba_export_all_ro : Samba服务只读共享功能

]# getenforce   #查看SELinux状态
]# getsebool -a | grep samba   #查看SELinux所有布尔值

]# setsebool samba_export_all_ro  on  #修改SELinux布尔值

]# getsebool -a | grep samba
]# getenforce 


虚拟机desktop:
1.安装软件包,支持Samba共享的挂载,让本机识别cifs协议
]# yum -y install cifs-utils
]# rpm -q  cifs-utils

2.挂载访问Samba共享
]# mkdir /mnt/smb
]# mount -o user=harry,pass=123  //172.25.0.11/nsd   /mnt/smb/

格式:
mount -o user=用户名,pass=密码  //服务端IP地址/共享名   挂载点

]# df -h

3.开机自动挂载,书写/etc/fstab      

//172.25.0.11/nsd /mnt/smb  cifs defaults,_netdev,user=harry,pass=123 0 0

[root@desktop0 ~]# umount /mnt/smb/
[root@desktop0 ~]# mount -a
[root@desktop0 ~]# df -h

##############################################

===================================================
NFS共享配置

所需软件包: nfs-utils
系统服务: nfs-server

首先修改SELinux策略
[root@server0 ~]# firewall-cmd --set-default-zone=trusted
[root@desktop0 ~]# firewall-cmd --set-default-zone=trusted

一. 服务端虚拟机server
1.安装软件包nfs-utils
[root@server0 ~]# yum -y install nfs-utils
[root@server0 ~]# rpm -q nfs-utils

2. 创建共享目录
[root@server0 ~]# mkdir /public
[root@server0 ~]# echo zhaiyanquan > /public/1.txt
[root@server0 ~]# ls /public
重启服务public
[root@server0 ~]# systemctl restart nfs-server
[root@server0 ~]# systemctl enable nfs-server

3. 修改配置文件/etc/exports,指定共享的目录
共享的文件夹路径     客户机地址(权限)         客户机地址(权限)
例:
[root@server0 ~]# vim /etc/exports
/public              *(ro)
共享目录         *表示所有客户机可以访问,ro表示以读取方式挂载
重启服务
[root@server0 ~]# systemctl restart nfs-server
[root@server0 ~]# systemctl enable nfs-server

[root@server0 ~]# man exports  #可以man帮助查看例子

二. 客户端虚拟机desktop
1. 查看服务端共享路径
[root@desktop0 ~]# showmount -e 172.25.0.11

2. 挂载访问
[root@desktop0 ~]# mkdir /mnt/nfs
[root@desktop0 ~]# mount 172.25.0.11:/public /mnt/nfs
[root@desktop0 ~]# df -Th  #查看挂载使用信息

3. 开机自动挂载
[root@desktop0 ~]# vim /etc/fstab
172.25.0.11:/public /mnt/nfs    nfs      defaults,_netdev          0 0 
                                      文件系统      _netdev:声明为网路设配
[root@desktop0 ~]# umount /mnt/nfs  #删除原来的挂载 
[root@desktop0 ~]# mount -a         #挂载
[root@desktop0 ~]# df -Th           #查看挂载信息

===============================================================
HTTP服务基础

基于B/S架构的网页服务
服务端提供网页
浏览器下载并侠显示网页
http: 超文本传输协议

Web网站服务端：软件包httpd、系统服务httpd
Web网站浏览器：软件包elinks或fireox
传输协议及端口：TCP 80
Web网站服务端配置文件：
    /etc/httpd/conf/httpd.conf
    /etc/httpd/conf.d/*.conf

虚拟机server(服务端)
[root@server0 ~]# yum -y install httpd
[root@server0 ~]# systemctl restart httpd
[root@server0 ~]# systemctl enable httpd
[root@server0 ~]# echo '<h1>ZHAIYANQUAN' /var/www/html/index.html
[root@server0 ~]# firefox 172.25.0.11

===============================================================
Web服务器的软件
Web服务器: 面试重点

http  nginx  tomcat

提供的默认配置
Listen: 监听地址: 端口80
ServerName: 本站点注册的DNS名称
DocumentRoot: 网页根目录(/var/www/html(相当于根目录起始点))

DNS服务器: 虚拟机classroom提供域名解析
           erver0.example.com
           www0.example.com
           webapp0.example.com
解析域名
[root@server0 ~]# nslookup server0.example.com

虚拟机server
[root@server0 ~]# yum -y install  httpd  #安装软件
[root@server0 ~]# mkdir /var/www/myweb/  #创建放入网页的路径
[root@server0 ~]# echo '<h1>zhaiyanquan' >  /var/www/myweb/index.html  #创建一个网页
[root@server0 ~]# vim /etc/httpd/conf/httpd.conf                       #修改放入网页的路径
#DocumentRoot "/var/www/html"
DocumentRoot "/var/www/myweb"
重启服务
[root@server0 ~]# systemctl restart httpd
[root@server0 ~]# systemctl enable httpd
[root@desktop0 ~]# firefox 172.25.0.11


===============================================================
网路路径与实际路径

客户端访问:
  firefox 172.25.0.11:80--> DocumentRoot

客户端: fiefox 172.25.0.11/abc
服务端实际路径: /var/www/myweb/abc/index.html

客户端: fiefox 172.25.0.11/var/www/myweb/abc/
服务端实际路径: /var/www/myweb/var/www/myweb/abc/
[root@server0 ~]# yum -y install elinks

虚拟机server(无需重启服务)
[root@server0 ~]# mkdir /var/www/myweb/abc  #创建路径
[root@server0 ~]# echo '545452345' > /var/www/myweb/abc/index.html
虚拟机desktop
[root@desktop0 ~]# firefox 172.25.0.11      #测试访问结果
[root@desktop0 ~]# firefox 172.25.0.11/abc  #测试访问新建路径的结果

===============================================================
配置文件调用

配置文件路径
  /etc/httpd/conf/httpd.conf  #主配置文件
  /etc/httpd/conf.d/*.conf    #调用配置文件 

虚拟机Web主机
一. 由同一台服务器提供多个同的Web站点

区分方式
  基于域名的虚拟主机
  基于端口的虚拟主机
  基于域IP地产的虚拟主机
 
配置文件路径
   /etc/httpd/conf/httpd.conf  #主配置文件
   /etc/httpd/conf.d/*.conf    #调用配置文件 

[root@server0 ~]# vim /etc/httpd/conf.d/*.conf
<VirtualHost IP地址:端口>
  ServerName   此站点的域名[root@server0 ~]# yum -y install elinks

  DocumentRoot 此站点网页路径
</VirtualHost>

为每个虚拟站点添加配置
[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost *:80> #*表示匹配所有IP地址
  ServerName server0.example.com
  DocumentRoot /var/www/baidu
</VirtualHost>

<VirtualHost *:80> 
  ServerName www0.example.com
  DocumentRoot /var/www/qq
</VirtualHost>

[root@server0 virtual]# httpd  -t    #确保语法检查OK

新建网页路径
[root@server0 ~]# mkdir /var/www/baidu /var/www/qq
编写网页
[root@server0 ~]# echo '<h1>百度' > /var/www/baidu/index.html
[root@server0 ~]# echo '<h1>企鹅' > /var/www/qq/index.html
重启服务
[root@server0 ~]# systemctl restart httpd
[root@server0 ~]# systemctl enable httpd
访问网页
[root@server0 ~]# firefox server0.example.com
[root@server0 ~]# firefox www0.example.com
访问网站服务器
[root@server0 ~]# yum -y install elinks   //安装elinks
[root@desktop0 ~]# elinks  -dump  http://server0.example.com/     //访问指定网址

DocumentRoot  路径尽量放在/var/www/ ,SELlinux策略

虚拟机Web主机

===============================================================
Samba共享服务
补充: Samba共享服务(Windows 平台与Linux平台 跨平台的共享)

协议: smb(沟通验证身份)    cifs(存储或传输数据)

默认情况下必须通过用户验证,才可以访问
专门用于Samba共享服务,验证的用户,Samba共享账号
1. 必须要有相应本地用户对应
2. 采用独立的密码设置
 
虚拟机server(服务端):
1.安装软件包samba
[root@server0 ~]# yum -y install samba

2. 创建Samba共享账号
添加一个Samba共享账号,-s /sbin/nologin/是用户没有登录功能
[root@server0 ~]# useradd -s /sbin/nologin/ harry

pdbedit -x   #用户名 #删除Samba共享账号
pdbedit -L   #查看当前Samba共享账号
pdbedit -a   #添加为Samba共享账号

将用户添加为Samba共享账号
[root@server0 ~]# pdbedit -a harry

3.修改配置文件
[root@server0 ~]# vim /etc/samba/smb.conf
#在命令行模式下,输入G(大写)到全文的最后一行 ,输入gg(小写)到全文首行

[nsd]             #设置共享名
path = /common    #设置实际共享的目录
[root@server0 ~]# mkdir /common  

4. 重启smb服务
[root@server0 ~]# systemctl restart smb

5. 修改SELinux策略,布尔值策略(功能的开关)
[root@server0 ~]# getsebool -a | grep samba
[root@server0 ~]# setsebool samba_export_all_rw  on
[root@server0 ~]# setsebool samba_export_all_ro on

虚拟机desktop(客户端)
1.安装软件包cifs-utils,支持Samba共享的挂载,让本机
[root@desktop0 ~]# yum -y install cifs-utils
[root@desktop0 ~]# rpm -q cifs-utils
[root@desktop0 ~]# mkdir /mnt/smb

2. 挂载访问Samba共享
[root@desktop0 ~]# mount -o user=harry,pass='123' //172.25.0.11/nsd /mnt/smb #nsd是共享名
[root@desktop0 ~]# mount -a         #挂载
[root@desktop0 ~]# df -Th           #查看当前挂载使用信息
[root@desktop0 ~]# mkdir /mnt/nfs   #新建挂载点路径

3. 开机自动挂载
[root@desktop0 ~]# vim /etc/fstab
//172.25.0.11/nsd /mnt/smb cifs defaults,_netdev,user=harry,pass=123 0 0 
[root@desktop0 ~]# mount -a  #挂载
[root@desktop0 ~]# df -Th    #查看当前挂载使用信息


Engineer_day05========================================================================================

教学环境介绍  
– 格式:rht-vmctl   控制指令    虚拟机名

真机上操作：
　]# rht-vmctl reset classroom　 //先重置资源服务器
　]# rht-vmctl reset server
　]# rht-vmctl reset desktop　　 //再重置练习虚拟机
####################################################
环境准备:
虚拟机server
]# firewall-cmd --set-default-zone=trusted  #允许所有访问

虚拟机desktop
]# firewall-cmd --set-default-zone=trusted  #允许所有访问

####################################################
<VirtualHost  *:80>
  ServerName   www0.example.com
  DocumentRoot  /var/www/web01
</VirtualHost>
<VirtualHost  *:80>
  ServerName   server0.example.com
  DocumentRoot  /var/www/web02
</VirtualHost>
<VirtualHost  *:80>
  ServerName   webapp0.example.com
  DocumentRoot  /var/www/web03
</VirtualHost>
####################################################
- 实现客户端访问www0.example.com网页内容为  大圣又归来
- 实现客户端访问server0.example.com网页内容为 大圣归来
- 实现客户端访问webapp0.example.com网页内容为 大圣累了

####################################################
网页内容访问

客户机地址限制
• 使用 <Directory> 配置区段
– 每个文件夹自动继承其父目录的ACL访问权限
– 除非针对子目录有明确设置

	<Directory  目录的绝对路径>
	  .. ..
	 Require all denied|granted
	 Require ip IP或网段地址 .. ..
	</Directory>

	<Directory  /var/www/web01>
	 Require all denied   #拒绝所有人访问
	</Directory>

	<Directory  /var/www/web02>
	 Require all granted   #允许所有人访问
	</Directory>

	<Directory  /var/www/web03>
	 Require ip 172.25.0.11   #仅允许172.25.0.11访问
	</Directory>

##############################################
	<Directory  /var/www/web01>
	 Require all denied   #拒绝所有人访问
	</Directory>
	<Directory  /var/www/web01/abc>
	 Require all granted   #允许所有人访问
	</Directory>

   /var/www/web01/abc/index.html   #允许

   /var/www/web01/nsd/index.html   #拒绝

############################################
案例1:配置网页内容访问
在 Web 网站 http://server0.example.com 的          
DocumentRoot 目录下创建一个名为 private 的子目录
要求如下:
1.虚拟机server,查看DocumentRoot 目录路径
]# cat /etc/httpd/conf.d/nsd01.conf 

]# mkdir /var/www/web02/private

]# echo '<h1>wo shi private' > /var/www/web02/private/index.html

2.虚拟机desktop访问测试
]# firefox  server0.example.com/private

3.从虚拟机server0上,任何人都可以浏览 private的内容,
但是从其他系统不能访问这个目录的内容
[root@server0 ~]# cat /etc/httpd/conf.d/nsd02.conf
  <Directory  /var/www/web02/private>
	Require  ip  172.25.0.11   #仅允许172.25.0.11访问
  </Directory>

[root@server0 ~]# systemctl restart httpd

在虚拟机desktop测试: firefox server0.example.com/private
Forbidden

You don't have permission to access /private/ on this server.

####################################################
案例2:使用自定Web根目录
调整 Web 站点 http://server0.example.com 的网页目录,要求如下:
1)新建目录 /webroot,作为此站点新的网页目录
]# mkdir /webroot
]# echo '<h1>wo shi webroot' > /webroot/index.html
]# vim /etc/httpd/conf.d/nsd01.conf 
 ......
<VirtualHost *:80>
  ServerName server0.example.com
  DocumentRoot /webroot
</Virtualhost>
 ......
]# vim /etc/httpd/conf.d/nsd02.conf 
.......
<Directory /webroot>
    Require all granted    #允许所有人进行访问
</Directory>
[root@server0 ~]# systemctl restart httpd

2)修改SELinux策略,安全上下文(标签)    

[root@server0 ~]# ls -Zd /var/www/  #查看目录SELinux标签值
[root@server0 ~]# ls -Zd /webroot/

• 方式1:参照标准目录,重设新目录的属性
– chcon [-R] --reference=模板目录 新目录

[root@server0 ~]# chcon -R --reference=/var/www /webroot
[root@server0 ~]# ls -Zd /webroot

[root@server0 ~]# firefox server0.example.com

#####################################################
部署动态网站

 静态网站:
  • 服务端的原始网页 = 浏览器访问到的网页
    – 由Web服务软件处理所有请求
    – 文本(txt/html)、图片(jpg/png)等静态资源

 动态网站:
  • 服务端的原始网页 ≠ 浏览器访问到的网页
    – 由Web服务软件接受请求,动态程序转后端模块处理
  – PHP网页、Python网页、JSP网页......


部署Python动态页面,为站点 webapp0.example.com
虚拟机Server:
1.下载Python页面文件
[root@server0 ~]# cat /etc/httpd/conf.d/nsd01.conf 

[root@server0 ~]# cd /var/www/web03/
[root@server0 web03]# wget http://classroom.example.com/pub/materials/webinfo.wsgi

[root@server0 web03]# ls 

2.实现客户端方便访问,设置页面跳转(页面别名  地址重写)

  webapp0.example.com ---> webinfo.wsgi

  Alias  网络路径    实际路径
   网络路径为  /  : 用户直接输入域名
    当客户端访问  网络路径 ,将  实际路径 页面文件呈现

[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf 

<VirtualHost *:80>
  ServerName webapp0.example.com
  DocumentRoot /var/www/web03
  Alias   /    /var/www/web03/webinfo.wsgi
   当用户直接访问网页文件根目录时,将webinfo.wsgi页面呈现
</Virtualhost>
[root@server0 ~]# systemctl restart httpd

3.虚拟机Server,安装mod_wsgi软件进行Pyhton页面代码的翻译
[root@server0 ~]# yum -y install mod_wsgi

4.修改配置文件,添加翻译配置
[root@server0 ~]# vim  /etc/httpd/conf.d/nsd01.conf 
<VirtualHost *:80>
  ServerName  webapp0.example.com
  DocumentRoot /var/www/web03
  WsgiScriptAlias   /    /var/www/web03/webinfo.wsgi 
</Virtualhost>

[root@server0 ~]# systemctl restart httpd

访问测试:firefox webapp0.example.com
页面内容显示 UNIX时间戳:
            从1970-1-1 0:0:0到现在时间所有经历的秒数

5.此虚拟主机侦听在端口8909
[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf 
Listen 8909           #httpd监听8909端口
<VirtualHost *:8909>  #设置虚拟web主机的端口     15:15上课
  ServerName webapp0.example.com
  DocumentRoot /var/www/web03
  WsgiScriptAlias   /    /var/www/web03/webinfo.wsgi  
</Virtualhost>

6.修改SELinux策略,非默认端口开放的策略
]# semanage port -l | grep http
]# semanage port -a -t http_port_t -p tcp 8909
      -a:添加    -t:类型    -p:协议
]# semanage port -l | grep http

]# systemctl restart httpd
]# firefox webapp0.example.com:8909
##################################################
端口优先级最高,然后虚拟Web主机由上到下进行匹配

#################################################
安全Web服务

PKI公钥基础设施
• Public Key Infrastructure,公钥基础设施
– 公钥:主要用来加密数据
– 私钥:主要用来解密数据(与相应的公钥匹配)
– 数字证书:证明拥有者的合法性/权威性(单位名称、
有效期、公钥、颁发机构及签名、......)
– Certificate Authority,数字证书授权中心:负责证书
的申请/审核/颁发/鉴定/撤销等管理工作

虚拟机server部署安全的Web服务器       
1.部署网站证书(营业执照)
]# cd /etc/pki/tls/certs/
]# wget http://classroom.example.com/pub/tls/certs/server0.crt

]# ls

2.部署根证书(工商局的信息)
]# cd /etc/pki/tls/certs/
]# wget http://classroom.example.com/pub/example-ca.crt

]# ls

3.部署用于解密数据的秘钥
]# cd /etc/pki/tls/private/
]# wget http://classroom.example.com/pub/tls/private/server0.key

]# ls 

4.安装mod_ssl软件,实现加密Web传输
[root@server0 /]# yum -y install mod_ssl
[root@server0 /]# ls /etc/httpd/conf.d/

5.修改配置文件/etc/httpd/conf.d/ssl.conf
[root@server0 /]# vim /etc/httpd/conf.d/ssl.conf
 vim末行模式   :set  nu   开启行号功能

 59 DocumentRoot "/var/www/web01"
 60 ServerName www0.example.com:443
#指定网站证书
100 SSLCertificateFile /etc/pki/tls/certs/server0.crt

#指定秘钥
107 SSLCertificateKeyFile /etc/pki/tls/private/server0.key

#指定根证书
122 SSLCACertificateFile /etc/pki/tls/certs/example-ca.crt
[root@server0 /]# systemctl restart httpd
最后测试:
[root@server0 /]# firefox https://www0.example.com

===================================================
网页内容访问控制

[root@desktop0 ~]# firewall-cmd --set-default-zone=trusted
[root@server0 ~]# firewall-cmd --set-default-zone=trusted

配置Web内容的访问控制需要添加Directory区段，主要形式可参考
<Directory  "父目录路径">
     Require  all  denied             #上层目录拒绝任何访问
</Directory>

<Directory  "子目录1路径">
     Require  all  granted            #子目录1允许任何访问
</Directory>

<Directory  "子目录2路径">
     Require  ip  IP或网段地址 .. ..      #子目录2允许少数客户机
</Directory>

从虚拟机server0上,任何人都可以浏览private内容,但是从其他系统不能访问这个目录的内容
[root@server0 ~]# vim /etc/httpd/conf.d/nsd02.conf
<Directory /var/www/web02/private>
    Require ip 172.25.0.11    #仅允许172.25.0.11访问
</Directory>
重启服务
[root@server0 ~]# systemctl restart httpd
[root@server0 ~]# systemctl enbale httpd

在虚拟机desktop测试
[root@desktop0 ~]# firefox server0.example.com/private

=====================================================================
使用自定web根目录

[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost *:80>
ServerName server0.example.com
DocumentRoot /webroot
</VirtualHost>

[root@server0 ~]# mkdir /webroot  #创建网页路径
添加一个网页
[root@server0 ~]# echo '<h1>trtertert' > /webroot/index.html

修改配置文件
[root@server0 ~]# vim /etc/httpd/conf.d/nsd02.conf
<Directory /webroot>
    Require all granted #子目录1允许任何访问
</Directory>

重启服务
[root@server0 ~]# systemctl restart httpd
[root@server0 ~]# systemctl enable httpd

修改SELinux策略,安全上下文(策略)

查看标签的之
[root@server0 ~]# ls -Zd /var/www
[root@server0 ~]# ls -Zd /webroot

方式1.参照标准目录,重设新目录的属性 ([root@desktop0 ~]# chcon --help)
chcon -R --reference=模板目录 新目录
例:
[root@server0 ~]# chcon -R --reference=/var/www /webroot

查看目录标签值
[root@server0 ~]# ls -Zd /webroot

访问
[root@server0 ~]# firefox server0.example.com
[root@desktop0 ~]# firefox server0.example.com

=====================================================================
部署动态网站

静态网站: 
服务端的原始网页=浏览器访问到的网页
  由Web服务软件处理所有请求

动态网站:
服务端的原始网页不等于浏览器访问到的网页
有Web服务软件接受请求,动态程序转后端模块处理

[root@server0 ~]# /var/www/web03 #新建网页路径

1. 将网页下载到/var/www/web03目录下
[root@server0 web03]# cd /var/www/web03
[root@server0 web03]# wget http://classroom/pub/materials/webinfo.wsgi

2. 实现客户端方便访问,设置页面跳转(页面别名 地址重写)
    
Alias 客户端网路路径  实际路径
当客户端访问  网络路径 实际路径
网络路径为 / :用户直接输入域名
当客户端访问  网络路径,将 实际路径页面文件呈现

修改配置文件
[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost *:80>
ServerName webapp0.example.com
DocumentRoot /var/www/web03
Alias /  /var/www/web03/webinfo.wsgi  
</VirtualHost>

重启服务
[root@server0 ~]# systemctl restart  httpd
[root@server0 ~]# systemctl enable  httpd

访问
[root@server0 ~]# firefox webapp0.example.com
[root@desktop0 ~]# firefox webapp0.example.com

3. 虚拟机server,安装mod_wsgi软件进行Python页面代码的翻译
[root@server0 ~]# yum -y install mod_wsgi

4. 修改配置文件,添加翻译配置
[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf
<VirtualHost *:80>  
ServerName webapp0.example.com
DocumentRoot /var/www/web03
WsgiScriptAlias /  /var/www/web03/webinfo.wsgi  #WsgiScriptAlias是翻译配置
</VirtualHost>

重启服务
[root@server0 ~]# systemctl restart  httpd
[root@server0 ~]# systemctl enable  httpd

访问
[root@server0 ~]# firefox webapp0.example.com
[root@desktop0 ~]# firefox webapp0.example.com

5. 此虚拟机server主听在端口8909
[root@server0 ~]# vim /etc/httpd/conf.d/nsd01.conf   #修改配置文件
Listen 8909
<VirtualHost *:8909>
ServerName webapp0.example.com
DocumentRoot /var/www/web03
WsgiScriptAlias /  /var/www/web03/webinfo.wsgi
#Alias /  /var/www/web03/zhai.html
</VirtualHost>

6. 修改SELinux策略,非默认端口开放的策略
[root@server0 ~]# semanage port -l | grep http
[root@server0 ~]# semanage port -a -t http_port_t -p tcp 8909

重启服务
[root@server0 ~]# systemctl restart httpd
[root@server0 ~]# systemctl enable httpd

访问
[root@desktop0 ~]# firefox server0.example.com:8909
[root@server0 ~]# firefox server0.example.com:8909

=====================================================================
安全Web服务

公钥: 主要用来加密数据
私钥: 主要用来解密数据(与相应的公钥匹配) 
数字证书: 证明拥有者的合法性/权威性

部署安全Web服务器

1. 部署网站证书(营业执照)
[root@server0 ~]# cd /etc/pki/tls/certs
[root@server0 certs]# wget http://classroom/pub/tls/certs/server0.crt #下载证书(已签名证书)
[root@server0 certs]# ls
server0.crt

3. 部署根证书(工商局的信息)
[root@server0 ~]# cd /etc/pki/tls/private/
[root@server0 private]# wget http://classroom/pub/tls/private/server0.key  #下载证书的密钥

4. 部署用于证书的签名授权信息
[root@server0 ~]# cd /etc/pki/tls/certs
[root@server0 certs]# wget http://classroom/pub/example-ca.crt

5.安装mod_ssl软件,实现加密Web传输
[root@server0 ~]# yum -y install mod_ssl

6.修改配置文件/etc/httpd/conf.d/ssl.conf
[root@server0 ~]# vim /etc/httpd/conf.d/ssl.conf  #vim末行模式 :set nu  开启号功能
59 DocumentRoot "/var/www/web01"
60 ServerName www0.example.com:443
100 SSLCertificateFile /etc/pki/tls/certs/server0.crt
107 SSLCertificateKeyFile /etc/pki/tls/private/server0.key
122 SSLCACertificateFile /etc/pki/tls/certs/example-ca.crt

重启服务
[root@server0 ~]# systemctl restart httpd
[root@server0 ~]# systemctl enable httpd

访问测试
[root@server0 ~]# firefox https://www0.example.com

Engineer_day06========================================================================================

教学环境介绍  
– 格式:rht-vmctl   控制指令    虚拟机名

真机上操作：
　]# rht-vmctl reset classroom　 //先重置资源服务器
　]# rht-vmctl reset server
　]# rht-vmctl reset desktop　　 //再重置练习虚拟机
####################################################
环境准备:
虚拟机server
]# firewall-cmd --set-default-zone=trusted  #允许所有访问

虚拟机desktop
]# firewall-cmd --set-default-zone=trusted  #允许所有访问

###################################################
基础邮件服务          

电子邮件通信
• 电子邮件服务器的基本功能
– 为用户提供电子邮箱存储空间(用户名@邮件域名)
– 处理用户发出的邮件 —— 传递给收件服务器
– 处理用户收到的邮件 —— 投递到邮箱


快速部署postfix邮件服务器
• 装包、配置、起服务
– 默认的标准配置即可为本机提供发/收邮件服务
– 若有必要,可扩大服务范围(邮件域)

DNS服务器:虚拟机classroom
         
         yg@server0.example.com
         xln@server0.example.com

虚拟机server:
1.安装软件postfix,提供邮件功能的软件
[root@server0 ~]# rpm -q postfixpostfix-2.10.1-6.el7.x86_64
[root@server0 ~]# 
                                                      
2. 修改配置文件/etc/postfix/main.cf
vim末行模式  :set  nu

99 myorigin = server0.example.com  #默认补全邮箱帐号后缀
116 inet_interfaces = all     #本机所有网卡都提供邮件服务
164 mydestination =  server0.example.com 
                                                              #判断为本域邮件依据

       收件人:xln@server0.example.com

3.重启postfix邮件服务
[root@server0 ~]# systemctl restart postfix
使用mail命令发信/收信
– mail -s  '邮件标题'    -r  发件人    收件人[@收件域]...

• mail 收信操作
– mail [-u 用户名]

[root@server0 ~]# useradd yg
[root@server0 ~]# useradd xln

[root@server0 ~]# mail -s 'test01' -r yg  xln
haha xixi hehe lele 
.                          #当只有一个点时,提交并发送邮件
EOT
[root@server0 ~]# echo dc | mail -s 'test02' -r yg  xln

[root@server0 ~]# mail -u xln
Heirloom Mail version 12.5 7/5/10.  Type ? for help.
"/var/mail/xln": 2 messages 2 new
>N  1 yg@server0.example.c  Thu Apr 18 10:31  18/588   

> 1     #输入邮件的编号1,查看邮件内容teambridge
####################################################
准备交换分区

交换空间(虚拟内存):缓解内存不足

mkswap  swapon  swapoff  swapon -s     swapon -a


parted分区工具(划分GPT分区模式)

   GPT分区模式: 128个主分区,最大空间18EB


[root@server0 ~]# parted /dev/vdb 
(parted) mktable  gpt      #初始化磁盘,不能重复执行
(parted) mkpart            #划分新的分区
分区名字?                                 #随便写
文件系统类型？[ext2]?  xfs    #随便写不起实际作用
起始点？ 0                       
结束点？ 2G   
 忽略/Ignore/放弃/Cancel? Ignore 
(parted) print 
(parted) unit GB     #显示单位
                                                  (parted) print 
(parted) quit
(parted) rm          #删除分区        
[root@server0 ~]# lsblk 
###################################################
配置IPv6地址

• IPv4 地址表示
– 32个二进制位,点 分隔的十进制数

• IPv6 地址表示
– 128个二进制位, 利用冒号分隔 8 部分,最终每一部分由16进制数标识
– 每段内连续的前置 0 可省略、连续的多个 : 可简化为 ::
– 例如: 2003:ac18:0000:0000:0000:0000:0000:0305
      2003:ac18::305


为虚拟机server:配置IPv6地址2003:ac18::305/64

1.利用nmcli命令查看网卡名称
[root@server0 ~]# nmcli connection show
名称         
System eth0

2.修改地址                                                            
]# nmcli connection modify 'System eth0' 
   ipv6.method manual ipv6.addresses 2003:ac18::305/64  
   connection.autoconnect yes

]# nmcli connection 修改  '识别的网卡名称' 
   ipv6.方法 手工配置 ipv6.地址 2003:ac18::305/64  
     每次开机自动启用

3.激活配置
[root@server0 ~]# nmcli connection up 'S(tab)'
[root@server0 ~]# ifconfig | less
  inet6 2003:ac18::305  prefixlen 64 

[root@server0 ~]# ping6 2003:ac18::305
##################################################

配置聚合连接(链路聚合)

• team,聚合连接(也称为链路聚合)
– 由多块网卡(team-slave)一起组建而成的虚拟网卡,即"组队"

– 作用1:热备份(activebackup)连接冗余


                eth1        eth2
                   
                               虚拟网卡 team0  192.168.1.1

虚拟机配置链路聚合:
1.创建虚拟网卡team0 ,参考 man teamd.conf 全文搜索/example

]# nmcli connection add type team      
 con-name team0 ifname  team0 autoconnect yes           
 config   '{"runner": {"name": "activebackup"}}'

]# nmcli connection 添加  类型  team(组队)
      配置文件名  team0  网卡命名为 team0  每次开机自动启用
      配置  链路聚合以activebackup(热备)工作的方式

]# ifconfig     #查看team0网卡的生成
 
如果有敲错,请删除从新创建team0
]# nmcli connection delete team0  

2.添加成员
]# nmcli connection add type team-slave 
 con-name team0-1 ifname eth1 master team0 

]# nmcli connection add type team-slave 
 con-name team0-2 ifname eth2 master team0

]# nmcli connection 添加   类型   组队-成员 
 配置文件名 team0-1  网卡设备名   eth1   主设备为 team0 

]# ls /etc/sysconfig/network-scripts/  #查看生成的配置文件

如果有敲错,请删除从新创建team0
]# nmcli connection delete team0-1  (生成配置文件名)
]# nmcli connection delete team0-2  (生成配置文件名)


3.配置IP地址,再激活
]# nmcli connection modify team0      
   ipv4.method manual ipv4.addresses 192.168.1.1/24 
   connection.autoconnect yes

]# nmcli connection up team0    #激活team0

]# ifconfig team0 | head -2    #查看team0的IP地址信息

]# teamdctl team0 state      #查看team0信息

]# ifconfig eth2 down        #将eth2网卡禁用
]# teamdctl team0 state      #查看team0信息

]# ifconfig eth2 up          #将eth2网卡启用

=============================================================
基础邮件服务

电子邮件服务器的基本功能
  为用户提供电子邮箱存储空间
  处理用户发出的邮件-------传递给收件服务器
  处理用户收到的邮件-------投递到邮箱

装包 配置 起服务
DNS服务器: 虚拟机classroom
            server0.example.com

[root@desktop0 ~]# firewall-cmd --set-default-zone=trusted 
[root@server0 ~]# firewall-cmd --set-default-zone=trusted 

1. 虚拟机server
安装软件postfix,提供邮件功能的软件
[root@server0 /]# yum -y install postfix
[root@server0 /]# rpm -q postfix

2. 修改配置文件/etc/postfix/main.cf
[root@server0 /]# vim /etc/postfix/main.cf  #wim末行模式  :set nu
99 myorigin = server0.example.com           #默认补全邮箱账号后缀
116 inet_interfaces = all                   #本机所有网卡都提供邮件服务
164 mydestination = server0.example.com     #判断为本域邮件依据
  
3. 重启postfix邮件服务
[root@server0 /]# systemctl restart postfix
[root@server0 /]# systemctl enable postfix

4. 使用mail命令发信/收信
mail -s '邮件标题' -r 发邮件人 收邮件人
例:
[root@server0 /]# mail -s 'zhaiyanquan' -r yg xln  
123456789        #在这里输入信内容
.                 #这里的点表示结束写信发送
或
[root@server0 /]# echo 9876543231 | mail -s 'ZHAIYANQUAN' -r yg xln

mail -u 收邮件人
例:
[root@server0 /]# mail -u xln
& 1     #输入1表示是第一封信
& exit  #退出

==============================================================
准备交换空间

交换空间(虚拟内存): 缓解内存不足

parted分区工具(划分GPT分区模式)
   GPT分区模式: 128个主分区,最大的空间18EB

[root@server0 /]# parted /dev/vdb
(parted) mktable gpt       #初始化磁盘,不能重复执行
(parted) mkpart            #划分新的分区
分区名称？  []? zhai          #自定义
文件系统类型？  [ext2]? ext4  #随便写,不起实际作用
起始点？ 0                                         
结束点？ 2G  
忽略/Ignore/放弃/Cancel? Ignore   
(parted) print     #显示分区信息
(parted) unit GB   #显示单位                                           
(parted) print   
(parted) quit      #退出分区操作
(parted) rm        #删除分区                                                  
分区编号？ 1           #1表示第一个分区

[root@server0 /]# lsblk  #显示分区信息
server
==============================================================
配置IPv6地址

IPv4 地址表示
  32个二进制位,点击分隔的十进制数

IPv6 地址表示
  128个二进制,利用冒号分隔,分隔8部分,最终每一部分有16进制标识

为虚拟机server配置IPv6地址2003:ac18::305/64

1. 利用ncmli命令查看网卡名称
[root@server0 /]# nmcli connection show
System eth0  #是网卡名称

2. 配置IPv6地址
[root@server0 /]# nmcli connection modify 'System eth0' ipv6.method manual ipv6.addresses '2003:ac18::305/64' connection.autoconnect yes

[root@server0 /]# nmcli connection up 'System eth0'   #激活配置的IPv6地址

[root@server0 /]# nmtui   #图形方式配置 
  
[root@server0 /]# ifconfig | less   

ping6
[root@server0 /]# ping6 -c 4 2003:ac18::305

==============================================================
配置聚合连接(链路集合)

team,集合链路(也称为链路聚合)

虚拟机配置链路集合:
1. 创建虚拟网卡team0 ,参考man teamd.conf 全文搜索/examples
[root@server0 ~]# nmcli connection add type team con-name team0 ifname team0 config '{"runner": {"name": "activebackup"}}'
[root@server0 ~]# man teamd.conf  #
[root@server0 ~]# nmcli connection delete team0  #删除某个网卡,team0是配置文件名称

2. 添加成员
nmcli connection 添加 类型 组队-成员 配置文件名team0-1 网卡设备名eth1 主设备为team0
例:
[root@server0 ~]# nmcli connection add type team-slave con-name team0-1 ifname eth1 master team0
[root@server0 ~]# nmcli connection add type team-slave con-name team0-2 ifname eth2 master team0
team0-1和team0-2是配置文件名,自定义

如果有敲错,请删除从新创建team0
[root@server0 ~]# nmcli connection delete team0-1  (生成配置文件名)
[root@server0 ~]# nmcli connection delete team0-2  (生成配置文件名)

3. 配置IP地址, 再激活
[root@server0 ~]# nmcli connection modify team0 ipv4.method manual ipv4.addresses '192.168.1.1/24' connection.autoconnect yes
[root@server0 ~]# nmcli connection up team0  #激活IP地址

[root@server0 ~]# teamdctl team0 state  #查看team0信息
[root@server0 ~]# ifconfig eth2 down    #禁用eth2网卡
[root@server0 ~]# ifconfig eth2 up      #开启eth2网卡
[root@server0 ~]# teamdctl team0 state  #查看team0信息

3.service=====================================================================================================

service_day01=================================================================================================

新教学环境的搭建

一 构建两台虚拟机
真机上运行:
[student@room9pc01 ~]$ clone-vm7 
Enter VM number: 8
Creating Virtual Machine disk image......	[OK]
Defining new virtual machine......		[OK]

[student@room9pc01 ~]$ clone-vm7 
Enter VM number: 9
Creating Virtual Machine disk image......	[OK]
Defining new virtual machine......		[OK]


虚拟机    用户为root   密码为123456

###################################################
真机管理虚拟机
  1.直接管理虚拟机,无需IP地址(将"虚拟系统管理软件"关闭)
[student@room9pc01 ~]$ virsh console  A
    退出: Ctrl + ]

[student@room9pc01 ~]$ virsh console  B
    退出: Ctrl + ]

  2.配置IP地址:                                               
     虚拟机A
        1.为eth0配置IP地址:192.168.4.7/24
        2.配置主机名:svr7.tedu.cn
     虚拟机B
        1.为eth0配置IP地址:192.168.4.207/24
        2.配置主机名:pc207.tedu.cn

[root@localhost /]# echo pc207.tedu.cn > /etc/hostname
[root@localhost /]# cat /etc/hostname
pc207.tedu.cn
[root@localhost /]# hostname
localhost.localdomain
[root@localhost /]# hostname pc207.tedu.cn

####################################################
[root@svr7 ~]# setip
Network name(eth0/eth1/eth2/eth3):eth0
Set IP(IP/24):192.168.4.7/24
Set Gateway(default none):


[root@svr7 ~]# ifconfig | head -2
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.4.7  netmask 255.255.255.0  broadcast 192.168.4.255
[root@svr7 ~]# 

###################################################
真机设置别名
[student@room9pc01 ~]$ vim /home/student/.bashrc 
 alias goa='ssh -X root@192.168.4.7'
 alias gob='ssh -X root@192.168.4.207'

[student@room9pc01 ~]$ exit

新开一个终端,验证goa与gob

##################################################
虚拟机查看文件内容
[root@svr7 ~]# cat /etc/motd 

###################################################
为虚拟机A与虚拟机B构建Yum仓库

服务端:真机上构建ftp服务，共享光盘所有内容
1.安装vsftpd软件包                                          
]$ rpm -q vsftpd
vsftpd-3.0.2-22.el7.x86_64
]$ systemctl status  vsftpd  #查看服务状态

2.创建在/var/ftp/centos-1804      
 FTP服务默认共享:/var/ftp/
]$ ls /var/ftp/
]$ ls /var/ftp/centos-1804/
]$ firefox ftp://192.168.4.254/centos-1804/

3.开机自动挂载:
]$ vim /etc/fstab
/var/lib/libvirt/images/iso/CentOS7-1804.iso  /var/ftp/centos-1804 iso9660 defaults 0 0


客户端:虚拟机A与虚拟机B /etc/yum.repos.d/*.repo
[root@svr7 ~]# cat /etc/yum.repos.d/local.repo 
[local_repo]
name=CentOS-$releasever - Base
baseurl=ftp://192.168.4.254/centos-1804
enabled=1
gpgcheck=0
[root@svr7 ~]# yum -y install httpd

[root@pc207 ~]# cat /etc/yum.repos.d/local.repo 
[local_repo]
name=CentOS-$releasever - Base
baseurl=ftp://192.168.4.254/centos-1804
enabled=1
gpgcheck=0
[root@pc207 ~]# yum -y install httpd

###################################################

##################################################
补充:解决远程管理student用户虚拟机关闭问题
[student@room9pc01 ~]$ vim /home/student/.bash_logout 
里面的内容删除:/var/lib/libvirt/images/virt
 
####################################################
     虚拟机C
        1.为eth0配置IP地址:192.168.4.10/24
        2.配置主机名:C.tedu.cn
        3.使用真机FTP构建Yum仓库

     虚拟机D
        1.为eth0配置IP地址:192.168.4.20/24
        2.配置主机名:D.tedu.cn
        3.使用真机FTP构建Yum仓库

####################################################
扩展的几个应用

目录结构
• 认识Linux的目录层次:
– man hier

• 常见一级目录的用途
  /boot 	    存放系统引导必需的文件,包括内核、启动配置
  /bin、/sbin  存放各种命令程序
  /dev         存放硬盘、键盘、鼠标、光驱等各种设备文件
  /etc 		存放Linux系统及各种程序的配置文件
  /root、/home/用户名 分别是管理员root、普通用户的默认家目录
  /var 		存放日志文件、邮箱目录等经常变化的文件
  /proc 		存放内存中的映射数据,不占用磁盘
  /tmp 		存放系统运行过程中使用的一些临时文件

[root@svr7 ~]# ls -ld /tmp/

##################################################
权限的数值表示
• 权限的数值化
– 基本权限:r = 4,w = 2,x = 1
– 附加权限:SUID = 4,SGID = 2,Sticky Bit = 1

• 采用数值形式设置权限
– chmod [-R] nnn 文档...
– chmod [-R] xnnn 文档...


[root@svr7 ~]# mkdir /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 750 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 700 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 007 /nsd01
[root@svr7 ~]# ls -ld /nsd01

[root@svr7 ~]# chmod 077 /nsd01
[root@svr7 ~]# ls -ld /nsd01

###################################################

历史命令
• 管理/调用曾经执行过的命令
– history:查看历史命令列表
– history -c:清空历史命令
– !n:执行命令历史中的第n条命令
– !str:执行最近一次以str开头的历史命令
• 调整历史命令的数量
[root@svr7 ~]# vim /etc/profile
HISTSIZE=1000  //默认记录1000条


[root@svr7 ~]# history         #查看历史命令
[root@svr7 ~]# history -c      #清空历史命令
[root@svr7 ~]# history 
    1  history 
[root@svr7 ~]# 

[root@svr7 ~]# cat /etc/redhat-release 
[root@svr7 ~]# ls /root/
[root@svr7 ~]# cat /etc/hostname
[root@svr7 ~]# history 

[root@svr7 ~]# !cat  #执行历史命令中,最近一条以cat开头
##################################################
• du,统计文件的占用空间
– du [选项]... [目录或文件]...

– -s:只统计每个参数所占用的总空间大小
– -h:提供易读容量单位(K、M等)

[root@svr7 ~]# du -sh /root
[root@svr7 ~]# du -sh /etc/
[root@svr7 ~]# du -sh /

[root@svr7 ~]# du -sh /boot

• date,查看/调整系统日期时间
– date +%F、date +%R

– date +"%Y-%m-%d %H:%M:%S"
– date -s "yyyy-mm-dd HH:MM:SS"


[root@svr7 ~]# date
[root@svr7 ~]# date +%Y    #显示年
2019
[root@svr7 ~]# date +%m    #显示月
04
[root@svr7 ~]# date +%d    #显示日
19
[root@svr7 ~]# date +%H    #显示 时
14
[root@svr7 ~]# date +%M    #显示 分
08
[root@svr7 ~]# date +%S    #显示 秒

[root@svr7 ~]# date +%F    #显示 年-月-日

##################################################
制造快捷方式:

1.软连接 
  ln  -s   /路径/源文件      /路径/快捷方式名

若原始文件或目录被删除,连接文件将失效
软连接可存放在不同分区/文件系统

[root@svr7 ~]# cat /etc/redhat-release 
[root@svr7 ~]# ln -s /etc/redhat-release  /abc
[root@svr7 ~]# ls /

[root@svr7 ~]# ls -l /abc
[root@svr7 ~]# cat /abc

[root@svr7 ~]# ln -s /etc/redhat-release  /
[root@svr7 ~]# ls /

2.硬连接
  ln    /路径/源文件      /路径/快捷方式名

若原始文件被删除,连接文件仍可用
硬连接与原始文件必须在同一分区/文件系统

[root@svr7 ~]# ls /opt/
[root@svr7 ~]# echo 123 > /opt/A.txt

[root@svr7 ~]# ln /opt/A.txt /opt/B
[root@svr7 ~]# ls /opt/
[root@svr7 ~]# cat /opt/A.txt 
[root@svr7 ~]# cat /opt/B

[root@svr7 ~]# rm -rf /opt/A.txt 
[root@svr7 ~]# ls /opt/

[root@svr7 ~]# cat /opt/B

###################################################
获取命令帮助
1.利用--help选项
[root@svr7 ~]# date --help

2.利用man命令
[root@svr7 ~]# man  date

[root@svr7 ~]# man 5 passwd   #5表示文件类型的帮助信息

#################################################
 zip归档工具,跨平台的压缩归档格式

• 归档+压缩操作
– zip [-r] 备份文件.zip   被归档的文档...
[root@svr7 ~]# yum  -y install zip
[root@svr7 ~]# zip -r  /opt/test.zip  /etc/passwd /home/
[root@svr7 ~]# ls /opt
[root@svr7 ~]# zip -r  /opt/nb.zip   /etc/fstab   
[root@svr7 ~]# ls /opt

• 释放归档+解压操作
– unzip 备份文件.zip [-d 目标文件夹]    
[root@svr7 ~]# yum -y install unzip
[root@svr7 ~]# mkdir /nsd02
[root@svr7 ~]# unzip /opt/test.zip -d /nsd02/

[root@svr7 ~]# ls /nsd02
[root@svr7 ~]# ls /nsd02/etc/

####################################################
将FTP服务器上,RHCE测试脚本
     desktop0.sh  rht-labcheck  server0.sh
下载到本地/home/student/bin/赋予执行权限

[student@room9pc01 ~]$ chmod -R  +x /home/student/bin/
[student@room9pc01 ~]$ ls /home/student/bin/
clone-vm7  desktop0.sh  rht-labcheck  server0.sh
[student@room9pc01 ~]$ 

##################################################
自定义Yum仓库

1.真机:具备从互联网下载的软件包
真机:访问FTP服务将 tools.tar.gz 下载真机的桌面上

2.将真机的tools.tar.gz包,上传到虚拟机A的/root目录下
scp依赖于ssh, scp=ssh + cp

 scp  /本地路径/源文件      root@对方的IP地址:/对方的路径

[student@room9pc01 ~]$ scp /home/student/桌面/tools.tar.gz   root@192.168.4.7:/root/

[student@room9pc01 ~]$ goa
[root@svr7 ~]# ls /root/
Desktop  tools.tar.gz
[root@svr7 ~]# 

3.将tar进行解包
[root@svr7 ~]# tar -xf /root/tools.tar.gz -C  /
[root@svr7 ~]# ls /

[root@svr7 ~]# ls /tools/
[root@svr7 ~]# ls /tools/other/

4.仓库数据文件
[root@svr7 ~]# yum -y install createrepo
[root@svr7 ~]# createrepo /tools/other/

[root@svr7 ~]# ls /tools/other/
[root@svr7 ~]# ls /tools/other/repodata/

5.修改配置文件
[root@svr7 ~]# cd /etc/yum.repos.d/          
[root@svr7 yum.repos.d]# ls
[root@svr7 yum.repos.d]# vim local.repo 
[local_repo]
name=CentOS-$releasever - Base
baseurl=ftp://192.168.4.254/centos-1804
enabled=1
gpgcheck=0

[other]
name=my rpm
baseurl=file:///tools/other    #file://表示本机为服务端
enabled=1
gpgcheck=0
[root@svr7 yum.repos.d]# yum repolist

软件的安装:
[root@svr7 /]# yum -y install cmatrix

[root@svr7 /]# rpm -ql cmatrix      #显示包的安装清单
[root@svr7 /]# ls /usr/bin/cmatrix 
/usr/bin/cmatrix
[root@svr7 /]# cmatrix 
[root@svr7 /]# cmatrix -C  red

[root@svr7 /]# yum -y install oneko
[root@svr7 /]# oneko
[root@svr7 /]# oneko  &   #将程序放入后台

[root@svr7 /]# yum -y install sl
[root@svr7 /]# ls
##################################################
vim编辑技巧

 vi :Linux基本的文本编辑


命令模式操作
[root@svr7 ~]# cp   /etc/passwd  /opt/pass.txt
[root@svr7 ~]# vim  /opt/pass.txt

光标跳转
	上、下、左、右
	Home 键 或 ^、数字 0 		跳转到行首
	End 键 或“$”键 				跳转到行尾
	PgUp 键、PgDn 键 			向上翻页、向下翻页
	1G 或 gg 					跳转到全文的首行
	G 						跳转到全文的末尾行

复制/粘贴/删除
	复制 yy、#yy 		复制光标处的一行、#行
	粘贴 p、P 		粘贴到光标处之后、之前
	x 或 Delete键 		删除光标处的单个字符
	dd、#dd 			删除光标处的一行、#行
	d^ 				从光标处之前删除至行首
	d$或D(大写)		从光标处删除到行尾
	C(大写) 			从光标处删除到行尾,进入插入模式

查找/撤销/保存
	/root 		向后查找字符串“root”
	n、N 		跳至后/前一个结果
	u 			撤销最近的一次操作
	U 			撤销对当前行的所有修改
	Ctrl + r 	取消前一次撤销操作(反撤销)
	ZZ(大写) 	保存修改并退出

####################################################
末行模式操作

 读入其他文件内容
[root@svr7 ~]# echo 123 > /opt/1.txt
[root@svr7 ~]# echo abc > /opt/2.txt
[root@svr7 ~]# vim /opt/1.txt 
       :r  /opt/2.txt    #读入2.txt文件内容到当前文件
       :r  /etc/passwd  #读入/etc/passwd文件内容到当前文件


字符串替换
	:s /root/admin 		替换光标所在的当前行第一个“root”
	:s /root/admin/g   	替换光标所在的当前行所有的“root”
	:1,10 s/root/admin/g 	替换第1-10行所有的“root”
	:% s/root/admin/g	     替换文件内所有的“root”

[root@svr7 ~]# vim /opt/pass.txt


开关参数的控制
	:set  nu或nonu	 	显示/不显示行号
	:set  ai或noai 		启用/关闭自动缩进

###################################################

====================================================================
--教学环境的搭建

一. 构建两台虚拟机
[root@room12pc8 ~]# clone-vm7
Enter VM number: 9  #9表示是第9台虚拟机

虚拟机 用户为root 密码为123456

1. 真机管理虚拟机 ,无需IP地址(虚拟机系统管理系统)
  先关闭虚拟机窗口,然后强制重启
[root@room12pc8 ~]# virsh console A
退出: Ctrl + ]
[root@room12pc8 ~]# virsh console B
退出: Ctrl + ]

2.配置IP地址:
  虚拟机A
  1.为eth0配置IP地址: 192.168.4.7/24
[root@pc207 ~]# nmcli connection modify 'eth0' ipv4.method manual ipv4.addresses '192.168.4.7/24' connection.autoconnect yes
[root@pc207 ~]# nmcli connection up 'eth0'
  2.配置主机名: svr7.tedu.cn
[root@pc207 ~]# hostnamectl set-hostname svr7.tedu.cn

虚拟机B
1.为eth0配置IP地址: 192.168.4.207/24
[root@pc207 ~]# nmcli connection modify 'eth0' ipv4.method manual ipv4.addresses '192.168.4.207/24' connection.autoconnect yes
[root@pc207 ~]# nmcli connection up 'eth0'
2.配置主机名: pc207.tedu.cn
[root@pc207 ~]# hostnamectl set-hostname pc207.tedu.cn

[root@svr7 ~]# nmtui  #图片配置
[root@svr7 ~]# setip

真机设置别名
[student@room12pc8 ~]$ vim /home/student/.bashrc  #给用户设置别名
 alias goa='ssh -X root@192.168.4.7'
 alias gob='ssh -X root@192.168.4.207'

新开一个终端,验证goa与gob

===========================================================================
虚拟机查看文件内容
[root@svr7 ~]# vim /etc/motd  #公告

===========================================================================
发布网络Yum源

为虚拟机A与虚拟机B构建Yum仓库
服务端: 真机上构建ftp服务, 共享光盘所有内容
1. 安装vsftpd软件包
[root@room12pc8 ~]# rpm -q vsftpd
[root@room12pc8 ~]# systemctl status vsftpd #查看服务状态

2. 创建载/var/ftp/centos-1804
[root@room12pc8 ~]# ls /var/ftp #真机的存在路径
[root@room12pc8 ~]# ls /var/ftp/centos-1804  #如果centos-1804不存在要创建
FTP服务默认共享:　/var/ftp/
[root@room12pc8 ~]# firefox ftp://192.168.4.254/centos-1804

3.开机自动挂载
[root@room12pc8 ~]# vim /etc/fstab
/var/lib/libvirt/images/iso/CentOS7-1804.iso  /var/ftp/centos-1804 iso9660 defaults 0 0

[student@room12pc8 ~]$ vim /home/student/.bash_logout
/var/lib/libvirt/images/virt　　＃删除这行

4.客户端：虚拟机A与虚拟机B
[root@svr7 ~]# vim /etc/yum.repos.d/local.repo
[local_repo]
name=CentOS-$releasever - Base
baseurl=ftp://192.168.4.254/centos-1804  //
enabled=1
gpgcheck=0
[root@svr7 ~]# yum -y install httpd

[root@pc7 ~]# vim /etc/yum.repos.d/local.repo
[local_repo]
name=CentOS-$releasever - Base
baseurl=ftp://192.168.4.254/centos-1804
enabled=1
gpgcheck=0
[root@pc207 ~]# yum -y install httpd　＃测试

======================================================================
目录结构
• 认识Linux的目录层次:
– man hier

目录结构
常见一级目录的用途
/boot             存放系统引导必须的文件,包括内核,启动配置
/bin /sbin        存放各种命令程序
/dev              存放硬盘,键盘,鼠标光驱等各种设备文件
/etc              存放Llinux系统及各种程序的配置文件
/root /hone用户名  分别是管理员root,普通用户的默认家目录
/var              存放日志文件,邮箱目录等经常变化的文件
/proc             存放内存中的映射数据,不占用磁盘
/tmp              存放系统运行程中使用的一些临时文件

[root@svr7 ~]# ls -ld /tmp/

======================================================================
权限的数值表示

权限的数值化
基本权限：ｒ=4,w=2,x=1
附加权限：SUID=4,SGUD=2,Sticky Bit=1

基本权限：ｒ=4,w=2,x=1
例：
[root@svr7 ~]# mkdir /nsd01
[root@svr7 ~]# ls -ld /nsd01
drwx------ 2 root root 6 4月  19 11:40 /nsd01

附加权限：SUID=4,SGUD=2,Sticky Bit=1
例：
[root@svr7 ~]# mkdir /nsd02
[root@svr7 ~]# chmod 3755 /nsd02　＃3是附加权限的和
[root@svr7 ~]# ls -ld /nsd02
drwxr-sr-t 2 root root 6 4月  19 11:46 /nsd02　

例：
#默认权限
[root@svr7 ~]# ls -ld /zhai
drwxr-xr-x. 2 root root 6 5月   5 11:38 /zhai 
#使用数值修改权限
[root@svr7 ~]# chmod 7751 /zhai
[root@svr7 ~]# ls -ld /zhai
drwsr-s--t. 2 root root 6 5月   5 11:38 /zhai
#恢复权限
[root@svr7 ~]# chmod 00751 /zhai  
[root@svr7 ~]# ls -ld /zhai
drwxr-x--x. 2 root root 6 5月   5 11:38 /zhai

===========================================================================
历史命令

管理／调用曾经执过的命令
history: 查看历史命令列表
history　-c:查看历史命令
!n:执行命令历史中的第ｎ条命令
!str :执行最近一次str开头的历史命令
例：
调整历史记录的数量
[root@svr7 ~]# vim /etc/protocols
HISTSIZE=1000
或
[root@server0 ~]# vim /etc/profile  //真机
HISTSIZE=1000

确认设置结果
所有用户重新登录以后即可生效：
[root@server0 ~]# su - root
[root@server0 ~]# echo $HISTSIZE

[root@svr7 ~]# history　　　＃查看历史命令
[root@svr7 ~]# history -c　＃清空历史命令

[root@svr7 ~]# !cat  #执行历史命令中,最近一条以cat开头

========================================
du：统计文件的占用空间　　
　du [选项]　[目录或文件]
　-ｓ:只统计每个参数所占用的总空间大小
　-h: 提供易读容量单位（Ｋ M 等）
例：
[root@server0 ~]# du -sh /boot /etc/pki
80M	/boot
1.3M	/etc/pki
[root@svr7 ~]# du -sh /*

[root@room0pc99 桌面]# du -sh /var //统计目录/var总空间大小
27G	/var

========================================
date:查看／调整系统日期时间
date +%F、date +%R
date +"%Y-%m-%d %H:%M:%S"
date -s "yyyy-mm-dd HH:MM:SS"

[root@svr7 ~]# date
[root@svr7 ~]# date +%Y    #显示年
2019
[root@svr7 ~]# date +%m    #显示月
04
[root@svr7 ~]# date +%d    #显示日
19
[root@svr7 ~]# date +%H    #显示 时
14
[root@svr7 ~]# date +%M    #显示 分
08
[root@svr7 ~]# date +%S    #显示 秒

[root@svr7 ~]# date +%F    #显示 年-月-日

date +%F  date +%R
例：
[root@svr7 ~]# date +%Y
2019
[root@svr7 ~]# date +%R
14:10
[root@svr7 ~]# date +"%F %R"
2019-04-19 14:12

[root@svr7 ~]# hwclock -s　重设系统日期时间

========================================
制造快捷方式

1.软件链接：　
ln -s /路径／源文件　／路径／快捷方式
例
[root@svr7 ~]# ln -s /etc/redhat-release /abc
[root@svr7 ~]# cat /abc
CentOS Linux release 7.5.1804 (Core) 

2.硬链接：删除源文件，快捷方式还可以用，但是要载同目录下
ln  /路径／源文件　／路径／快捷方式
例：
[root@svr7 ~]# echo 1235566777 > /opt/1.txt
[root@svr7 ~]# ln /opt/1.txt /opt/3　　＃3文件是不存在

软件连接和硬连接例子
[root@server0 ~]# echo "AAAA" > file1
[root@server0 ~]# ln -s file1 file1-s  #软件连接
[root@server0 ~]# ln  file1 file1-n    #硬连接
[root@server0 ~]# rm -rf file1         #删除原文件
[root@server0 ~]# ln file1-n file1     #使用硬连接恢复原文件

========================================
获取命令帮助
1.利用--help选项
[root@svr7 ~]# date --help

2.利用man命令
[root@svr7 ~]# man  date

[root@svr7 ~]# man 5 passwd   #5表示文件类型的帮助信息

========================================
zip归档工具：跨平台压缩归档

[root@svr7 ~]# yum -y install zip
zip [-r] 备份文件.zip　被归档的文档
例：
[root@svr7 ~]# zip -r /test.zip /etc/passwd /home

释放.zip压缩包
[root@svr7 ~]# yum -y install unzip
unzip 备份文件.zip　[-d 目录文件夹]
例：
[root@svr7 ~]# unzip /test.zip -d /zhai

============================================================
[student@room12pc8 ~]$ ls  /home/student/bin/

============================================================
自定义Yum仓库

1. 具备从互联网网下载的软件包
真机: 访问FTP服务将tools.tar.gz 下载真机桌面上

2.将真机的tools.tar.gz包上传到虚拟机A的/root目录下
scp依赖于ssh,scp=ssh+cp
scp /本地路径 
将桌面/tools.tar.gz上传到虚拟机A/root/ 下
[root@room12pc8 ~]# scp -r 桌面/tools.tar.gz root@192.168.4.7:/root/
                                   要传的目录　         对方用户　目标IP   目标目标下
3.将tar进行解包
[root@svr7 ~]# tar -xf /root/tools.tar.gz -C /

4.仓库数据文件
[root@svr7 ~]# yum -y install createrepo
[root@svr7 ~]# createrepo /tools/other
[root@svr7 ~]# ls /tools/other
[root@svr7 ~]# ls /tools/other/repodata

5.修改配置文件
[root@svr7 ~]# vim /etc/yum.repos.d/local.repo
[other]
name=my_other
baseurl=file:///tools/other
enabled=1
gpgcheck=0

============================================================
有趣的软件包
[root@svr7 ~]# yum -y install cmatrix
[root@svr7 ~]# cmatrix
[root@svr7 ~]# cmatrix -C red
[root@svr7 ~]# yum -y install oneko
[root@svr7 ~]# yum -y install sl
[root@svr7 ~]# sl  #开火车

============================================================
U盘读取
    文件系统FAT: 一般可以识别

软件: ntfs-3g
挂载: mount.ntfs-3g
[root@room9pc01 ~]# yum list | grep  ntfs-3g
[root@room9pc01 ~]# yum -y install ntfs-3g_ntfsprogs.x86_64
[root@room9pc01 ~]# lsblk
[root@room9pc01 ~]# find /dev -name ZHAIYANQUAN  #ZHAIYANQUAN是U盘名称
/dev/disk/by-label/ZHAIYANQUAN  
[root@room9pc01 ~]# mount.ntfs-3g /dev/disk/by-label/ZHAIYANQUAN 桌面 #挂载在桌面


service_day02=================================================================================================

新教学环境的搭建

一 构建两台虚拟机
真机上运行:
                                           
     虚拟机A
        1.为eth0配置IP地址:192.168.4.7/24
        2.配置主机名:svr7.tedu.cn
     虚拟机B
        1.为eth0配置IP地址:192.168.4.207/24
        2.配置主机名:pc207.tedu.cn

##########################################################
真机:
   root密码:  teacher.com

##########################################################
U盘读取:
    文件系统:FAT   一般可以直接识别
   
       扩展FAT文件系统

    文件系统:NTFS
 
  [root@room9pc01 ~]# lsblk 
  NAME   MAJ:MIN RM   SIZE RO TYPE MOUNTPOINT
  sda      8:0    0 465.8G  0 disk 
   ├─sda1   8:1    0 297.7G  0 part /var/lib/libvirt/ima
   └─sda2   8:2    0   100G  0 part /
  sdb      8:16   0 931.5G  0 disk 
   └─sdb1   8:17   0 931.5G  0 part 
  loop0    7:0    0   8.8G  0 loop /var/ftp/centos-1804
  [root@room9pc01 ~]# 

  [root@room9pc01 ~]# mount.ntfs-3g  /dev/sdb1     挂载点

########################################################
真机远程管理虚拟机A

KVM构建及管理

虚拟化概述
• virtualization 资源管理
– x个物理资源 --> y个逻辑资源
– 实现程度:完全、部分、硬件辅助(CPU)


• 虚拟化主要厂商及产品

	VMware          VMware Workstation、vSphere
	Microsoft 	   VirtualPC、Hyper-V
	RedHat 	   KVM、RHEV
	Citrix 	   Xen
	Oracle 	   Oracle VM VirtualBox

安装虚拟化服务器平台
                                                                   
在虚拟机A:
• 主要软件包
– qemu-kvm	:为 kvm 提供底层仿真支持
– libvirt-daemon	:libvirtd 守护进程,管理虚拟机
– libvirt-client	:用户端软件,提供客户端管理命令
– libvirt-daemon-driver-qemu	:libvirtd 连接 qemu 的驱动
– virt-manager	:图形管理工具

#######################################################
虚拟化服务:libvirtd
[root@svr7 ~]# systemctl restart libvirtd
[root@svr7 ~]# systemctl enable libvirtd
[root@svr7 ~]# virt-manager   #运行图形管理虚拟化工具
[root@svr7 ~]# LANG=en  virt-manager   #以英文开启该工具

########################################################
使用虚拟化功能,需要CPU支持虚拟化功能

CPU支持虚拟化功能,有可能关闭
 开启----->BIOS中进行开启

########################################################
连接本地KVM
• 使用 virt-manager 客户端工具
– 应用程序 --> 系统工具 --> 虚拟系统管理器
– 默认连本机的 libvirtd 服务

真机上操作:
[student@room9pc01 ~]$ virt-manager 

virsh控制工具:
]$ virsh  console  虚拟机名字      #真机直接管理相应虚拟机
]$ virsh 
欢迎使用 virsh，虚拟化的交互式终端。

输入：'help' 来获得命令的帮助信息
       'quit' 退出

virsh # console  A


virsh nodeinfo  :查看KVM节点(服务器)信息

virsh list [--all]  :列出虚拟机

virsh net-list [--all]  :列出虚拟网络

virsh dominfo 虚拟机名称   :查看指定虚拟机的信息

]$ virsh dominfo win2008
]$ virsh autostart win2008    #将虚拟机设置为开机自启
域 win2008标记为自动开始

]$ virsh dominfo win2008 
]$ virsh autostart --disable win2008   #将虚拟机设置为开机不自启
域 win2008取消标记为自动开始

]$ virsh dominfo win2008

• 运行|重启|关闭指定的虚拟机
– virsh start|reboot|shutdown 虚拟机名称
• 强制关闭指定的虚拟机
– virsh destroy 虚拟机名称

[student@room9pc01 ~]$ virsh list --all
[student@room9pc01 ~]$ virsh start B
[student@room9pc01 ~]$ virsh list --all

[student@room9pc01 ~]$ virsh  shutdown B
域 B 被关闭
[student@room9pc01 ~]$ virsh list --all
[student@room9pc01 ~]$ virsh start B
[student@room9pc01 ~]$ virsh list
[student@room9pc01 ~]$ virsh destroy B
域 B 被删除
[student@room9pc01 ~]$ virsh list --all

##########################################################

• 一台KVM虚拟机的组成
– xml配置文件(虚拟机配置文件):定义虚拟机的名称、UUID、CPU、内
存、虚拟磁盘、网卡等各种参数设置
[student@room9pc01 ~]$ ls /etc/libvirt/qemu/


– 磁盘镜像文件:保存虚拟机的操作系统及文档数据,
镜像路径取决于xml配置文件中的定义
[student@room9pc01 ~]$ ls /var/lib/libvirt/images/


导出xml配置文件
– 查看:virsh dumpxml 虚拟机名
– 备份:virsh dumpxml 虚拟机名  > 虚拟机名.xml

   虚拟机的名称、UUID、虚拟磁盘文件路径、网卡唯一编号(MAC地址)   

#########################################################
一  新建一台全新的虚拟机,虚拟机名字nsd01
   
   虚拟机 :
       内存为  2048M  硬盘 9G  虚拟机名字nsd01  网络类型:private1

       软件包选择: 最小化安装     分区选择:自动分区   root密码设置为:1

二 利用,虚拟机nsd01作为模板,手动快速生成一台全新的虚拟机nsd02
  1.将虚拟机nsd01的磁盘文件复制一份,修改磁盘文件的名称
  [student@room9pc01 /]$ su - root
   密码： teacher.com
  [root@room9pc01 ~]# 

  ]# virsh destroy  nsd01           #强制关闭虚拟机nsd01
  ]# virsh  list  --all 
  ]# cd  /var/lib/libvirt/images/

  ]# du  -sh  nsd01.qcow2           #计算磁盘文件大小
  ]# cd  /var/lib/libvirt/images/

  ]# cp  nsd01.qcow2  nsd02.qcow2    #复制磁盘文件
  ]# du  -sh nsd02.qcow2 

  2.将虚拟机nsd01的xml文件复制一份,修改内容
  ]# mkdir /xmlfile
  ]# virsh dumpxml nsd01 > /xmlfile/haha.xml  #导出虚拟机xml文件
  ]# ls /xmlfile/
  haha.xml
  ]# vim  /xmlfile/haha.xml 

     修改虚拟机的名称: <name>nsd02</name>
   UUID:   <uuid></uuid>    #删除整行内容,按u撤销
     虚拟磁盘文件路径:  file='/var/lib/libvirt/images/nsd02.qcow2'
     网卡唯一编号(MAC地址)  :
       <mac address='52:54:00:32:a3:aa'/> #删除整行内容,按u撤销

   3.导入虚拟机信息
  ]# virsh define /xmlfile/haha.xml    #导入虚拟机信息
    定义域 nsd02（从 /xmlfile/haha.xml）

  ]# virsh list --all
  ]# virt-manager
   
   4.删除的命令
  ]# virsh list --all
  ]# virsh destroy  nsd02   #关机

  ]# virsh undefine  nsd02  #删除虚拟机nsd02,仅会删除/etc下xml文件
  ]# virsh list --all

  ]# ls /etc/libvirt/qemu   #被删除
  ]# ls /xmlfile/           #存在
  ]# ls /var/lib/libvirt/images/nsd02.qcow2  #默认保留磁盘文件

###########################################################
以nsd01虚拟机为模板,制作虚拟机nsd03
1.复制nsd01虚拟机的磁盘文件
[root@room9pc01 /]# cd /var/lib/libvirt/images/
[root@room9pc01 images]# cp nsd01.qcow2 nsd03.qcow2
[root@room9pc01 images]# ls

2.修改nsd01的xml文件
[root@room9pc01 /]# virsh dumpxml nsd01 > /xmlfile/nsd03.xml
[root@room9pc01 /]# ls /xmlfile/
[root@room9pc01 /]# vim  /xmlfile/nsd03.xml

     修改虚拟机的名称: <name>nsd03</name>
   UUID:   <uuid></uuid>    #删除整行内容,按u撤销
     虚拟磁盘文件路径:  file='/var/lib/libvirt/images/nsd03.qcow2'
     网卡唯一编号(MAC地址)  :
       <mac address='52:54:00:32:a3:aa'/> #删除整行内容,按u撤销

[root@room9pc01 /]# virsh define /xmlfile/nsd03.xml
[root@room9pc01 /]# virsh list --all
########################################################

编辑虚拟机设置
• 对虚拟机的配置进行调整
– 编辑:virsh  edit  虚拟机名

以nsd01虚拟机为模板,制作虚拟机nsd04                  
1.复制nsd01虚拟机的磁盘文件
[root@room9pc01 /]# cd /var/lib/libvirt/images/
[root@room9pc01 images]# cp nsd01.qcow2 nsd04.qcow2
[root@room9pc01 images]# ls

[root@room9pc01 /]# virsh list --all
[root@room9pc01 /]# virsh edit nsd01
     修改虚拟机的名称: <name>nsd04</name>
   UUID:   <uuid></uuid>    #删除整行内容,按u撤销
     虚拟磁盘文件路径:  file='/var/lib/libvirt/images/nsd04.qcow2'
     网卡唯一编号(MAC地址)  :
       <mac address='52:54:00:32:a3:aa'/> #删除整行内容,按u撤销

[root@room9pc01 /]# virsh list --all
##########################################################
COW技术原理
• Copy On Write,写时复制
– 前端盘直接映射原始盘的数据内容
– 当前端盘的旧数据有修改时,在修改之前自动将旧数据存入前端盘
– 对前端盘的修改不回写到原始


• qemu-img 通过 -b 选项复用指定后端盘
– qemu-img create -f qcow2 -b 后端盘 前端盘

– qemu-img info   磁盘文件    #查看磁盘文件的信息
– qemu-img create  磁盘文件   #快速产生一个任意大小的磁盘文件,内容为空


1.查看nsd01.qcow2磁盘文件的信息

]# qemu-img  info  /var/lib/libvirt/images/nsd01.qcow2 


#######################################################
通过写时复制技术,生成虚拟机abc01
– qemu-img create -f qcow2 -b 原始盘   前端盘    前端盘大小

1.以nsd01虚拟机磁盘文件为原始盘,产生abc01虚拟机的前端盘    

]# qemu-img create -f qcow2 -b /var/lib/libvirt/images/nsd01.qcow2   /var/lib/libvirt/images/abc01.qcow2  10G

]# qemu-img info /var/lib/libvirt/images/abc01.qcow2 

 前端盘大小最好大于原始盘
 一旦基于原始盘制作出前端盘,原始盘不能做任何改变

2.以前端盘abc01.qcow2产生虚拟机abc01
[root@room9pc01 /]# virsh edit nsd01
     修改虚拟机的名称: <name>abc01</name>
   UUID:   <uuid></uuid>    #删除整行内容,按u撤销
     虚拟磁盘文件路径:  file='/var/lib/libvirt/images/abc01.qcow2'
     网卡唯一编号(MAC地址)  :
       <mac address='52:54:00:32:a3:aa'/> #删除整行内容,按u撤销

[root@room9pc01 /]# 

#########################################################
1.以nsd01虚拟机磁盘文件为原始盘,产生nb虚拟机的前端盘    
]# qemu-img create -f qcow2 -b /var/lib/libvirt/images/nsd01.qcow2   /opt/nb.qcow2  10G

]# qemu-img info /opt/nb.qcow2 

2.以前端盘nb.qcow2产生虚拟机nb
[root@room9pc01 /]# virsh dumpxml nsd01 > /xmlfile/nb.xml
[root@room9pc01 /]# ls /xmlfile/
[root@room9pc01 /]# vim  /xmlfile/nb.xml
     修改虚拟机的名称: <name>nb</name>
   UUID:   <uuid></uuid>     #删除整行内容,  删错可以按u撤销
     虚拟磁盘文件路径:  file='/opt/nb.qcow2'
     网卡唯一编号(MAC地址)  :
       <mac address='52:54:00:32:a3:aa'/>  #删除整行内容
[root@room9pc01 /]# virsh define /xmlfile/nb.xml
[root@room9pc01 /]# virsh list --all
#########################################################

离线访问虚拟机的磁盘文件内容
• 基本用法
 guestmount  -a  虚拟机磁盘路径   -i  /挂载点

[root@room9pc01 /]# virsh destroy nb

[root@room9pc01 /]# mkdir /mnt/disk
[root@room9pc01 /]# ls /mnt/disk/
[root@room9pc01 /]# guestmount -a /opt/nb.qcow2 -i /mnt/disk/
[root@room9pc01 /]# ls /mnt/disk/

###########################################################
教学环境(扩容)

虚拟机A:
]# LANG=en growpart /dev/vda  1  #扩展/dev/vda磁盘的第一个分区空间
]# lsblk 
]# blkid /dev/vda1 

]# xfs_growfs /dev/vda1       #扩展/dev/vda1文件系统
]# df -h

#########################################################

====================================================
安装一个KVM服务器

虚拟化服务软件：
qemu-kvm为 kvm 提供底层仿真支持
libvirt-daemon为libvirtd 守护进程，管理虚拟机
libvirt-client为用户端软件，提供客户端管理命令
libvirt-daemon-driver-qemu为libvirtd 连接 qemu 的驱动
virt-manager为图形管理工具

安装主要KVM软件
[root@svr7 ~]# yum  -y    install  libvirt-daemon  libvirt-client libvirt-daemon-driver-qemu  virt-manager
[root@svr7 ~]# systemctl  restart  libvirtd
[root@svr7 ~]# systemctl  enable  libvirtd
[root@svr7 ~]# virt-manager

====================================================================================
virsh控制工具

真机直接连接虚拟机
[root@room12pc8 ~]# virsh console 虚拟机名字 
或
[root@room12pc8 ~]# virsh
virsh # console 虚拟机名字

查看虚拟化信息
查看KVM节点(服务)信息
[root@room12pc8 ~]# virsh nodeinfo
列出虚拟机
[root@room12pc8 ~]# virsh list       #列出正在运行的虚拟机
[root@room12pc8 ~]# virsh list --all #列出所有虚拟机

列出虚拟网络
[root@room12pc8 ~]# virsh net-list        #列出活跃的虚拟网络
[root@room12pc8 ~]# virsh net-list --all  #列出所有的虚拟网络

查看指定虚拟机的信息
[root@room12pc8 ~]# virsh dominfo 虚拟机名字
例:
[root@room12pc8 ~]# virsh dominfo server

开关机操作
运行|重启|关闭指定的虚拟机
virsh start|reboot|shudown
[root@room12pc8 ~]# virsh reboot 虚拟机名字
例:
[root@room12pc8 ~]# virsh reboot server  #重启
[root@room12pc8 ~]# virsh start server   #运行
[root@room12pc8 ~]# virsh shudown server #关闭

强制关闭指定的虚拟机
[root@room12pc8 ~]# virsh destroy 虚拟机名字
例:
[root@room12pc8 ~]# virsh destroy server

将指定的虚拟机设为开机自动运行
[root@room12pc8 ~]# virsh autostart [--disable] 虚拟名字
例:
[root@room12pc8 ~]# virsh autostart server           #开机自动运行
[root@room12pc8 ~]# virsh autostart --disable server #取消开机自动运行

====================================================================================
一台kVM虚拟机的构成

KVM虚拟机的xml配置文件也就是通常所说的虚拟机的描述文件，主要用来定义一个虚拟机的名称、UUID、CPU、内存、虚拟磁盘、网卡等各种参数设置。
KVM虚拟机的xml配置文件默认位于： /etc/libvirt/qemu/虚拟机名.xml

修改虚拟机配置的基本思路：
编辑虚拟机配置：virsh edit 虚拟机名
根据需要修改，保存配置结果	

xml配置文件
/etc/libvirt/qemu/虚拟机名.xml
例:
[root@room12pc8 ~]# vim /etc/libvirt/qemu/server.xml
[root@room12pc8 ~]# ls /var/lib/libvirt/images/   

导出xml配置文件
查看
[root@room12pc8 ~]# virsh dumpxml 虚拟机名字
例:
[root@room12pc8 ~]# virsh dumpxml server  #查看虚拟机信息
备份
[root@room12pc8 ~]# virsh dumpxml 虚拟机名字 > 虚拟机名字
例:

第一种方法
1.复制nsd01虚拟机的磁盘文件
[root@room12pc8 ~]# cd /var/lib/libvirt/images/
[root@room12pc8 ~]# virsh destroy nsd01 #先强制关机虚拟机nsd01
[root@room12pc8 ~]# virsh list --all    #查看运行状态
[root@room12pc8 images]# cp nsd01.qcow2  nsd02.qcow2
[root@room12pc8 ~]# mkdir /xmlfin 
[root@room12pc8 images]# virsh dumpxml nsd01 > /xmlfile/yan.xml

2.修改nsd02配置文件
[root@room12pc8 ~]# vim /xmlfile/yan.xml
[root@room12pc8 ~]# uuidgen  #自动生成uid
  <name>nsd02</name>  #修改
  <source file='/var/lib/libvirt/images/nsd02-1.qcow2'/>  #修改
<uuid>3087ffbb-b863-46a2-8dfc-7b75333846dd</uuid>  #删除这个行
 <mac address='52:54:00:57:6b:95'/>   #删除这个行

3.导入虚拟机
[root@room12pc8 ~]# virsh define /xmlfile/yan.xml  #生成虚拟机
[root@room12pc8 ~]# virsh start nsd03 #开机测试
[root@room12pc8 images]# virsh undefine nsd02 #删除生成的虚拟机

第二种方法
[root@room12pc8 ~]# cd /var/lib/libvirt/images/
[root@room12pc8 images]# cp nsd01.qcow2 nsd04.qcow2
[root@room12pc8 images]# virsh edit nsd01  #nsd01要存在
  <name>nsd02</name>  #修改
  <source file='/var/lib/libvirt/images/nsd02-1.qcow2'/>   #修改
<uuid>3087ffbb-b863-46a2-8dfc-7b75333846dd</uuid>  #删除此行
 <mac address='52:54:00:57:6b:95'/>   #删除此行

=============================================================================
COW技术原理
 qemu-img info  
 qemu-img create

[root@room12pc8 ~]# qemu-img info /var/lib/libvirt/images/nsd01.qcow2  #查看虚拟机休息

通过写时复制技术,生成虚拟机zhai01
1.以虚拟机nsd01磁盘文件为原始盘,产生zhai01虚拟机的前端盘
qemu-img create -f qcow2 -b 原始盘 前端盘 前端盘大小
例:
[root@room12pc8 ~]# qemu-img create -f qcow2 -b /var/lib/libvirt/images/nsd01.qcow2  /var/lib/libvirt/images/zhai01.qcow2 10G
前端盘大小最好大于原端盘

2.以前端盘zhai01.qcow2产生虚拟机zhai01
[root@room12pc8 ~]# qemu-img info /var/lib/libvirt/images/zhai01.qcow2 #查看虚拟机休息
[root@room12pc8 ~]# cd /var/lib/libvirt/images/
[root@room12pc8 images]# cp nsd01-1.qcow2 zhai01-1.qcow2
[root@room12pc8 ~]# virsh edit nsd01
  <name>nsd02</name>  #修改
  <source file='/var/lib/libvirt/images/nsd02-1.qcow2'/>   #修改
<uuid>3087ffbb-b863-46a2-8dfc-7b75333846dd</uuid>  #删除此行
 <mac address='52:54:00:57:6b:95'/>   #删除此行

[root@room12pc8 ~]# virt-manager  #打开虚拟机管理系统

==============================================================================
离线访问虚拟机

离线访问虚拟机的磁盘文件的内容
guestmount -a 虚拟机磁盘路径 -i /挂载点
例: 
[root@room12pc8 ~]# guestmount -a /opt/zhai03-1.qcow2 -i /mnt/zhai
[root@room12pc8 ~]# ls /mnt/zhai

==============================================================================
教学环境

虚拟机A:
LANG=en growpart /dev/vda
例:
[root@svr7 ~]# LANG=en growpart /dev/vda 1  #扩展/dev/vda磁盘的第一个分区空间
[root@svr7 ~]# xfs_growfs /dev/vda1    #扩展/dev/vda1文件系统

[root@svr7 ~]# df -Th
[root@svr7 ~]# lsblk

==============================================================================

service_day03=================================================================================================

新教学环境的搭建

一 构建两台虚拟机
真机上运行:
                                           
     虚拟机A
        1.为eth0配置IP地址:192.168.4.7/24
        2.配置主机名:svr7.tedu.cn
     虚拟机B
        1.为eth0配置IP地址:192.168.4.207/24
        2.配置主机名:pc207.tedu.cn

##########################################################
DNS服务基础

• DNS服务器的功能
– 正向解析:根据注册的域名查找其对应的IP地址
– 反向解析:根据IP地址查找对应的注册域名,不常用


一级DNS服务器    二级DNS服务器    三级DNS服务器

   所有有的域名都必须以点结尾

   www.qq.com.    www.baidu.com.

根域:                                . 点

一级域名:       .cn    .us     .tw    .hk    .kr    .jp 


二级域名:   .com.cn     .net.cn    .org.cn  .......

  
三级域名:   haxi.com.cn    nb.com.cn   dc.com.cn  .......

        

• Full Qualified Domain Name(FQDN),完全合格主机名

     主机头部,正确申请的域名结尾

   vip.nb.com.cn   www.nb.com.cn  tts.nb.com.cn 


####################################################
搭建Web服务器,此网站的FQDN为www.sina.com

####################################################
• BIND服务器端程序
– 主要执行程序:/usr/sbin/named
– 系统服务:named
– 默认端口:TCP/UDP 53
– 运行时的虚拟根环境:/var/named/chroot/

• 主配置文件:/etc/named.conf    #设置本机负责解析的域名    tedu.cn
• 地址库文件:/var/named/        #完全合格的域名与IP地址的对应关系

##################################################
虚拟机A构建基本DNS服务
1.安装软件包 bind  bind-chroot
bind-9.9.4-29.el7.x86_64  //域名服务包
bind-chroot-9.9.4-29.el7.x86_64  //提供虚拟根支持(牢笼政策)

2.修改主配置文件
[root@svr7 ~]# cp /etc/named.conf  /etc/named.bak
[root@svr7 ~]# vim /etc/named.conf 
options {
        directory       "/var/named";   #地址库文件存放位置
};
zone "tedu.cn" IN {           #指定负责解析域名
        type master;          #指定为权威主服务器
        file "tedu.cn.zone";  #指定地址库文件名称
};      

3.建立相应的地址库文件
[root@svr7 ~]# cd /var/named
[root@svr7 named]# cp -p named.localhost  tedu.cn.zone
    -p:保持源文件权限不变进行复制

[root@svr7 named]# ls -l tedu.cn.zone
[root@svr7 named]# vim  tedu.cn.zone
 所有的域名都必须以点结尾,都要写最后的点
  没有以点结尾,默认补全本地址库文件负责的域名

 tedu.cn.      NS  svr7        #声明负责解析tedu.cn域名为svr7主机
 svr7          A   192.168.4.7 #声明svr7主机的IP地址为192.168.4.7
 www           A   192.168.4.1 #正常解析记录
 ftp           A   192.168.4.2 #正常解析记录

4.重启named服务
[root@svr7 ~]# systemctl restart named

虚拟机B:
1.指定DNS服务器位置
  /etc/resolv.conf   #指定DNS服务器地址配置文件

]# echo nameserver  192.168.4.7  >  /etc/resolv.conf 
]# cat /etc/resolv.conf

2.测试DNS解析命令
]# nslookup www.tedu.cn
  
#########################################################
虚拟机A负责qq.com域名解析
1.修改主配置文件/etc/named.conf 
......
zone "qq.com" IN {
        type master;
        file "qq.com.zone";
};
2.建立地址库文件
[root@svr7 /]# cd /var/named/
[root@svr7 named]# cp -p  tedu.cn.zone   qq.com.zone
[root@svr7 named]# vim  qq.com.zone
 qq.com.        NS  svr7
 svr7	       A   192.168.4.7
 www            A   1.1.1.1
 ftp            A   2.2.2.2
[root@svr7 /]# !sys
systemctl restart named
[root@svr7 /]# 
#######################################################
特殊的解析记录
1.基于域名的负载均衡
[root@svr7 /]# vim /var/named/tedu.cn.zone 
tedu.cn.       NS  svr7
svr7           A  192.168.4.7
www            A  192.168.4.11
www            A  192.168.4.12
www            A  192.168.4.13
ftp            A  192.168.4.2

[root@svr7 /]# systemctl restart named

2.泛域名解析
[root@svr7 /]# vim /var/named/tedu.cn.zone 
tedu.cn.       NS  svr7
svr7           A   192.168.4.7
www            A   192.168.4.11
ftp            A   192.168.4.2
tedu.cn.       A   10.20.30.40
*              A   1.2.3.4

[root@svr7 /]# !sys
systemctl restart named
[root@svr7 /]# 

虚拟机B客户端测试: 
   nslookup hahahaha.tedu.cn
   nslookup tedu.cn

3.有规律的泛域名解析
          pc1.tedu.cn ------> 192.168.10.1
          pc2.tedu.cn ------> 192.168.10.2
          pc3.tedu.cn ------> 192.168.10.3
                  .......
          pc50.tedu.cn ------> 192.168.10.50

内置函数: $GENERATE   起始-结束     #制造连续范围的数字

[root@svr7 ~]# vim /var/named/tedu.cn.zone 
.......
$GENERATE  1-50  pc$   A  192.168.10.$

[root@svr7 ~]# !sys
systemctl restart named
[root@svr7 ~]# 

4.解析记录的别名
[root@svr7 ~]# vim /var/named/tedu.cn.zone 
.......
tts            CNAME     ftp

[root@svr7 ~]# !sys
systemctl restart named

虚拟机B客户端测试: 
[root@pc207 ~]# nslookup tts.tedu.cn
Server:		192.168.4.7
Address:	192.168.4.7#53

tts.tedu.cn	canonical name = ftp.tedu.cn.
Name:	ftp.tedu.cn
Address: 192.168.4.2

[root@pc207 ~]# 
#########################################################
DNS服务器的资源解析记录类型?
   NS     声明DNS服务器记录
   A      地址解析记录
   CNAME  解析记录别名

##########################################################


/etc/resolv.conf   #指定DNS服务器位置

客户端解析域名优先级
1./etc/hosts       #直接提供解析结果,只为本机提供服务
2./etc/resolv.conf  #寻找DNS服务器解析


[root@svr7 ~]# vim /etc/hosts 
......
192.168.4.4    www.360.com

[root@svr7 ~]# ping  www.360.com

#####################################################
DNS子域授权

     父域:www.qq.com
     子域:www.bj.qq.com

  虚拟机A负责解析qq.com域名
  虚拟机B负责解析bj.qq.com域名

虚拟机B:搭建为DNS服务器,负责解析的域名为bj.qq.com
[root@pc207 ~]# yum -y install bind bind-chroot
[root@pc207 ~]# cp /etc/named.conf /etc/named.bak
[root@pc207 ~]# vim /etc/named.conf 
 options {
        directory       "/var/named";
  };      
 zone "bj.qq.com" IN {
        type master;
        file "bj.qq.com.zone";
  };      
[root@pc207 ~]# cd /var/named/
[root@pc207 named]# cp -p named.localhost bj.qq.com.zone
[root@pc207 named]# vim bj.qq.com.zone
bj.qq.com.      NS      pc207
pc207           A       192.168.4.207
www             A       50.60.70.80
[root@pc207 /]# systemctl restart named
[root@pc207 /]# nslookup  www.bj.qq.com  192.168.4.207




子域授权

    虚拟机A负责解析qq.com域名
    虚拟机B负责解析bj.qq.com域名

    解析子域的域名,请求虚拟机A,可以解析
虚拟机A:
[root@svr7 ~]# vim /var/named/qq.com.zone 
 qq.com.       NS  svr7
 bj.qq.com.    NS  pc207
 svr7           A  192.168.4.7
 pc207          A  192.168.4.207
 www            A  192.168.4.10
 ftp            A  2.2.2.2
[root@svr7 ~]# systemctl restart named
[root@pc207 /]# nslookup www.bj.qq.com 192.168.4.7
Server:		192.168.4.7
Address:	192.168.4.7#53

Non-authoritative answer:   #非权威解答
Name:	www.bj.qq.com
Address: 50.60.70.80
[root@pc207 /]# 

递归解析:
   接受客户端解析请求,本机与其他DNS服务器交流,最终将解析结果带回来的过程

[root@svr7 ~]# vim /etc/named.conf   
options {
        directory       "/var/named";
        recursion no;
};


迭代解析:本机与其他DNS服务器交流


#######################################################
验证迭代查询
• dig命令,更专业的DNS测试工具
– 由软件包 bind-utils 提供
– 格式: dig @DNS服务器 目标地址
[root@svr7 ~]# dig www.bj.qq.com 192.168.4.7


###################################################
缓存DNS,提高解析效率

     虚拟机C
        1.为eth0配置IP地址:192.168.4.10/24
        2.配置主机名:C.tedu.cn
        3.使用真机FTP构建Yum仓库

#####################################################
虚拟机A:真DNS服务器
虚拟机B上操作,搭建缓存DNS服务器
虚拟机C:客户端
#####################################################
虚拟机B上操作
[root@pc207 /]# vim /etc/named.conf 
options {
        directory       "/var/named";
        forwarders  { 192.168.4.7; };  #转发给192.168.4.7
};
[root@pc207 /]# systemctl restart named

虚拟机C:做测试:
[root@C ~]# nslookup ftp.tedu.cn 192.168.4.207
Server:		192.168.4.207
Address:	    192.168.4.207#53

Non-authoritative answer:
Name:	ftp.tedu.cn
Address: 192.168.4.2

########################################################

==============================================================
NDS服务基础

 DNS解析的作用
     正向解析: 根据注册的域名查找其对应的IP地址
     反向解析: 根据IP地址查找对应的注册域名,不常用

所有的域名都必须以点结尾
一级域名:　 .cn  .us  .tw  .hk  .kr  .jp
二级域名: 　.com.cn  .net.cn  .org  .cn
三级域名: 　zhai.com.cn   hahx.com.cn  quan.com.cn

虚拟机A构建基本DNS服务:
BIND域名服务　
服务软件：bind-chront bind
系统服务：named

1.
[root@svr7 ~]# yum -y install  bind-chront bind　　＃安装服务包
[root@svr7 ~]# rpm -qa bind*
bind-9.9.4-61.el7.x86_64　　　　　　＃提供域名服务包
bind-chroot-9.9.4-61.el7.x86_64　　＃提供安全机制

主配置文件：/etc/named.conf  #设置本机负责解析的域名　　tedu.cn
地址库文件：/var/named       #完全合格的域名与IP地址对应的关系 

2.修改主配置文件
[root@svr7 ~]# vim /etc/named.conf
options {
        directory       "/var/named";
          rec
};

zone "tedu.cn" IN {
        type master;   #master权威服务器
        file "tedu.cn.zone";
};

zone "qq.com" IN {
        type master;
        file "qq.com.zone";
};


3.建立相应的地址库文件
[root@svr7 ~]# cd /var/named
[root@svr7 named]# cp -p named.localhost tedu.cn.zone
[root@svr7 named]# cp -p tedu.cn.zone qq.com.zone

[root@svr7 named]# vim tedu.cn.zone 
tedu.cn.        NS      svr7   #名自定义,上下要一致
svr             A       192.168.4.7
www             A       127.0.0.1
ftp             A       192.168.8.9
*               A       192.168.8.12   #匹配所有,如 www.tedu.cn   werew.tedu.cn
$GENERATE 1-50 pc$ A 192.168.10.$      
tts          CNAME     ftp   #或tts A 192.168.8.9  ,#tts和ftp解析结果都是192.168.8.9


[root@svr7 named]# vim qq.com.zone
qq.com.         NS      svr7
svr7            A       192.168.4.7
www             A       152.0.0.8
ftp             A       1.1.6.1
*               A       192.168.1.55     #匹配所有,如 www.qq.com   werew.qq.com

4.重启named服务
[root@svr7 ~]# systemctl restart named
[root@svr7 ~]# systemctl enable  named

虚拟机B:
1.指定DNS服务器位置
/etc/resolv.conf #指定DNS服务器位置地址配置文件
[root@pc207 ~]# echo nameserver 192.168.4.7 > /etc/resolv.conf
[root@pc207 ~]# cat  /etc/resolv.conf

2.测试DNS服务命令
[root@pc207 ~]# vim /etc/resolv.conf   #在客户端添加服务端IP地址
nameserver 192.168.4.7
[root@pc207 ~]# nslookup www.tedu.cn
或
[root@pc207 ~]# nslookup www.tedu.cn  192.168.4.7


特殊的解析记录
1.基于域名的负载
*      A       192.168.8.12   #匹配所有,如 www.tedu.cn   werew.tedu.cn

2.有规律的泛域名解析
     pc1.tedu.cn    A     192.168.1
     pc2.tedu.cn    A     192.168.2
     pc3.tedu.cn    A     192.168.3
     pc4.tedu.cn    A     192.168.4
     pc5.tedu.cn    A     192.168.5
     pc6.tedu.cn    A     192.168.6
      或
    $GENERATE 1-6 pc$ A 192.168.10.$

====================================================
DNS服务器的资源记录类型?
NS       #声明DNS服务器记录
A        #地址解析记录
CNAME    #解析记录别名

客户器解析域名优选级
1. /etc/hosts  #直接提供解析结果(只能为本机服务)168.4.90
2. /etc/resolv.conf #寻找DNS服务器解析

例:
[root@svr7 ~]# vim /etc/hosts
192.168.4.7     www.360.com
[root@svr7 ~]# ping www.360.com

====================================================
DNS子域授权


====================================================
缓存DNS服务器
    作用: 提高解析速度 

service_day04=================================================================================================

虚拟机A负责sina.com域名解析
1.修改主配置文件/etc/named.conf 
......
 zone "sina.com" IN {
        type master;
        file "sina.com.zone";
 };
2.建立地址库文件
[root@svr7 /]# cd /var/named/
[root@svr7 named]# cp -p  tedu.cn.zone   sina.com.zone
[root@svr7 named]# vim  sina.com.zone
  sina.com.        NS  svr7
  svr7	          A   192.168.4.7
  www              A   1.1.1.1

[root@svr7 /]# !sys
systemctl restart named
##########################################################
Split分离解析(视图解析)

分离解析概述

什么是分离解析
• 当收到客户机的DNS查询请求的时候
– 能够区分客户机的来源地址
– 为不同类别的客户机提供不同的解析结果(IP地址)

– 为客户端提供最近服务器IP地址


BIND的view视图
• 根据源地址集合将客户机分类
– 不同客户机获得不同结果(待遇有差别)

	view "联通" {
	match-clients {  来源地址1;   .. ..;  };
	zone "12306.cn" IN {
	...... 地址库1;
	}; };
	view "铁通" {
	match-clients {  来源地址2;   .. .. ;  };
	zone "12306.cn" IN {
	...... 地址库2;
	}; };

###########################################################
注意事项:
1.由上到下进行,匹配及停止
2.分类要合理,每一个客户端都要找到自己的分类
3.所有的zone必须都在view中
	view "nsd" {
	match-clients {  192.168.4.1;   };  #匹配客户端来源地址
	zone "tedu.cn" IN {
	......tedu.cn.zone;
	 }; 
        };

	view "haha" {
	match-clients {  any;  };  #匹配客户端来源地址
	zone "tedu.cn" IN {
	...... tedu.cn.haha;
	  };
        };


 案例需求及要点
• 环境及需求
– 权威DNS:svr7.tedu.cn 192.168.4.7
– 负责区域:tedu.cn
– A记录分离解析 —— 以 www.tedu.cn 为例
客户机来自 解析结果
	192.168.4.207------------> 192.168.4.100
	其他地址------------> 1.2.3.4                                   

虚拟机A操作:
[root@svr7 /]# vim /etc/named.conf 
    options {
        directory       "/var/named";
        };
	view "nsd" {
	 match-clients {  192.168.4.207;   };  #匹配客户端来源地址
	 zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";  ---->解析结果为 192.168.4.100
	 }; 
        };
	view "other" {
	 match-clients {  any;  };  #匹配客户端来源地址
	 zone "tedu.cn" IN {
        type master;
        file "tedu.cn.other";  ---->解析结果为 1.2.3.4
	  };
        };


##########################################################
 案例需求及要点
• 环境及需求
– 权威DNS:192.168.4.7
– 负责区域: tedu.cn  sina.com 
– A记录分离解析 —— 以  www.tedu.cn  www.sina.com 为例
客户机来自 解析结果
	192.168.4.207-----www.tedu.cn-------> 192.168.4.100
	其他地址-----www.tedu.cn------->1.2.3.4 
                                  
	192.168.4.207-----www.sina.com-------> 192.168.4.200
	其他地址-----www.sina.com------->10.20.30.40 

注意事项:每一个view中zone的个数保持一致
view "nsd" {
  match-clients { 192.168.4.207; };
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";---->解析结果为 192.168.4.100
  };
  zone "sina.com" IN {
        type master;
        file "sina.com.zone";---->解析结果为 192.168.4.200
  };
};
view "other" {
  match-clients { any; };
  zone "tedu.cn" IN {
        type master;
        file "tedu.cn.other"; ---->解析结果为 1.2.3.4
  };
  zone "sina.com" IN {
        type master;
        file "sina.com.other";---->解析结果为 10.20.30.40
  };
};
   
####################################################
补充分离解析  acl test  { ; ; };

acl test { 192.168.4.207; 192.168.4.1; 192.168.4.2; };

view "nsd" {
  match-clients { test; };
..........

##################################################
RAID阵列概述
• 廉价冗余磁盘阵列
– Redundant Arrays of Inexpensive Disks
– 通过硬件/软件技术,将多个较小/低速的磁盘整合成一个大磁盘

– 阵列的价值:提升I/O效率、硬件级别的数据冗余
– 不同RAID级别的功能、特性各不相同

• RAID 0,条带模式
– 同一个文档分散存放在不同磁盘
– 并行写入以提高效率
– 至少需要两块磁盘组成

• RAID 1,镜像模式
– 一个文档复制成多份,分别写入不同磁盘
– 多份拷贝提高可靠性,效率无提升
– 至少需要两块磁盘组成

• RAID5,高性价比模式
– 相当于RAID0和RAID1的折中方案
– 需要至少一块磁盘的容量来存放校验数据
– 至少需要三块磁盘组成

• RAID6,高性价比/可靠模式
– 相当于扩展的RAID5阵列,提供2份独立校验方案
– 需要至少两块磁盘的容量来存放校验数据
– 至少需要四块磁盘组成

• RAID 0+1/RAID 1+0
– 整合RAID 0、RAID 1的优势
– 并行存取提高效率、镜像写入提高可靠性
– 至少需要四块磁盘组成
###################################################
进程管理

   程序: 静态的代码   占用磁盘空间

   进程: 动态的代码   占用  CPU  内存

   进程整体也是树型结果
   父进程与子进程          特殊进程:僵尸进程   孤儿进程

   进程唯一编号: PID

###################################################
查看进程树
• pstree — Processes Tree
– 格式:pstree [选项] [PID或用户名]

• 常用命令选项
– -a:显示完整的命令行
– -p:列出对应PID编号

   systemd:所有进程的父进程,上帝进程

[root@svr7 ~]# useradd lisi
[root@svr7 ~]# pstree           #查看整个进程树信息
[root@svr7 ~]# pstree lisi
bash───vim
[root@svr7 ~]# pstree -p lisi    #-p:列出对应PID编号
bash(31421)───vim(31454)
[root@svr7 ~]# pstree -ap lisi   #-a:显示完整的命令行
bash,31421
  └─vim,31454 a.txt
[root@svr7 ~]#


查看进程快照
• ps — Processes Snapshot
– 格式:ps [选项]...
• 常用命令选项
– aux:显示当前终端所有进程(a)、当前用户在所有
终端下的进程(x), 以用户格式输出(u)

– -elf:显示系统内所有进程(-e)、以长格式输出(-l)
信息、包括最完整的进程信息(-f)

• ps aux 操作
– 列出正在运行的所有进程

• ps -elf 操作
– 列出正在运行的所有进程,PPID:父进程的PID号


统计命令: wc -l  文件    #统计文件内容有多少行
[root@svr7 ~]#  wc -l /etc/passwd
统计正在运行的进程有多少个?
[root@svr7 ~]# ps aux  | wc -l

[root@svr7 ~]# ps -elf | wc -l

[root@svr7 ~]# ps aux                  

[root@svr7 ~]# ps -elf

请统计/etc目录下有多少个以".conf"结尾的文档?
[root@svr7 ~]# find /etc/ -name '*.conf' | wc -l
153
[root@svr7 ~]# 

[root@svr7 ~]# find /etc/ -name '*tab' | wc -l
9
[root@svr7 ~]# 

################################################
进程动态排名
• top 交互式工具
– 格式:top [-d 刷新秒数] [-U 用户名]

[root@svr7 ~]# top -d 1
  按键盘  P(大写)  按CPU占用排序
  按键盘  M(大写)  按内存占用排序


检索进程
• pgrep — Process Grep
– 用途:pgrep [选项]... 查询条件

• 常用命令选项
– -l:输出进程名,而不仅仅是 PID
– -U:检索指定用户的进程
– -x:精确匹配完整的进程名

[root@svr7 ~]# pgrep -l a
[root@svr7 ~]# pgrep -l crond

[root@svr7 ~]# pgrep -U  lisi
[root@svr7 ~]# pgrep -lU  lisi

[root@svr7 ~]# pgrep -x  named
[root@svr7 ~]# pgrep -xl  named

#################################################
控制进程

进程的前后台调度
• 正在运行放入后台:
  在命令行末尾添加“&”符号,不占用当前终端
• Ctrl + z 组合键
– 挂起当前进程(暂停并转入后台)
• jobs 命令
– 查看后台任务列表
• fg 命令
– 将后台任务恢复到前台运行
• bg 命令
– 激活后台被挂起的任务


[root@svr7 ~]# sleep 800 &  #正在运行放入后台
[root@svr7 ~]# jobs         ＃查看后台进程信息
[root@svr7 ~]# sleep 900 
^Z      　　#按键盘上Ctrl+z暂停放入后台
[2]+  已停止               sleep 900
[root@svr7 ~]# jobs 
[root@svr7 ~]# bg 2　　　＃让后台编号为２的进程　继续运行
[root@svr7 ~]# jobs 

[root@svr7 ~]# fg 1　　　＃让后台编号为１的进程　恢复到前台　　
sleep 800
^C　　　　#按键盘上Ctrl+ｃ暂停放入后台
[root@svr7 ~]# jobs
[root@svr7 ~]# fg 2　　　＃让后台编号为２的进程　恢复到前台
sleep 900
^C
[root@svr7 ~]# jobs
 
################################################
杀死进程
• 干掉进程的不同方法
– Ctrl+c 组合键,中断当前命令程序
– kill [-9] PID... 、kill [-9] %后台任务编号
– killall [-9] 进程名...
– pkill 查找条件

[root@svr7 ~]# sleep 1000 & 
[root@svr7 ~]# sleep 2000 & 
[root@svr7 ~]# sleep 3000 & 
[root@svr7 ~]# sleep 4000 & 

[root@svr7 ~]# jobs 
[root@svr7 ~]# jobs -l                 

[root@svr7 ~]# kill 3083
[root@svr7 ~]# jobs -l
[root@svr7 ~]# kill -9 3086
[root@svr7 ~]# jobs -l

[root@svr7 ~]# killall sleep
[root@svr7 ~]# jobs -l

################################################
杀死一个用户开启的所有进程（强制踢出一个用户）
[root@svr7 ~]# killall -9 -u lisi

################################################
日志管理
日志的功能
• 系统和程序的“日记本”
– 记录系统、程序运行中发生的各种事件
– 通过查看日志,了解及排除故障
– 信息安全控制的“依据”

• 由系统服务rsyslog统一记录/管理
　时间、地点、人物、发生何事


常见的日志文件
日志文件

　/var/log/messages 	记录内核消息、各种服务的公共消息
　/var/log/dmesg 		记录系统启动过程的各种消息
　/var/log/cron 		记录与cron计划任务相关的消息
　/var/log/maillog 	记录邮件收发相关的消息
　/var/log/secure 	记录与访问限制相关的安全消息
	
日志分析

• 通用分析工具
– tail、tailf、less、grep等文本浏览/检索命令

　tailf：跟踪日志消息

[root@svr7 ~]# echo 　123 　> 　/opt/1.txt
[root@svr7 ~]# cat 　/opt/1.txt
123
[root@svr7 ~]# tailf　 /opt/1.txt
123

#################################################s
用户登录分析
• users、who、w 命令
– 查看已登录的用户信息,详细度不同

• last、lastb 命令
– 查看最近登录成功/失败的用户信息

[root@svr7 ~]# users
[root@svr7 ~]# who
[root@svr7 ~]# w

[root@svr7 ~]# last   -2   #最近登录成功
[root@svr7 ~]# lastb   -2　　#最近登录失败

###############################################

日志消息的优先级
• Linux内核定义的事件紧急程度
– 分为 0~7 共8种优先级别
– 其数值越小,表示对应事件越紧急/重要

  0  EMERG（紧急）          会导致主机系统不可用的情况
  1  ALERT（警告）          必须马上采取措施解决的问题
  2  CRIT（严重）	        比较严重的情况
  3  ERR（错误）	       运行出现错误
  4  WARNING（提醒）      可能会影响系统功能的事件
  5  NOTICE（注意）        不会影响系统但值得注意
  6  INFO（信息）	       一般信息
  7  DEBUG（调试）          程序或系统调试信息等

####################################################

使用journalctl工具
• 提取由 systemd-journal 服务搜集的日志
– 主要包括内核/系统日志、服务日志
• 常见用法
– journalctl | grep 关键词
– journalctl -u 服务名       [-p 优先级]
– journalctl -n 消息条数
– journalctl --since="yyyy-mm-dd HH:MM:SS" --
until="yyyy-mm-dd HH:MM:SS"


[root@svr7 ~]# journalctl -u httpd
[root@svr7 ~]# journalctl -xe  #显示服务最近的报错信息
#####################################################
systemd介绍
• Linux系统和服务管理器
– 是内核引导之后加载的第一个初始化进程(PID=1)
– 负责掌控整个Linux的运行/服务资源组合

• 一个更高效的系统&服务管理器
– 开机服务并行启动,各系统服务间的精确依赖
– 配置目录:/etc/systemd/system/
– 服务目录:/lib/systemd/system/
– 主要管理工具:systemctl


对于服务的管理
 systemctl restart  服务名    #重起服务
 systemctl start    服务名    #开启服务
 systemctl stop     服务名    #停止服务
 systemctl status   服务名    #查看服务当前的状态
 
 systemctl enable   服务名      #设置服务开机自启动
 systemctl disable  服务名      #设置服务不开机自启动


RHEL6 运行级别    
  
         0：关机    
         1：单用户模式（基本功能的实现，破解Linux密码）
	 2：多用户字符界面（不支持网络）    
	 3：多用户字符界面（支持网络）服务器默认的运行级别   
	 4：未定义
	 5：图形界面   
	 6：重起 
   
    切换运行级别：init  5   


RHEL7 运行模式 

   字符模式：multi-user.target
   图形模式：graphical.target
[root@svr7 /]# ls -l /lib/systemd/system/

当前直接切换到字符模式
[root@svr7 /]# systemctl isolate multi-user.target
或
[root@zyq ~]# init 3

当前直接切换到图形模式
[root@svr7 /]# systemctl isolate graphical.target
或
[root@zyq ~]# init 5

查看每次开机默认进入模式
[root@svr7 /]# systemctl get-default  #查看默认级别
graphical.target

设置永久策略，每次开机自动进入graphical.target
]# systemctl set-default multi-user.target
]# reboot 
例:
设置默认级别
[root@zyq ~]# systemctl set-default multi-user.target  #设置默认图形级别
[root@zyq ~]# systemctl set-default graphical.target   #设置默认字符级别

#################################################

================================================================
Split分离解析(视图解析)
    当收到客户机的DNS查询请求的时候
    能够区分客户机的来源地址
    为不同类别的客户机提供不同的解析结果(IP地址)

注意事项: 
1.由上到下进行,匹配即停止
2.分类要合理, 每一个客户端都要找到自己的分类

虚拟机A操作

1.修改主配置文件
[root@svr7 ~]# vim /etc/named.conf
options {
        directory       "/var/named";
       forwarders { 192.168.4.207; };
};

view "nsd" {
match-clients { 192.168.4.207; };  #192.168.4.207是客户机的IP地址
zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";
};
 };

view "other" {
match-clients { any; };  #所有来源地址
zone "tedu.cn" IN {
        type master;
        file "tedu.cn.other";
};
 };

2.修改地址库文件
[root@svr7 ~]# cd /var/named
[root@svr7 named]# cp -p tedu.cn.zone tedu.cn.other
[root@svr7 named]# vim  tedu.cn.other   
tedu.cn.        NS      svr
svr             A       192.168.4.7
www             A       1.2.3.4
[root@svr7 named]# vim tedu.cn.zone
tedu.cn.        NS      svr
svr             A       192.168.4.7
www             A       10.20.30.40

[root@svr7 ~]# nslookup www.tedu.cn   #在本机解析
[root@pc207 ~]# nslookup www.tedu.cn  #在客户机解析

综合练习
修改主配置文件
[root@svr7 ~]# vim /etc/named.conf
options {
       directory       "/var/named";
       forwarders { 192.168.4.207; };
};

view "nsd" {
match-clients { 192.168.4.207; };
zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";
};
zone "sina.com" IN {
        type master;
        file "sina.com.zone";
   };
};
 
view "other" {
match-clients { any; };
zone "tedu.cn" IN {
        type master;
        file "tedu.cn.other";
};
zone "sina.com" IN {
        type master;
        file "sina.com.other";
  };
};


[root@svr7 ~]# cd /var/named
[root@svr7 named]# cp -p tedu.cn.zone sina.com.zone
[root@svr7 named]# cp -p tedu.cn.other sina.com.other
修改sina地址库文件
[root@svr7 named]# vim  sina.com.zone
sina.com.       NS      sinasvr7
sinasvr7        A       192.168.4.7
www             A       192.168.4.200
[root@svr7 named]# vim  sina.com.other
sina.com.       NS      svr7
svr7            A       192.168.4.7
www             A       11.22.33.44

==========================================================
分离解析的acl
   acl是变量: 以不变的名称,而值可能会变化的量

acl test { ;  ; };
例:
主配置文件
[root@svr7 ~]# vim /etc/named.conf
acl test { 192.168.4.207; 192.168.4.7; } ;

view "nsd" {
match-clients { test; };
zone "tedu.cn" IN {
        type master;
        file "tedu.cn.zone";
};
zone "sina.com" IN {
        type master;
        file "sina.com.zone";
};
 };

==========================================================
RAID阵列概述

• 廉价冗余磁盘阵列
– Redundant Arrays of Inexpensive Disks
– 通过硬件/软件技术,将多个较小/低速的磁盘整合成一个大磁盘

– 阵列的价值:提升I/O效率、硬件级别的数据冗余
– 不同RAID级别的功能、特性各不相同

• RAID 0,条带模式
– 同一个文档分散存放在不同磁盘
– 并行写入以提高效率
– 至少需要两块磁盘组成

• RAID 1,镜像模式
– 一个文档复制成多份,分别写入不同磁盘
– 多份拷贝提高可靠性,效率无提升
– 至少需要两块磁盘组成

• RAID5,高性价比模式
– 相当于RAID0和RAID1的折中方案
– 需要至少一块磁盘的容量来存放校验数据
– 至少需要三块磁盘组成

• RAID6,高性价比/可靠模式
– 相当于扩展的RAID5阵列,提供2份独立校验方案
– 需要至少两块磁盘的容量来存放校验数据
– 至少需要四块磁盘组成

• RAID 0+1/RAID 1+0
– 整合RAID 0、RAID 1的优势
– 并行存取提高效率、镜像写入提高可靠性
– 至少需要四块磁盘组成
  
==========================================================
进程管理

程序: 静态代码,占用磁盘空间
   查看进程
   
进程: 动态的代码,占用CPU和内存
进程整体也是树形结构: 父进程与子进程
特殊进程: 僵尸进程  孤儿进程
进程唯一编号: PID

查看进程树
systemd: 所有进程的父进程,上帝进程.
-a: 显示完整的命令行
-p: 列出对应PID编号
例:
[root@svr7 ~]# pstree -p
[root@svr7 ~]# pstree lisi #查看用户lisi开了哪些进程
bash───vim
[root@svr7 ~]# pstree -p lisi #列出用户lisi对应PID编号
bash(6619)───vim(6684)
[root@svr7 ~]# pstree -pa lisi #显示完整的命令行
bash,6619
  └─vim,6684 a.txt

查看进程快照
ps 
格式: ps [选项]
例:
[root@svr7 ~]# ps aux  #显示当前终端所有进程
[root@svr7 ~]# ps -elf #显示系统内所有进程
[root@svr7 ~]# wc -l /etc/passwd #统计文件内容有多少行(统计所有用户)
[root@svr7 ~]# ps -elf | wc -l   #统计当前所有进程个数

================================================================
进程动态排名

top: 交互工具
格式: top [-d 刷新秒数] [-U 用户名]
[root@svr7 ~]# top
load average: 0.10, 0.15, 0.20 
                     1     5        15分钟
  按键盘  P(大写)  按CPU占用排序
  按键盘  M(大写)  按内存占用排序

================================================================
检索进程

pgrep: 
用途: pgrep [选项]... 查询条件
-l: 输出进程名,而不仅仅是PID
例:
[root@svr7 ~]# pgrep -l crond
486 crond
-U: 检索指定用户的进程
例:
[root@svr7 ~]# pgrep -U lisi
6619
-x: 精确匹配完整的进程名
例:
[root@svr7 ~]# pgrep -x named
4369

================================================================
控制进程

进程的前后台调度
• 正在运行放入后台:
  在命令行末尾添加“&”符号,不占用当前终端
• Ctrl + z 组合键
– 挂起当前进程(暂停并转入后台)
• jobs 命令
– 查看后台任务列表
• fg 命令
– 将后台任务恢复到前台运行
• bg 命令
– 激活后台被挂起的任务

[root@svr7 ~]# sleep 800 &  #正在运行放入后台
[root@svr7 ~]# jobs  #查看后天进程信息
[root@svr7 ~]# bg 1  #让后台编号为1的进程,继续运行
-bash: bg: 任务 1 已在后台
[root@svr7 ~]# fg 4  #让后台编号为3的进程,恢复的前台

==========================================================
杀死进程

• 干掉进程的不同方法
– Ctrl+c 组合键,中断当前命令程序
– kill [-9] PID... 、kill [-9] %后台任务编号
– killall [-9] 进程名...
– pkill 查找条件
例:
[root@svr7 ~]# jobs -l             #查看进程信息,包含进程编号
[root@svr7 ~]# kill 10382          #以进程编号为杀死进程
[root@svr7 ~]# killall -9 -u lisi  #强制杀死用户lisi所有进程
[root@svr7 ~]# pkill ab            #杀死包含a的所有进程

==========================================================
日志管理

日志的功能
• 系统和程序的“日记本”
– 记录系统、程序运行中发生的各种事件
– 通过查看日志,了解及排除故障
– 信息安全控制的“依据”

• 由系统服务rsyslog统一记录/管理
　时间、地点、人物、发生何事


常见的日志文件
日志文件

　/var/log/messages   记录内核消息、各种服务的公共消息
　/var/log/dmesg 	   记录系统启动过程的各种消息
　/var/log/cron 	   记录与cron计划任务相关的消息
　/var/log/maillog    记录邮件收发相关的消息
　/var/log/secure 	   记录与访问限制相关的安全消息
	
日志分析

• 通用分析工具
– tail、tailf、less、grep等文本浏览/检索命令

　tailf：跟踪日志消息

[root@svr7 ~]# echo 　123 　> 　/opt/1.txt
[root@svr7 ~]# cat 　/opt/1.txt
123
[root@svr7 ~]# tailf　 /opt/1.txt
123

==========================================================
用户登录分析

users,who,w命令: 查看已登录的用户信息,详细度不同
例:
[root@svr7 ~]# users
root
[root@svr7 ~]# who
root     pts/0        2019-04-24 14:00 (192.168.4.254)
[root@svr7 ~]# w
 16:35:59 up  7:49,  1 user,  load average: 0.00, 0.01, 0.05
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0    192.168.4.254    14:00    7.00s  0.14s  0.00s w

last,lastb命令
例:
[root@svr7 ~]# last  #查看所有登入记录
[root@svr7 ~]# last -2 #查看最近两条登入记录
[root@svr7 ~]# last -2 #查看最近两条登入失败记

==========================================================
日志消息的优先级

• Linux内核定义的事件紧急程度
– 分为 0~7 共8种优先级别
– 其数值越小,表示对应事件越紧急/重要

  0  EMERG（紧急）          会导致主机系统不可用的情况
  1  ALERT（警告）          必须马上采取措施解决的问题
  2  CRIT（严重）	        比较严重的情况
  3  ERR（错误）	       运行出现错误
  4  WARNING（提醒）      可能会影响系统功能的事件
  5  NOTICE（注意）        不会影响系统但值得注意
  6  INFO（信息）	       一般信息
  7  DEBUG（调试）          程序或系统调试信息等

==========================================================
使用journalctl工具
• 提取由 systemd-journal 服务搜集的日志
– 主要包括内核/系统日志、服务日志
• 常见用法
– journalctl | grep 关键词
– journalctl -u 服务名       [-p 优先级]
– journalctl -n 消息条数
– journalctl --since="yyyy-mm-dd HH:MM:SS" --
until="yyyy-mm-dd HH:MM:SS"

[root@svr7 ~]# journalctl -u httpd
[root@svr7 ~]# journalctl -xe  #显示服务最近的报错信息

==========================================================
systemd介绍
• Linux系统和服务管理器
– 是内核引导之后加载的第一个初始化进程(PID=1)
– 负责掌控整个Linux的运行/服务资源组合

• 一个更高效的系统&服务管理器
– 开机服务并行启动,各系统服务间的精确依赖
– 配置目录:/etc/systemd/system/
– 服务目录:/lib/systemd/system/
– 主要管理工具:systemctl

对于服务的管理
 systemctl restart  服务名    #重起服务
 systemctl start    服务名    #开启服务
 systemctl stop     服务名    #停止服务
 systemctl status   服务名    #查看服务当前的状态
 
 systemctl enable   服务名      #设置服务开机自启动
 systemctl disable  服务名      #设置服务不开机自启动(开机不自启)

RHEL6 运行级别    
  
         0：关机    
         1：单用户模式（基本功能的实现，破解Linux密码）
	 2：多用户字符界面（不支持网络）    
	 3：多用户字符界面（支持网络）服务器默认的运行级别   
	 4：未定义
	 5：图形界面   
	 6：重起 
   
    切换运行级别：init  5


RHEL7 运行模式 

   字符模式：multi-user.target
   图形模式：graphical.target
[root@svr7 /]# ls -l /lib/systemd/system/

当前直接切换到字符模式
[root@svr7 /]# systemctl isolate multi-user.target
当前直接切换到图形模式
[root@svr7 /]# systemctl isolate graphical.target

查看每次开机默认进入模式
[root@svr7 /]# systemctl get-default
graphical.target

设置永久策略，每次开机自动进入graphical.target
# systemctl set-default multi-user.target
# reboot 

==========================================================
当前直接切换到字符模式
[root@server0 ~]# systemctl isolate multi-user.target 
当前直接切换到图形模式
[root@server0 ~]# systemctl isolate graphical.target 
查看每次开机默认进入模式
[root@server0 ~]# systemctl get-default 
设置永久策略,每次开机自动进入
[root@server0 ~]# systemctl set-default multi-user.target 

service_day05=================================================================================================

部署DHCP服务器

DHCP概述及原理
• Dynamic Host Configuration Protocol
– 动态主机配置协议,由 IETF(Internet 网络工程师任
务小组)组织制定,用来简化主机地址分配管理

• 主要分配以下入网参数
– IP地址/子网掩码/广播地址
– 默认网关地址、DNS服务器地址

DHCP原理：　广播进行，先到先得，一个网络里只能有一个DHCP服务器

• DHCP地址分配的四次会话
– DISCOVERY --> OFFER --> REQUEST -->ACK


开机启动项:匹配即停止
 1.本机硬盘    2.光驱设备    3.U盘    4.网络

虚拟机Ａ：
1.装软件包 dhcp
[root@svr7 /]# yum -y install dhcp
2.配置文件 /etc/dhcp/dhcpd.conf
vim末行模式  :r  /usr/share/doc/dhcp*/dhcpd.conf.example

subnet 192.168.4.0 netmask 255.255.255.0 {  #分配的网段
  range 192.168.4.100  192.168.4.200;      #分配的IP范围
  option domain-name-servers  192.168.4.7; #分配DNS服务器
  option routers 192.168.4.254;            #分配网关地址
  default-lease-time 600;
  max-lease-time 7200;
} 

[root@svr7 /]# systemctl restart dhcpd

####################################################
网络装机概述

• 规模化:同时装配多台主机
• 自动化:装系统、配置各种服务
• 远程实现:不需要光盘、U盘等物理安装介质

什么是PXE网络
• PXE,Pre-boot eXecution Environment
– 预启动执行环境,在操作系统之前运行
– 可用于远程安装


PXE组件及过程分析
• 需要哪些服务组件
– DHCP服务,分配IP地址、定位引导程序
– TFTP服务,提供引导程序下载
– HTTP服务,提供yum安装源

• 客户机应具备的条件
– 网卡芯片必须支持PXE协议
– 主板支持从网卡启动

##################################################
一  部署DHCP服务,指定下一个服务器地址

[root@svr7 /]# vim /etc/dhcp/dhcpd.conf 
 ......

  next-server  192.168.4.7;   #指定下一个服务器地址
  filename  "pxelinux.0";     #指定引导文件名称
} 

[root@svr7 /]# systemctl restart dhcpd

 pxelinux.0:网卡引导文件(安装说明书) 二进制文件
                      安装一个软件,默认产生的网卡引导文件名为pxelinux.0

##################################################
二 搭建tftp服务
    tftp:简单的文件传输协议  默认端口为69
       默认共享位置:/var/lib/tftpboot

1.安装软件包tftp-server
[root@svr7 /]# yum -y install tftp-server

2.重启tftp服务
[root@svr7 /]# systemctl  restart  tftp

3.部署pxelinux.0文件
]# yum  provides  */pxelinux.0     #查询那个包产生,该文件
]# yum -y install syslinux         
]# rpm -ql syslinux | grep pxelinux.0  #查询软件包安装清单

]# cp /usr/share/syslinux/pxelinux.0   /var/lib/tftpboot/
]# ls /var/lib/tftpboot/

pxelinux.0文件--->/var/lib/tftpboot/pxelinux.cfg/default

4.部署菜单文件
[root@svr7 /]# poweroff 
Connection to 192.168.4.7 closed by remote host.
Connection to 192.168.4.7 closed.
[student@room9pc01 ~]$ 
图形为虚拟机A,添加一个光驱设备,放入光盘内容
[student@room9pc01 ~]$ goa
Last login: Thu Apr 25 08:55:41 2019 from 192.168.4.254
[root@svr7 ~]# mount /dev/cdrom  /mnt/
mount: /dev/sr0 写保护，将以只读方式挂载
[root@svr7 ~]# ls /mnt/

[root@svr7 ~]# mkdir /var/lib/tftpboot/pxelinux.cfg

[root@svr7 ~]# cp /mnt/isolinux/isolinux.cfg /var/lib/tftpboot/pxelinux.cfg/default

[root@svr7 ~]# ls /var/lib/tftpboot/pxelinux.cfg/

[root@svr7 ~]# ls -l /var/lib/tftpboot/pxelinux.cfg/


5.部署 图形模块(vesamenu.c32) 与  背景图片(splash.png)

[root@svr7 ~]# cp /mnt/isolinux/vesamenu.c32 /mnt/isolinux/splash.png  /var/lib/tftpboot/

[root@svr7 ~]# ls /var/lib/tftpboot/

6.部署 启动内核(vmlinuz)   与  驱动程序(initrd.img)

[root@svr7 ~]# cp /mnt/isolinux/vmlinuz /mnt/isolinux/initrd.img /var/lib/tftpboot/

[root@svr7 ~]# ls /var/lib/tftpboot/
initrd.img  pxelinux.cfg  vesamenu.c32
pxelinux.0  splash.png    vmlinuz

7.修改菜单文件内容
# vim /var/lib/tftpboot/pxelinux.cfg/default 

  1 default vesamenu.c32   #默认加载图形模块
  2 timeout 600            #读秒时间60秒    1/10秒

 10 menu background splash.png     #指定背景图片
 11 menu title NSD1903 PXE Server  #修改标题 

 61 label linux
 62   menu label ^Install CentOS 7  #屏幕显示
 63   menu default                  #读秒结束默认选择
 64   kernel vmlinuz                #调用内核
 65   append initrd=initrd.img      #解压驱动程序

##################################################
 8.检查服务启动
[root@svr7 ~]# systemctl restart dhcpd
[root@svr7 ~]# systemctl enable dhcpd

[root@svr7 ~]# systemctl restart tftp
[root@svr7 ~]# systemctl enable tftp

#################################################
总结:
  1.DHCP服务-->IP地址   next-server  filename
  2.tftp服务-->pxelinux.0
  3.pxelinux.0-->读取默认菜单文件
  4.default-->图形模块  背景图片  启动内核  驱动程序

验证:
   新建一台虚拟机,安装方式选择 "网络引导安装(PXE)"
   网络类型选择"private1"

####################################################
三  构建Web服务,共享光盘所有内容
1.安装软件包httpd
[root@svr7 ~]# yum -y install httpd

2.重启httpd服务
[root@svr7 ~]# systemctl restart httpd
[root@svr7 ~]# systemctl enable httpd

3.共享光盘所有内容
[root@svr7 ~]# mkdir /var/www/html/centos
[root@svr7 ~]# ls /var/www/html/centos

[root@svr7 ~]# mount /dev/cdrom  /var/www/html/centos
mount: /dev/sr0 写保护，将以只读方式挂载
[root@svr7 ~]# ls /var/www/html/centos

[root@svr7 ~]# firefox 192.168.4.7/centos

#####################################################
四  部署无人值守安装,生成应答文件

1.安装图形的system-config-kickstart工具,生成应答文件
[root@svr7 ~]# yum -y install system-config-kickstart 

2.运行system-config-kickstart工具,进行配置
[root@svr7 ~]# LANG=en  system-config-kickstart 
首先查看软件包选择(Package Select),是否可以使用
需要Yum仓库的支持,必须要求Yum光盘仓库标识为 [development]

[root@svr7 ~]# vim /etc/yum.repos.d/local.repo 
[development]
 ........

[root@svr7 ~]# LANG=en  system-config-kickstart 

[root@svr7 ~]# ls /root/
[root@svr7 ~]# vim /root/ks.cfg 

3.利用Web服务,将应答文件ks.cfg,共享给客户端
[root@svr7 ~]# cp /root/ks.cfg  /var/www/html/
[root@svr7 ~]# ls /var/www/html/

4.修改菜单文件,指定应答文件ks.cfg
]# vim /var/lib/tftpboot/pxelinux.cfg/default
.........
label linux
  menu label ^Install CentOS 7
  menu default
  kernel vmlinuz
  append initrd=initrd.img  ks=http://192.168.4.7/ks.cfg

#####################################################
总结:
  1.DHCP服务-->IP地址   next-server  filename
  2.tftp服务-->pxelinux.0
  3.pxelinux.0-->读取默认菜单文件
  4.default-->图形模块  背景图片  启动内核  驱动程序  应答文件
  5.ks.cfg应答文件--> 分区 语言  键盘类型   装包
    # Use network installation
    url --url="http://192.168.4.7/centos"

验证:
   新建一台虚拟机,安装方式选择 "网络引导安装(PXE)"
   网络类型选择"private1"
   内存必须2G以上
##################################################


===========================================================
批量装机环境

DHCP原理: 广播进行,先到先得
DHCP地址分配的四次会话：DISCOVERY --> OFFER --> REQUEST -->ACK 。

DHCP服务器基本概念：
DHCP租期：允许客户机租用IP地址的时间期限，单位为秒
DHCP作用域：分配给客户机的IP地址所在的网段
DHCP地址池：用来动态分配的IP地址的范围
DHCP服务端：软件包dhcp、系统服务dhcpd
DHCP服务端配置文件：/etc/dhcp/dhcpd.conf
传输协议及端口：UDP 67（服务器）、UDP 68（客户端）


网络装机概述

• 规模化:同时装配多台主机
• 自动化:装系统、配置各种服务
• 远程实现:不需要光盘、U盘等物理安装介质

什么是PXE网络
• PXE,Pre-boot eXecution Environment
– 预启动执行环境,在操作系统之前运行
– 可用于远程安装

PXE组件及过程分析
• 需要哪些服务组件
– DHCP服务,分配IP地址、定位引导程序
– TFTP服务,提供引导程序下载
– HTTP服务,提供yum安装源

• 客户机应具备的条件
– 网卡芯片必须支持PXE协议
– 主板支持从网卡启动

开机启动项: 匹配即停止
1.本机硬盘    2.光驱设备    3.U盘    4.网络

一.搭建DHCP服务
虚拟机A:
   软件包: dhcp
   配置文件：/etc/dhcp/dhcpd.conf
   服务包: dhcpd
1.装软件包:
[root@svr7 ~]# yum -y install dhcp

2.配置文件：/etc/dhcp/dhcpd.conf
vim末行模式   :r  /usr/share/doc/dhcp*/dhcpd.conf.example
[root@svr7 ~]# vim /etc/dhcp/dhcpd.conf
subnet 192.168.4.0 netmask 255.255.255.0 {   #指定网段
  range 192.168.4.100 192.168.4.200;         #配置IP地址范围
  option domain-name-servers 192.168.4.7;    #解析的dns
  option routers 192.168.4.254;              #网关
  default-lease-time 600;        
  max-lease-time 7200;
}

3.重启服务
[root@svr7 ~]# systemctl restart dhcpd
[root@svr7 ~]# systemctl enable dhcpd


4. 部署DHCP服务,指定下一个服务器地址
[root@svr7 ~]# vim /etc/dhcp/dhcpd.conf
subnet 192.168.4.0 netmask 255.255.255.0 {
  range 192.168.4.100 192.168.4.200;
  option domain-name-servers 192.168.4.7;
  option routers 192.168.4.254;
  default-lease-time 600;
  max-lease-time 7200;
  next-server 192.168.4.7;  #指定下一个服务器地址
  filename "pxelinux.0";    #指定引导文件名称,pxelinux.0:网卡引导文件(安装说明书)

[root@svr7 ~]# systemctl restart dhcpd
[root@svr7 ~]# systemctl enable dhcpd

二. 搭建tftp服务  tftp:简单文件传输协议  二进制文件
默认共享位置: //var/lib/tftpboot

1.安装软件包tftp-server
[root@svr7 ~]# yum -y install tftp-server

2.重启服务
[root@svr7 ~]# systemctl restart tftp
[root@svr7 ~]# systemctl enable tftp

3.部署:pxelinux.0文件
[root@svr7 ~]# yum provides 路径
[root@svr7 ~]# yum provides */pxelinux.0  #查询那个包产生,该文件
[root@svr7 ~]# yum -y install syslinux-4.05-13.el7.x86_64  #查询软件包安装清单
[root@svr7 ~]# rpm -ql syslinux | grep pxelinux.0
[root@svr7 ~]# cp /usr/share/syslinux/pxelinux.0 /var/lib/tftpboot/

4.部署菜单文件
[root@svr7 ~]# poweroff
图形为虚拟机A,添加一个光驱设备,放入光盘内容
[root@svr7 ~]# mount /dev/cdrom /mnt  #光盘挂载
[root@svr7 ~]# ls /mnt/
[root@svr7 ~]# mkdir /var/lib/tftpboot/pxelinux.cfg
[root@svr7 ~]# cp /mnt/isolinux/isolinux.cfg /var/lib/tftpboot/pxelinux.cfg/default
[root@svr7 ~]# ls /var/lib/tftpboot/pxelinux.cfg/
[root@svr7 ~]# ls -l /var/lib/tftpboot/pxelinux.cfg/

5.部署图形模块与背景图片
[root@svr7 ~]# ls /mnt/isolinux/
[root@svr7 ~]# cp /mnt/isolinux/vesamenu.c32 /mnt/isolinux/splash.png /var/lib/tftpboot/
[root@svr7 ~]# ls /var/lib/tftpboot/

6.部署启动内核与驱动程序
[root@svr7 ~]# ls /mnt/isolinux/
[root@svr7 ~]# cp /mnt/isolinux/vmlinuz /mnt/isolinux/initrd.img  /var/lib/tftpboot/
[root@svr7 ~]# ls /var/lib/tftpboot/

7.修改菜单文件内容
[root@svr7 ~]# vim /var/lib/tftpboot/pxelinux.cfg/default 
1 default vesamenu.c32  #默认加载图形模块
2 timeout 600   #读秒时间,60秒
10 menu background splash.png  #指定背景图片
11 menu title NSD1903 PXE Server #修改标题
62  menu label ^Install CentOS 7 #^指定某个字母快捷键,屏幕显示
63   menu default  #读秒结束后默认选择
64   kernel vmlinuz #调用内核
注:65行以下全删
64 append initrd=initrd.img 

8.检查服务启动
[root@svr7 ~]# systemctl restart dhcpd
[root@svr7 ~]# systemctl enable dhcpd
[root@svr7 ~]# systemctl restart tftp
[root@svr7 ~]# systemctl enable tftp

总结: 
  1.DHCP服务--->IP地址 net-server   filename
  2.tftp服务-->pxelinux.0
  3.pxelinux.0 -->读取默认菜单文件
  4.default-->图形模块 背景图片 启动内核 启动程序

验证:
新建一台虚拟机,安装方式选择"网路引导安装(PXE)"
网络类型选择"private1"

[root@svr7 ~]# systemctl status dhcpd  #查看服务是否启动


三.构建Web服务,共享光盘所有内容

1.安装软件包httpd
[root@svr7 ~]# yum -y install httpd

2.重启httpd服务
[root@svr7 ~]# systemctl restart httpd
[root@svr7 ~]# systemctl enable httpd

3.共享光盘所有内容
[root@svr7 ~]# mkdir /var/www/html/centos
[root@svr7 ~]# mount /dev/cdrom /var/www/html/centos
[root@svr7 ~]# firefox 192.168.4.7/centos  


四.部署无人值守安装,生成应答文件
1.安装图形system-config-kickstart工具,生成应答文件
[root@svr7 ~]# yum -y install system-config-kickstart

2.system-config-kickstart
[root@svr7 ~]# LANG=en system-config-kickstart

[root@svr7 ~]# LANG=en  system-config-kickstart 
首先查看软件包选择(Package Select),是否可以使用
需要Yum仓库的支持,必须要求Yum光盘仓库标识为 [development]

[root@svr7 ~]# vim /etc/yum.repos.d/local.repo 
[development]
 ........

[root@svr7 ~]# LANG=en  system-config-kickstart 

[root@svr7 ~]# ls /root/
[root@svr7 ~]# vim /root/ks.cfg 

3.利用Web服务,将应答文件ks.cfg,共享给客户端
[root@svr7 ~]# cp /root/ks.cfg  /var/www/html/
[root@svr7 ~]# ls /var/www/html/

4.修改菜单文件,指定应答文件ks.cfg
]# vim /var/lib/tftpboot/pxelinux.cfg/default
.........
label linux
  menu label ^Install CentOS 7
  menu default
  kernel vmlinuz
  append initrd=initrd.img  ks=http://192.168.4.7/ks.cfg

#####################################################
总结:
  1.DHCP服务-->IP地址   next-server  filename
  2.tftp服务-->pxelinux.0
  3.pxelinux.0-->读取默认菜单文件
  4.default-->图形模块  背景图片  启动内核  驱动程序  应答文件
  5.ks.cfg应答文件--> 分区 语言  键盘类型   装包
    # Use network installation
    url --url="http://192.168.4.7/centos"

验证:
   新建一台虚拟机,安装方式选择 "网络引导安装(PXE)"
   网络类型选择"private1"
   内存必须2G以上
##################################################

service_day06=================================================================================================

rsync同步操作

rsync同步操作
• 命令用法
– rsync [选项...]  源目录     目标目录

• 同步与复制的差异
– 复制:完全拷贝源到目标
– 同步:增量拷贝,只传输变化过的数据

同步控制
• rsync操作选项
– -n:测试同步过程,不做实际修改
– --delete:删除目标文件夹内多余的文档
– -a:归档模式,相当于-rlptgoD
– -v:显示详细操作信息
– -z:传输过程中启用压缩/解压

[root@svr7 ~]# mkdir /nsd1903    /nsd04
[root@svr7 ~]# cp /etc/passwd /etc/fstab  /nsd1903/
[root@svr7 ~]# ls /nsd1903/

[root@svr7 ~]# rsync -av /nsd1903    /nsd04   #同步本身
[root@svr7 ~]# ls /nsd04
[root@svr7 ~]# rsync -av /nsd1903/    /nsd04  #同步内容
[root@svr7 ~]# ls /nsd04

[root@svr7 ~]# touch /nsd1903/1.txt
[root@svr7 ~]# ls /nsd1903/
[root@svr7 ~]# ls /nsd04

[root@svr7 ~]# rsync -av /nsd1903/    /nsd04
[root@svr7 ~]# ls /nsd04

[root@svr7 ~]# rsync -av --delete /nsd1903/  /nsd04/
[root@svr7 ~]#  ls /nsd1903
[root@svr7 ~]#  ls /nsd04

[root@svr7 ~]# touch /nsd04/xixi.txt
[root@svr7 ~]#  ls /nsd1903
[root@svr7 ~]#  ls /nsd04
[root@svr7 ~]# rsync -av --delete /nsd1903/  /nsd04/
[root@svr7 ~]#  ls /nsd1903
[root@svr7 ~]#  ls /nsd04

####################################################
远程同步                  
虚拟机A目录/nsd1903与虚拟机B目录/opt进行同步

rsync+SSH同步= rsync + scp

• 与远程的 SSH目录保持同步
– 下行:rsync [...] user@host:远程目录    本地目录
– 上行:rsync [...] 本地目录   user@host:远程目录

虚拟机A:
]# rsync -av --delete /nsd1903/ root@192.168.4.207:/opt/

虚拟机B
]# ls  /opt
]# touch /opt/haxi.txt
]# ls  /opt

虚拟机A:
]# rsync -av --delete /nsd1903/ root@192.168.4.207:/opt/

虚拟机B
]# ls  /opt

###################################################
完成实时同步准备:安装inotify-tools工具
源码包编译安装

源码编译安装的优势
• 主要优点
– 获得软件的最新版,及时修复bug
– 软件功能可按需选择/定制,有更多软件可供选择
– 源码包适用各种平台


rpm包:  rpm -ivh    yum install

源码包:----gcc make开发工具---->可以执行的程序--->运行安装

1.真机上传tools.tar.gz包,到虚拟机A的/root
[student@room9pc01 ~]$ scp /home/student/桌面/tools.tar.gz root@192.168.4.7:/root/

2.验证是否上传成功
[root@svr7 ~]# ls /root/
[root@svr7 ~]# tar -xf /root/tools.tar.gz  -C  /opt
[root@svr7 ~]# ls /opt/tools/
inotify-tools-3.13.tar.gz  other

步骤1:安装gcc make开发工具(安装依赖关系的软件)
[root@svr7 ~]# yum -y install gcc  make
[root@svr7 ~]# rpm -q gcc
[root@svr7 ~]# rpm -q make
步骤2:tar解包,释放源代码至指定目录
]# tar -xf /opt/tools/inotify-tools-3.13.tar.gz -C /
]# ls /inotify-tools-3.13/

步骤3: ./configure 配置,指定安装目录/功能模块等选项
                            
       --prefix=指定安装的位置   

]# cd /inotify-tools-3.13/
]# ./configure  
       
  #检测系统是否安装gcc,检测系统是否可以支持编译安装     
常见提示:gcc没有安装
checking for gcc... no
checking for cc... no
checking for cl.exe... no
configure: error: no acceptable C compiler found in $PATH
See `config.log' for more details.

步骤4:make 编译,生成可执行的二进制程序文件
]# cd /inotify-tools-3.13/
]# make 

步骤5:make install 安装,将编译好的文件复制到安装目录
]# cd /inotify-tools-3.13/
]# make install
]# ls /usr/local/bin/inotifywait 

###################################################
实时同步:虚拟机A目录/nsd1903与虚拟机B目录/opt进行同步

一 实现ssh的无密码验证,生成公钥 私钥

1.虚拟机A生成公钥 私钥
[root@svr7 ~]# ssh-keygen       #一路回车
[root@svr7 ~]# ls /root/.ssh/
authorized_keys  id_rsa  id_rsa.pub  known_hosts

known_hosts:记录曾经远程管理过的主机

2.虚拟机A传递公钥到虚拟机B上
]# ssh-copy-id  root@192.168.4.207

]# rsync -av --delete /nsd1903/ root@192.168.4.207:/opt/

虚拟机B
[root@pc207 ~]# ls /root/.ssh/
authorized_keys
[root@pc207 ~]# 

####################################################

二  监控目录内容的变化

inotifywait监控
• 基本用法
– inotifywait [选项] 目标文件夹

• 常用命令选项
– -m,持续监控(捕获一个事件后不退出)
– -r,递归监控、包括子目录及文件
– -q,减少屏幕输出信息
– -e,指定监视的 modify、move、create、delete、attrib等事件类别



 inotifywait -mrq /nsd1903

 rsync -a --delete /nsd1903/ root@192.168.4.207:/opt/

三  书写shell脚本完成,实时同步操作
       循环解决重复性操作
       for循环:适合写有次数的循环

          for  i  in  值
           do
                        重复性操作
           done

        死循环:无限次的循环
       while循环:适合写无限次的循环

         while [ 1 -eq 1 ]
          do
		      重复执行的操作
          done

[root@svr7 ~]# vim /root/rsync.sh
#!/bin/bash
while  inotifywait -rqq /nsd1903 
 do
 rsync -a --delete /nsd1903/ root@192.168.4.207:/opt/
 done
[root@svr7 ~]# /root/rsync.sh

####################################################

============================================================
rsync同步基本使用: 第一次同步所有内容,第二次同步变化内容

rsync同步工具的常用选项：
-n：测试同步过程，不做实际修改
--delete：删除目标文件夹内多余的文档
-a：归档模式，相当于-rlptgoD
-v：显示详细操作信息
-z：传输过程中启用压缩/解压

本地同步操作：
rsync [选项...] 本地目录1 本地目录2
rsync [选项...] 本地目录1/ 本地目录2

rsync [选项...] 本地目录1 本地目录2
例: 
[root@svr7 ~]# mkdir /nsd01 /nsd
[root@svr7 ~]# cp -p /etc/passwd /etc/fstab /nsd01
[root@svr7 ~]# rsync -av /nsd01 /nsd  #同步本身

rsync [选项...] 本地目录1/ 本地目录2
例:
[root@svr7 ~]# rsync -av /nsd01/ /nsd  #同步内容

--delete：删除目标文件夹内多余的文档
例:
[root@svr7 ~]# rsync -av --delete /nsd01/ /nsd  #以原为参照,删除多出来的

=========================================================
远程同步: rsync+SSH同步

虚拟机A目录/nsd01与虚拟机B目录/opt进行同步
rsync user@host:远程目录/

rsync+SSH远程同步操作：
rsync [...] user@host:远程目录 本地目录


rsync [...] 本地目录 user@host:远程目录
例:
虚拟机A
[root@svr7 ~]# rsync -av --delete /nsd01/ root@192.168.4.207:/opt
[root@pc207 ~]# ls /opt  #在虚拟机B查看

[root@room9pc01 ~]# rsync -r '/run/media/root/f687b0b7-5b7a-4496-94ea-497d331e2999/Linux/ISO/classroom' root@192.168.1.179:/


=========================================================
inotify实时同步

inotifywait常用命令选项：
-m，持续监控（捕获一个事件后不退出）
-r，递归监控、包括子目录及文件
-q，减少屏幕输出信息
-e，指定监视的 modify、move、create、delete、attrib 等事件类别


inotifywait监控操作：
  inotifywait [选项] 目标文件夹

完成实时同步准备: 安装inotify-tools工具
源码包编译安装
1.真机上传tools.tar.gz包到虚拟机A的/opt
[root@room12pc8 ~]# cd 桌面
[root@room12pc8 桌面]# scp tools.tar.gz root@192.168.4.7:/root/

2.验证是否上传成功
[root@svr7 ~]# ls /root/
[root@svr7 ~]# tar -xf /root/tools.tar.gz -C /opt
[root@svr7 ~]# ls /opt/tools

步骤1: 安装gcc和make开发工具(安装依赖工具软件)
[root@svr7 ~]# yum -y install gcc make
[root@svr7 ~]# rpm -q gcc make
gcc-4.8.5-28.el7.x86_64
make-3.82-23.el7.x86_64
步骤2: tar解包,释放源代码至指定目录
[root@svr7 ~]# ls /opt/tools/
[root@svr7 ~]# tar -xf  /opt/tools/inotify-tools-3.13.tar.gz -C /
步骤3: ./configure 配置指定安装目录/功能模块等选项
--prefix=指定安装的位置
[root@svr7 ~]# cd /inotify-tools-3.13/
[root@svr7 inotify-tools-3.13]#  ./configure  #检测系统是否安装支持编译安装

步骤4: make编译生成可以执行的二进制文件
[root@svr7 ~]# cd /inotify-tools-3.13/
[root@svr7 inotify-tools-3.13]# make

步骤5: make install 安装将编译好的文件复制到安装目录
[root@svr7 inotify-tools-3.13]# make install
[root@svr7 ~]# ls /usr/local/bin/inotifywait
/usr/local/bin/inotifywait

=============================================================
一.实现ssh的无密码验证
[root@svr7 ~]# ssh-keygen  #一路回车
[root@svr7 ~]# ls /root/.ssh/
authorized_keys  id_rsa  id_rsa.pub  known_hosts
                         私        公

=============================================================
known_hosts: ;记录
2.虚拟机A传递公钥到虚拟机B
[root@svr7 ~]# ssh-copy-id root@192.168.4.207
[root@svr7 ~]# rsync -av --delete /nsd01/ root@192.168.4.207:/opt/

虚拟机B
[root@pc207 ~]# ls /root/.ssh/
authorized_keys

二.监控目录内容变化
inotifywait常用命令选项：
-m，持续监控（捕获一个事件后不退出）
-r，递归监控、包括子目录及文件
-q，减少屏幕输出信息,两个qq代表不屏幕输出
-e，指定监视的 modify、move、create、delete、attrib 等事件类别
例:
[root@svr7 ~]# inotifywait -mrq /nsd01


三.书写shell脚本完成,实时同步操作
    循环解决重复性操作
    for循环:适合书写有次数的循环
 死循环: 无限次的循环
   while循环: 适合写无限次循环
 
[root@svr7 ~]# vim /root/rsync.sh
#!/bin/bash

while inotifywait -rqq /nsd01     
do
rsync -a --delete /nsd01/ root@192.168.4.207:/opt/
done
[root@svr7 ~]# chmod +x /root/rsync.sh
[root@svr7 ~]#  /root/rsync.sh &  #放在后台监听
 
=======================================================
Cobbler装机平台

本例要求为新建虚拟机硬盘位20G，网络类型为“private1”操作系统为CentOS 7：
虚拟机名设置为Cobbler
IP地址设置为：192.168.4.123/24
关闭SELinux安全机制
设置防火墙默认区域为trusted
利用Cobbler部署CentOS 7与 RedHat 7双系统装机平台


三.利用scp真机传递Cobbler.zip
[root@room12pc8 桌面]# scp Cobbler.zip root@192.168.4.7:/root/
[root@svr7 ~]# yum -y install unzip
[root@svr7 ~]# unzip /root/Cobbler.zip -d /
[root@svr7 ~]# ls /Cobbler/
[root@svr7 ~]# unzip /Cobbler/cobbler.zip -d /opt/
[root@svr7 ~]# unzip  /Cobbler/cobbler.zip -d /Cobbler/

[root@svr7 ~]# yum -y install /Cobbler/cobbler/*.rpm 
[root@svr7 ~]# yum -y install  httpd dhcp mod_ssl

[root@svr7 ~]# vim /etc/cobbler/settings
[root@svr7 ~]# vim /etc/cobbler/dhcp.template 
pxe_just_once: 1

[root@svr7 ~]# tar -tf  /Cobbler/cobbler_boot.tar.gz
[root@svr7 ~]# tar -xPf  /Cobbler/cobbler_boot.tar.gz

重启服务
[root@svr7 ~]# systemctl restart cobblerd
[root@svr7 ~]# systemctl enable cobblerd
[root@svr7 ~]# systemctl restart httpd
[root@svr7 ~]# systemctl enable httpd
[root@svr7 ~]# systemctl restart tftpd rsyncd
[root@svr7 ~]# systemctl enable tftp rsyncd 
或
[root@svr7 ~]# for i in cobblerd httpd tftpd rsyncd
> do
> systemctl restart $i
> systemctl enable $i
> done

[root@svr7 ~]# cobbler sync
[root@svr7 ~]# firefox https://192.168.4.7/conbbler

[root@svr7 ~]# mkdir /dvd
[root@svr7 ~]# mount /dev/cdrom /dvd
[root@svr7 ~]# cobbler import --path=/dvd --name=CentOS7  #导入

4.network======================================================================

network_day01===============================================================================

计算机网络
软件:eNSP1.2.0.0.510

什么是计算机网络
  硬件方面: 通过线缆将网络设备和计算机连接起来
  软件方面: 操作系统,应用软件,应用通信线路互连
  实现资源共享,信息传递,增加可以靠性,提高系统处理能力

60年代[Huawei]display mac-address
分组交换: 提高数据转输效率,减少服务器负担.
70-80年代
TCP/IP: 统一网路环境
90年代后
Web技术

================================================
WAN与LAN
广域网
  范围: 几十到几千千米
  作用: 用于连接远距离的计算机网络
  典型应用: Internet
局域网
  范围: 1km左右
  作用: 用于连接较短距离内的计算机
  典型应用: 企业网,校园网

================================================
网络设备及拓扑
  网络设备生产厂商: 华为和Cisco(思科)

网络拓扑结构
 线缆连接计算机和网络设备的布局
    点对点
    星型及扩展的星型
    网状

点对点拓扑结构
  两台设备之间只有一条单独的连接
  专用的广域网中电路连接的两台路由器

网络拓扑结构
   星型拓扑结构
     优点: 易于实现,易于网路扩展,易于故障排查
     缺点: 中心节点压力大,组网成本较高
   网状拓扑结构
     一个节点和其他多个节点相连
     提供冗余性和容错性
     可靠性高
     组网成本高

================================================
OSI参考模型
  
OSI七层模型
应用层          网络服务与最终用户的一个接口
表示层          数据的表示 安全 压缩
会话层          建立 管理 中止回话
传输层          定于传输数据的协议端口号,以及流控和
网络层          进行逻辑地址寻址
数据链路层      建立逻辑连接  进行硬件地址寻址
物理层          建立 维护  断开物理连接

===================================================
TCP/IP协议族的组成
应用层      HTTP FTP TFTP SMTP SNMP DNS 
传输层      TCP UDP
网络层      IMP IGMP IP ARP
数据链路层  VLAN TRUNK MSTP

什么是协议 
  为了使数据可以在网络上从源传递到目的地,网络上所有设备需要"讲"相同的"语言"
  描述网络通信"语言"规范的组规则就是协议

协议数据单元(PDU)
应用层          上层数据
传输层          数据段
网络层          数据包
数据链路层      数据帧
物理层          比特流(byte  字节)    8比特=1字节

计算机最小单位为比特

设备与层的对应关系
应用层          计算机
传输层          防火墙
网络层          路由器
数据链路层      交换机
物理层          网卡

===================================================
交换机的命令行视图

用户视图
＜Ｈuawei＞
＜Ｈuawei＞undo term monitor  #关闭提示信息弹出
＜Ｈuawei＞term monitor       #开启提示信息弹出
＜Huawei＞reboot  //重启
＜Huawei＞save　　 //保存交换机的配置，回复ｙ保存，回复ｎ不保存

===================================================
系统视图
<Huawei>system-view  //进入系统视图
[Huawei]
[Huawei]quit         //返回上一视图
[Huawei]return　　　　//直接退到用户视图，return命令和快捷键Ｃtrl+z 效果一样
[Huawei]interface Ethernet0/0/1  //进入接口视图
[Huawei-Ethernet0/0/1]
[Huawei]sysname SW1  //交换机设置主机名,要系统视图修改
[SW1]
[Huawei]display version //任何视图可以执行,显示VRP版本,要在系统视图查询
[Huawei]display current-configuration 　//查看当前交换机配置,可以任何视图查询

===========================================================
使用账户和密码登录终端
<Huawei>system-view 
[Huawei]aaa           //进入aaa认证
[Huawei－aaa]local user zhaiyanquan password cipher zhaiyanquan　　//cipher表示登录时输入密码不显示
                                 用户名　　　　　　　　　　　　　　　密码
[Huawei－aaa]quit
[Huawei]user-interface console 0
[Huawei-ui-console0]authentication-mode aaa

===========================================================
恢复设备出厂默认值
<Ｈuawei>reset saved-configuration  //回答ｙ恢复，回答ｎ不恢复
<Ｈuawei>reboot

配置控制台会话时间,默认是10分钟
<Huawei>system-view
[Huawei]user-interface console 0
[Huawei-ui-console0]idle-timeout 100 //设置100分钟

===================================================
数据链路层
　　
以太网ＭAC地址: 用来识别一个以太网上的某个单位的设备或一组设备
ＭAC地址: 48位(前24位是供应商标识,后24位是产品编号),6个字节

以太网帧格式: 数据链路层的协议数据单元(目的地址6字节,源地址6字节)

什么是交换机
  交换机是用来连接局域网的主要设备

交换机工作原理: 先学习MAC地址-->广播-->转发数据-->更新
   初始状态
   MAC地址学习
   广播未知数据帧
   接收方回应

查看MAC地址
<Huawei>display mac-address  //任何视图可以执行

广播: 同一范围或同一个网段

在交换机中查看MAC地址表
<Huawei>system-view
[Huawei]display mac-address

network_day02===============================================================================

LVAN技术及应用
   Virtual LAN(虚拟局域网)是物理设备上连接的不受物理位置限制的用户的一个逻辑组
    
LVAN的作用: 广播控制  增加安全性  提高带宽利用 降低延迟
vlan 0~4095 可以划分: 4096个vlan

创建VLAN

vlan划分

配置VLAN的步骤
  创建VLAN
  将接口加入到相应的VLAN中
  验证


创建vlan
<Huawei>system-view
[Huawei]vlan 2        //创建VLAN 2
批量创建VLAN
[Huawei]vlan batch 2 3 10 //同时创建vlan 2 3
[Huawei]vlan batch 11 to 30

删除VLAN
[Huawei]undo vlan 10
[Huawei]undo vlan batch 2 3 10
[Huawei]undo vlan batch 11 to 30

将某个接口加入vlan
[Huawei]interface e0/0/1 /进入接口1
[Huawei-Ethernet0/0/1]port link-type access  
[Huawei-Ethernet0/0/1]port default vlan 3  

将接口加入VLAN
[Huawei]interface Eethernet0/0/1
[Huawei-Eethernet0/0/1]port link-type access
[Huawei-Eethernet0/0/1]port default vlan 2

批量将接口加入VLAN
首先将某个接口加入接口组,然后将接口组加入VLAN
[Huawei]port-group 1
[Huawei-group-1]group-member Ethernet0/0/1 Ethernet0/0/2
[Huawei-group-1]group-member Ethernet0/0/1 to Ethernet0/0/10
[Huawei-group-1]port link-type access 
[Huawei-group-1]port default vlan 2

验证VLAN的配置
[Huawei]display vlan    //查看所有vlan信息
[Huawei]display vlan 2  //查看某个vlan信息


将多个接口同时加入vlan
[Huawei]port-group 1  //创建一号接口组
[Huawei-port-group-1]group-member e0/0/3 e0/0/4  //将接口e0/0/3和e0/0/4加一号组
[Huawei-port-group-1]port link-type access       //将1号组里的接口设置为access,表示将此接口
[Huawei-port-group-1]port default vlan 3 //将
[Huawei-port-group-1]display this                //查看组里显示的接口
[Huawei]undo vlan 4  //删除vlan 4 

access: 接入链路  可以承载1个vlan的数据
trunk : 中继链路,可以承载多个vlan的数据

验证vlan的配置
[Huawei]display vlan     //查看当前所有vlan信息
[Huawei]display vlan 1   //查看vlan 1信息
[Huawei]display port-group 1 //查看接口组1成员

[Huawei]clear configuration interface e0/0/7 //将接口恢复默认状态
[Huawei]interface e0/0/1    /进入接口
[Huawei-Ethernet0/0/1]port default vlan 1   //将接口e0/0/7加入vlan 1
[Huawei-Ethernet0/0/1]port link-type trunk  //设置接口状态
[Huawei-Ethernet0/0/1]port trunk allow-pass vlan all //允许所有vlan通过

=======================================================================
TRUNK
链路聚合配置: 通过配置实现网路高可用

TRUNK的作用: 为数据帧打上VLAN标识，使不同VLAN数据可以用一条链路传递

配置接口为Trunk模式
进入端口后修改端口为链路类型
[Huawei]interface e0/0/1
[Huawei-Ethernet0/0/1]port link-type trunk
[Huawei-Ethernet0/0/1]port trunk allow vlan all //允许所有vlan通过

配置vlan trunk实例
第一步:在交换机上添加vlan
[Huawei]vlan batch 2 3
第二步: 将接口加入相应的vlan中
[Huawei]port-group 1
[Huawei-port-group-1]
[Huawei-port-group-1]group-member e0/0/3 e0/0/5
或
[Huawei-port-group-1]group-member e0/0/8 to e0/0/20
[Huawei-port-group-1]port link-type access 
[Huawei-port-group-1]port default vlan 2  //将接口组加入vlan中

=======================================================================
链路聚合

链路聚合功能
Eth-trunk
 多线路负载均衡,带宽提高
 容错,当一条线路失效时,不会造成全网中断
 实现网络高可用

配置静态路由: 通过管理员手工配置目的网段

路由器: 1.使用前需要配置IP地址  2.能够连接不同广播域的设备,并隔离广播

配置链路聚合
进入接口,加入链路聚合组
[Huawei]interface e0/0/1           //进入接口1
[Huawei-Ethernet0/0/1]eth-trunk 1  //将接口加入链路聚合组
[Huawei]interface e0/0/2           //进入接口2
[Huawei-Ethernet0/0/2]eth-trunk 1  //将接口加入链路聚合组
或
[Huawei]interface Eth-trunk 1                     //开启链路集合接口1,1表示组号,只本机有用
[Huawei-Eth-Trunk1]trunkport Ethernet 0/0/1 0/0/2 //将接口01和02捆绑在一起
另一台交换机相同操作,路由器也是同样的操作

[Huawei]display eth-trunk //查看加入eth-trunk状态

在配置中继链路和链路聚合时,接口要设置为默认状态

<Huawei>system-view 
[Huawei]interface g0/0/0 //进入接口g0/0/0
[Huawei-GigabitEthernet0/0/1]ip address 192.168.1.254 24 //给路由器接口配置IP地址

[Huawei]display ip routing-table  //查看路由表

静态路由: 通过管理员手工配置目的网段
直连路由: 路由器配置IP地址后自动生成,结果需要是up状态

配置静态路由
[Huawei]ip route-static 192.168.3.0 24 192.168.2.2  //24表示子网掩码255.255.255.0
                                  对方网段            下一跳

=======================================================================
网络层解析

网络层的功能
 定义了基于IP地址的逻辑地址
 连接不同某介类型
 选择数据通信网络的最佳路径

ICMP协议
  通过IP数据报传送,用来发送错误信息和控制信息

三层交换机基本配置
[Huawei]vlan batch 2 3 //同时创建vlan2和vlan3
[Huawei]interface Vlanif 1  //进入vlanif1
[Huawei-Vlanif1]ip address 192.168.2.254 24   //给vlan2配置IP地址
[Huawei]interface Ethernet0/0/2     //进入接口2
[Huawei-Ethernet0/0/2] port link-type access   //将接口2配置access状态
[Huawei-Ethernet0/0/2] port default vlan 2  //将接口加入vlan2

ICMP Internet 控制报文协议
ping 检查和反馈网络状态信息

什么是路由
  数据包从一个网络发送到另一个网络
  需要依靠路由器来完成
  路由器只关心网路的状态,决定最佳路径
  路由器可以根据路由表选择最佳路径

如何获得路由表
静态 默认路由
     由管理员在路由器上手工指定
     适合分支机构,家居办公等小型网络
动态路由
   根据网络拓扑或流量变化,由路由器通过路由协议自动设置
   适合ISP服务商 广域网 园区网等大型网络
   
静态路由的主要特点
   由管理员手工配置,为单向条目
   通信双方的边缘路由器都需要指定,否则数据包有去无回

默认路由的作用
默认路由是一种特殊的静态路由
默认路由的目标网络为 0.0.0.0 0.0.0.0，可匹配任何目标地址
只有当从路由表中找不到任何明确匹配的路由条目时，才会使用默认路由，一般在企业网关出口使用

三层交换机
 什么是三层交换机: 
     使用三层交换机技术实现vlan间通信
     三层交换=二层交换+三层转发
     
=======================================================================

[Huawei-Ethernet0/0/1]shutdown        //关闭接口1rule permit source 192.168.2.1 0
[Huawei-Ethernet0/0/1]undo shutdown   //开启接口1
[Huawei]display current-configuration //查看当前配置
[Huawei-Ethernet0/0/1]display this    //查看当前视图配置

[Huawei-Ethernet0/0/1]undo port dedault vlan //先删除属于的vlan
[Huawei-Ethernet0/0/1]udno port link-type    //删除接口状态

network_day03===============================================================================

OSPF

动态路由: 基于某种路由协议实现
动态路由特点: 减少了管理任务  占用了网络带宽

动态路由协议OSPF
作用典型: 适合大中型网络使用
邻居列表
链路状态数据库
路由表

交换机
[Huawei]vlan batch 2 3           //创建VLAN2、3
[Huawei]interface Ethernet0/0/2  //进入接口1
[Huawei-Ethernet0/0/2]port link-type access
[Huawei-Ethernet0/0/2]port default vlan 2  //

三层交换机
[Huawei]ospf 1  //进入进程1
[Huawei]osfp 1
[Huawei-ospf-1]area 0  //进入区域0 

直连路由
静态路由
动态路由

默认路由: 是特殊静态路由,可以匹配任意网段,当路由表找不到明细路由时使用,一般用在企业出口网关.
三层交换机
[Huawei]ip route-static 0.0.0.0 0.0.0.0 192.168.4.2  //默认路由,那里都能去
                                                       下一跳
================================================================
传输层的协议： TCP协议和UDP协议

  TCP: 传输控制协议
           可靠的 面向连接的协议
           传输效率低
  
   UDP: 用户数据报协议
            不可靠的 无连接的服务
            传输效率高

传输层的作用:
网络层提供点到点的连接
传输层提供端到端的连接

TCP协议
syn: 打算与对方主机进行连接
ack: 确认对方信息
fin: 打算与对方主机断开连接

三次握手
syn-->syn,ack-->ack

四次断开
fin-->ack-->fin-->ack

TCP的应用
21   FTP  文件传输协议,用于上传,下载  
23   Telnet 用于远程登陆，通过连接目标计算机的这一端口，得到眼验证后可以远程控制管理目标计算机
25   SMTP  简单路由传输协议，用于发送邮件
53   DNS  域名服务，当用户输入网站的名称后，由DNS负责将它解析成IP地址，这个过程用到的端口是53
80   HTTP 超文本传输协议，通过HTTP实现网络上超文本的传输

UDP协议
UDP的应用
69   TFTP  简单文本传输协议
53   DNS   域名服务
123  NTP   网络时间协议

===============================================================
ACL
ACL的作用： 
访问控制列表是应用在路由器接口的指令列表
读取第三层、第四层报文头信息
根据预先定义好的规则对报文进行过滤

基本ACL
基于源IP地址过滤数据包
基本访问控制列表的列表号是2000~2999
高级ACL
基于源IP地址、目的IP地址、指定协议、端口来过滤数据包
高级访问控制列表的列表号是3000~3999

acl: 过滤网络类型,可以对源IP,目标IP,

0 严格匹配
1 不做匹配

deny :拒绝

[Huawei-GigabitEthernet0/0/1]traffic-filter inbound acl 2000
[Huawei-GigabitEthernet0/0/1]traffic-filter inbound acl 2000

[Huawei-GigabitEthernet0/0/1]undo traffic-filter inbound acl 2000

================================================================
NAT： 网络地址转换
NAT网络地址转换: 可以将内部私有IP地址转换为公网地址,从而实现全球互联

NAT的作用：
通过将内部网络的私有IP地址翻译成全球唯一的公网IP地址，使内部网络可以连接到互联网等外部网络上。

127 本机回环
169.254 内部保留

内部私有地址
A类 10.0.0.0～10.255.255.255
B类 172.16.0.0～172.31.255.255
C类 192.168.0.0～192.168.255.255
	
NAT的特性
NAT的优点： 节省公有合法IP地址、处理地址重叠、安全性
NAT的缺点： 延迟增大、配置和维护复杂性

NAT实现方式： 情态转换、Easy IP

静态NAT: 
静态转换是指将内部网络的私有地址转换为公网地址时，IP地址对应关系是确定的
静态转换是一对一的转换
静态转换是双向的

配置静态NAT
[Huawei]interface GigabitEthernet 0/0/0   
[Huawei-GigabitEthernet0/0/0] ip address  100.0.0.1 8                        #给路由器接口配置IP地址
[Huawei-GigabitEthernet0/0/0]nat static global 100.0.0.2 inside 192.168.2.1  #配置路由器
                                                             买的IP地址             客户机IP地址

Easy ip: 多对一转换,通常在仅需访问公网的环境使用
    特点: 能节约ip节点,但不能往回ping通

network_day04===============================================================================

STP
广播风暴的产生

交换机工作原理
根据MAC地址转发数据帧，如果未知，则广播。
如果交换机接到广播帧也会向所有接口发送

STP功能:
1)生成树协议,可以在环形网络中临时断开一个接口,避免广播风暴,在网络不通时,又可以打开这个接口,起到备份链路的作用
2)逻辑上断开环路,防止广播风暴的产生
3)当线路故障，阻塞接口被激活，恢复通信，起备份线路的作用

选择根网桥
网桥ID是唯一的,交换机之间选项BID值最小的交换机作为网络中的根网桥

STP配置
启动或关闭交换机全局或端口的STP功能,默认情况下交换机STP处于开启状态
[Huawei]stp enable   #启动
[Huawei]stp disable  #关闭

STP配置命令
Priority为交换机的优先级,取值范围0-61440,步长4096,默认值是32768
[Huawei]stp priority priority
                              数字
例:
[Huawei]stp priority 4096

查看当前根网桥
通过修改交换机的优先级来分配根网桥
[Huawei]display stp brief

[Huawei]display ip interface brief #查看设备IP


===============================================================
VRRP

单网关的缺陷
当网关路由器出现故障时,本网段内以该设备为网关的主机不能与Internet进行通信

多网关存在的问题
通过部署多网关的方式实现网关的备份
存在的问题: 网关间IP地址冲突  主机频率切换网关的出口

什么是VRRP
VRRP能够在不改变组网的情况下,将多台路由器虚拟成一台虚拟路由器,通过配置虚拟路由器的IP地址为默认网关,实现网关的备份.

VRRP组成员角色: 主路由器吧,备份路由器,虚拟路由器

VRRP配置步骤:
配置VRRP的成员
配置VRRP的优先级(默认100)
配置VRRP抢占模式(默认开启)
查看VRRP信息

查看VRRP信息
<Huawei>display vrrp
<Huawei>display vrrp brief #查看摘要信息

路由器
<Huawei>system-view #进入系统视图模式
[Huawei]interface GigabitEthernet 0/0/0
[Huawei-GigabitEthernet0/0/0]ip address 192.168.2.1 24 #给路由器接口配置IP地址
[Huawei]ospf 1        #进入进程1 
[Huawei-ospf-1]area 0 #进入区域0
[Huawei-ospf-1-area-0.0.0.0]network 192.168.2.0 0.0.0.255 #配置动态路由
[Huawei-ospf-1-area-0.0.0.0]network 192.168.3.0 0.0.0.255
[Huawei-ospf-1-area-0.0.0.0]network 192.168.4.0 0.0.0.255

三层交换机
<Huawei>system-view
[Huawei]interface Vlanif 2               #进入vlan2
[Huawei-Vlanif2]ip add 192.168.1.252 24  #给vlan 2配置ip
[Huawei]interface GigabitEthernet 0/0/2  #进入接口2
[Huawei-GigabitEthernet0/0/2]port link-type access  #把接口调成access,只能承载一个vlan
[Huawei-GigabitEthernet0/0/2]port default vlan 2    #将接口2加vlan 2 
[Huawei]ospf 1 //开启进程1  
[Huawei-ospf-1]area 0  //进入区域0
[Huawei-ospf-1-area-0.0.0.0]network 192.168.1.0 0.0.0.255 #配置动态路由
[Huawei-ospf-1-area-0.0.0.0]network 192.168.2.0 0.0.0.255
[Huawei]interface Vlanif 1  //进入vlan1
[Huawei-Vlanif1]vrrp vrid 1 virtual-ip 192.168.1.254 #配置虚拟路由器IP
[Huawei-Vlanif1]vrrp vrid 1 priority 200             #配置优先及大小,默认是100,范围0-255
注: 另一台三层交换机同样的配置,可以设置vlan 2为活动主

[Huawei]display vrrp brief #查看vrrp摘要信息

===============================================================
网络负载均衡

network_day05===============================================================================

综合拓扑 :搭建企业网络
1,规划ip,vlan
2,链接终端设备线缆到接入层交换机(S3700)
3,在所有接入层交换机创建vlan10,vlan20,vlan30,vlan40
   vlan  batch  10 20 30 40
4,将接入终端设备所在的接口加入相应vlan
	in e0/0/5
	port link-type access
	port default vlan 10		//注意第一台加vlan10,第二台加vlan20,以此类推,最后使用 display vlan检查
5,在vlan40的接入层交换机中配置链路聚合
	interface eth-trunk 1
	trunkport ethernet 0/0/1 0/0/2
	interface eth-trunk 2
	trunkport ethernet 0/0/3 0/0/4
	然后使用查询所有配置检查结果 dis current-configuration
6,添加S5700两台,作为网关设备,并将链接vlan40的设备接口进行链路聚合的配置
	第一台S5700
	interface eth-trunk 1
	trunkport gigabitethernet 0/0/4 0/0/5
	第二台S5700
	interface eth-trunk 2
	trunkport gigabitethernet 0/0/4 0/0/5
7,在两台S5700上分别创建vlan10,vlan20,vlan30,vlan40
8,将两台S5700用线缆链接
9,将所有交换机之间的链路都配置为trunk
	注意:链路聚合的接口要进入聚合口中配置
	interface eth-trunk 1
	port link-type trunk
	port trunk allow-pass vlan all
	普通接口配置:
	interface ethernet 0/0/1      //注意,百兆口和千兆口区分
	port link-type trunk
	port trunk allow-pass vlan all
	当接口数量较多时可以用接口组
	S5700交换机:	
	port-group 1
	group-member g0/0/1 to g0/0/3 g0/0/6
	port link-type trunk
	port trunk allow-pass vlan all
10,给第一台S5700配置ip
	vlan10  192.168.10.252
	vlan20  192.168.20.252
	vlan30  192.168.30.252
	vlan40  192.168.40.252
     给第二台S5700配置ip
	vlan10  192.168.10.253
	vlan20  192.168.20.253
	vlan30  192.168.30.253
	vlan40  192.168.40.253
然后使用每个vlan的pc主机测试与本vlan网关的链接状况
比如用192.168.10.1  去 ping  192.168.10.252 和 192.168.10.253

11,配置网关设备开启vrrp,实现虚拟网关功能,并达到负载均衡
	第一台S5700负责担任vlan10,vlan20的主
		            负责担任vlan30,vlan40的备份
	interface vlanif10
	vrrp vrid 10 virtual-ip 192.168.10.254
	vrrp vrid 10 priority 110
	interface vlanif20
	vrrp vrid 20 virtual-ip 192.168.20.254
	vrrp vrid 20 priority 110
	interface vlanif30
	vrrp vrid 30 virtual-ip 192.168.30.254
	interface vlanif40
	vrrp vrid 40 virtual-ip 192.168.40.254
	然后使用 dis vrrp brief检查
	第二台S5700负责担任vlan10,vlan20的备份
		            负责担任vlan30,vlan40的主
	interface vlanif10
	vrrp vrid 10 virtual-ip 192.168.10.254
	interface vlanif20
	vrrp vrid 20 virtual-ip 192.168.20.254
	interface vlanif30
	vrrp vrid 30 virtual-ip 192.168.30.254
	vrrp vrid 30 priority 110
	interface vlanif40
	vrrp vrid 40 virtual-ip 192.168.40.254
	vrrp vrid 40 priority 110
12,添加两台连接公网的路由器,并配置ip地址,另外两台S5700也配置连接路由器的地址
13,在路由器与S5700配置动态路由
	路由器1
	ospf 1
	area 0
	network 192.168.50.0 0.0.0.255
	network 192.168.70.0 0.0.0.255
	路由器2
	ospf 1
	area 0
	network 192.168.60.0 0.0.0.255
	network 192.168.80.0 0.0.0.255
	第一台S5700
	ospf 1
	area 0
	network 192.168.10.0 0.0.0.255
	network 192.168.20.0 0.0.0.255
	network 192.168.30.0 0.0.0.255
	network 192.168.40.0 0.0.0.255
	network 192.168.50.0 0.0.0.255
	network 192.168.60.0 0.0.0.255
	第二台S5700
	ospf 1
	area 0
	network 192.168.10.0 0.0.0.255
	network 192.168.20.0 0.0.0.255
	network 192.168.30.0 0.0.0.255
	network 192.168.40.0 0.0.0.255
	network 192.168.70.0 0.0.0.255
	network 192.168.80.0 0.0.0.255
14,配置外网ip
15,在所有路由器配置默认路由,在ospf中宣告默认路由
[Huawei]ip route-static 0.0.0.0 0.0.0.0 100.0.0.10
[Huawei]ospf
[Huawei-ospf-1]default-route-advertise always  #宣告默认路由
16,在所有路由器中配置nat使内外网互联
	使用acl定义范围
	acl 2000
	rule permit source any
	再使用easy ip连接外网
	interface g0/0/2
	nat outbound 2000
最终使用任何pc主机可以ping通外网的100.0.0.10则成功


5.shell========================================================================================

shell_day01====================================================================================

Shell环境及特性

什么是Shell
  Shell是在Linux内核与用户之间的解释器程序，通常指的是bash，负责向内核翻译及传达用户/程序指令
 
shell的使用方式：
  1.交互执行指令：人工干预，执行效率底。
  2.非交互执行指令：安静地在后台执行，执行效率高，方便写脚本。
  若需要临时使用另一种Shell环境，可以直接执行对应的Shell解释器程序，比如只要执行ksh可以切换到ksh命令行环境。

常见的Shell环境
    通过usermod chsh更改登录shell
    手动执行目标shell程序
[root@server0 ~]# cat /etc/shells      
/bin/sh           #多数Unix默认的Shell
/bin/bash         #多数Linux默认使用的Shell
/sbin/nologin     #非登录
/usr/bin/sh
/usr/bin/bash
/usr/sbin/nologin
/bin/tcsh
/bin/csh
/bin/ksh

/bin/bash 优势: 快捷键 历史记录 tab键 重定向 管道 别名

更改登录用户的解释器程序
[root@server0 ~]# useradd zhangsan
[root@server0 ~]# grep 'zhangsan' /etc/passwd
zhangsan:x:1003:1003::/home/zhangsan:/bin/bash
[root@server0 ~]# usermod -s /bin/ksh zhangsan  #修改用户解释器
[root@server0 ~]# grep 'zhangsan' /etc/passwd
zhangsan:x:1003:1003::/home/zhangsan:/bin/ksh

什么是Shell脚本
   提前写好可执行语句,能够完成特定任务的文件
   顺序 批量化的处理
   解析型程序

规范的脚本构成
  #!脚本环境声明
  #注释信息
  可执行的语句

shell脚本编写的三个步骤
1.声明所用解释器
2.写脚本功能描述,变量含义,使用位置,作者等信息
3.编写执行的命令

[root@server0 ~]# vim /etc/profile 
HISTSIZE=200 
[root@server0 ~]# cat .bash_history #历史记录文件

=================================================================
脚本执行方法
1.添加x权限
例:
[root@server0 ~]# chmod +x /opt/2.sh
2.使用解释器直接执行脚本
例:
[root@server0 ~]# bash /opt/1.sh
3.使用source直接执行脚本,新开启解释器
例:
[root@server0 ~]# source /opt/1.sh   #执行完成后退出当前解释器(脚本里包含exit)

例:
[root@server0 zhai]# vim /opt/1.sh
#!/bin/bash
echo "zhaiyanquan hello"
#sleep 1000
mkdir zhai
cd zhai
[root@server0 ~]# source /opt/1.sh  #使用source执行脚本直接进入目录zhai下
zhaiyanquan hello
[root@server0 zhai]# 
或
[root@server0 ~]# bash /opt/1.sh  #使用bash执行脚本创建zhai目录,但是不能进入zhai目录.
zhaiyanquan hello

=================================================================
Shell变量

什么是变量:
   以固定名称存储,可能会变化的值
   提高脚本对任务需求 运行环境变化的适应能力
   方便在脚本中重复使用

变量的名=变量的值

变量：
1.自定义变量，使用大小写字母，数字，下划线，不能以数字开头，不能使用特殊符号
2.系统变量，包含环境变量，预定义变量，位置变量，大部分是系统已经定义好的，直接使用

环境变量: PWD当前位置  USER当前用户名  HOSTNAME主机名  SHELL当前用户的解释器  HOME当前用户的家目录  
UID当前用户的UID号  PATH系统命令所在地  PS1一级提示符  PS2二级提示符
例：查看当前位置使用  echo $PWD
例:
[root@server0 ~]# echo $PS1
[\u@\h \W]\$
[root@server0 ~]# echo $PS2
>

修改PS1一级提示符
[root@desktop0 ~]# PS1='#####'
#####
#####PS1='[\u@\h \W]\$'

修改 PS2二级提示符
[root@desktop0 ~]# PS2='=====>>'
[root@desktop0 ~]# ls \
=====>>

[root@desktop0 ~]# a=100
[root@desktop0 ~]# echo ${a}b
100b

查看所有环境变量
[root@server0 ~]# env 

查看所有变量
[root@server0 ~]# set

取消变量
[root@server0 ~]# a=100
[root@server0 ~]# echo $a
100
[root@server0 ~]# unset a  #取消变量a
[root@server0 ~]# echo $a

预定义变量: 用来保存脚本执行的信息
注意: 直接使用这些变量 不能直接为这些变量赋值
$* 显示所有位置变量的值
$0 显示当前所在的进程或脚本名
$# 统计位置变量的个数
$$ 当前程序的进程号
$? 上一条指令的执行结果，0是正确，非0是异常
例:
[root@server0 ~]# echo $$
2307

位置变量: $1 $2 $3 $4 等等

三种引号对变量赋值的影响
' ' 单引号: 界定一个完整的字符串,并且可以实现屏蔽特殊符号的功能
例:
[root@server0 ~]# a=200
[root@server0 ~]# echo '$a' #取消$符号功能
$a
"" 双引号: 界定一个完整的字符串
例:
[root@server0 ~]# mkdir "c d"
[root@server0 ~]# ls -ld "c d"
drwxr-xr-x. 2 root root 6 5月   8 16:12 c d
反撇号``或$():  使用反撇号或$()时，可以将命令执行的标准输出作为字符串存储，因此称为命令替换
例:
[root@server0 ~]# a=$(ls)
[root@server0 ~]# echo $a

read命令从键盘读取变量值
例:
[root@svr5 ~]# read -p "请输入一个整数：" i
请输入一个整数：240
[root@svr5 ~]# echo $i
240

stty终端显示控制
将回显功能关闭（stty -echo）
将回显功能恢复（stty echo）
例:
[root@server0 ~]# vim /opt/user.sh
#!/bin/bash
read -p "请输入用户名:" u
useradd $u
stty -echo   #使输入密码时不显示
read -p "请输入密码:" p
stty echo    #将回显功能恢复
echo $p | passwd --stdin $u

从键盘录入信息时，不在屏幕显示
read -s -p "dsfsdaf:" n

[root@server0 ~]# cat /etc/shadow  #查看用户密文

export发布全局变量
例:
[root@server0 ~]# export zyq=1000 #在所有解释器都可以用
[root@server0 ~]# bash
[root@server0 ~]# echo $zyq
1000
[root@server0 ~]# bash
[root@server0 ~]# echo $zyq
1000
[root@server0 ~]# ksh
# echo $zyq
1000
#  

=======================================================
Shell中的数值运算

整数运算工具
1)使用expr命令
例:
[root@server0 ~]# a=10           #定义变量a
[root@server0 ~]# expr $a + 10   #加法
20
[root@server0 ~]# expr $a - 1    #减法
9
[root@server0 ~]# expr $a \* 10  #乘法，操作符应添加\转义
100
[root@server0 ~]# expr $a / 3    #除法，仅保留整除结果
3
[root@server0 ~]# expr $a % 6    #求模
4

2)使用$[]或$(())表达式
例:
[root@server0 ~]# a=10
[root@server0 ~]# echo $[a+10]
20
[root@server0 ~]# echo $((a+10))
20
[root@server0 ~]# echo $[a-10]
0
[root@server0 ~]# a=10
[root@server0 ~]# echo $((a-1))
9
[root@server0 ~]# echo $[a*10]
100
[root@server0 ~]# echo $((a*10))
100
[root@server0 ~]# echo $((a/3))
3
[root@server0 ~]# echo $[a/3]
3
[root@server0 ~]# echo $((a%3))
1
[root@server0 ~]# echo $[a%3]
1

3)使用let命令
例:
[root@server0 ~]# a=10
[root@server0 ~]# let a+=10   #a=a+10
[root@server0 ~]# echo $a
20
[root@server0 ~]# let a-=10   #a=a-10
[root@server0 ~]# echo $a
10
[root@server0 ~]# let a*=10   #a=a*10
[root@server0 ~]# echo $a 
100
[root@server0 ~]# let a/=2    #a=a/2
[root@server0 ~]# echo $a
50
[root@server0 ~]# let a%=4    #a=a%4
[root@server0 ~]# echo $a
2

小数运算工具
1）bc交互式运算
例:
[root@server0 ~]# bc
10-2.2
7.8
11.6+3.5
15.1
2.2*10
22.0
10/3
3
scale=3  #scale定义小数点的长度
10/3
3.333

2）bc非交互式运算
例:
[root@server0 ~]# echo '10.2+89' | bc
99.2
[root@server0 ~]# echo 'scale=3; 10/3' | bc
3.333

shell_day02====================================================================================

条件测试操作
  字符串匹配
  比较整数值的大小
  识别文件/目录的状态
  多个条件/操作的逻辑组合

test语法格式
“test 表达式”或者[ 表达式 ]都可以，表达式两边至少要留一个空格。
1)== 比较两个字符串是否相同
例:
[root@server0 ~]# test fds == sdf 
[root@server0 ~]# echo $?
1
或
[root@server0 ~]# [ fds == sdf ]
[root@server0 ~]# echo $?
1

2）!= 比较两个字符串是否不相同
[root@server0 ~]# [ $UID != "0" ]
[root@server0 ~]# echo $?
1
或
[root@server0 ~]# su - student
[student@server0 ~]$ [ $UID != "0" ]
[student@server0 ~]$ echo $?
0

3）一行执行多条命令的情况
&& 前面命令成功后才执行后面命令（和）
例:
[root@server0 ~]# [ zhai == zhai ] && ls
anaconda-ks.cfg  Documents  Music     Public     Videos
Desktop          Downloads  Pictures  Templates
||　前面命令失败后才执行后面命令（或）
例:
[root@server0 ~]# [ zhai != zhai ] || ls
anaconda-ks.cfg  Documents  Music     Public     Videos
Desktop          Downloads  Pictures  Templates
;　前面命令执行后再执行后面命令，无逻辑关系
例：
[root@server0 ~]# [ zhai != zhai ] ; ls
anaconda-ks.cfg  Documents  Music     Public     Videos
Desktop          Downloads  Pictures  Templates

[root@server0 ~]# [ zhai == zhai ] && echo "ok" || echo "no"
ok
[root@server0 ~]# [ zhai != zhai ] && echo "ok" || echo "no"
no
[root@server0 ~]# [ zhai != zhai ] || echo "ok" || echo "no"
ok
[root@server0 ~]# [ zhai != zhai ] || echo "ok" 
ok

4) -z 检查变量的值是否未设置（判断变量是否为空值）
例：
[root@server0 ~]# [ -z b ]　　＃ｂ是空值
[root@server0 ~]# echo $?
1
[root@server0 ~]# [ ! -z b ]  #!是取反
[root@server0 ~]# echo $?
0

==============================================================
整数值比较
参与比较的必须是整数（可以调用变量），比较非整数值时会出错

-eq 等于 (比较两个数是否相等)
-gt 大于 (比较前面的整数是否大于后面的整数)
-ge 大于等于 (比较前面的整数是否大于或等于后面的整数)
-ne 不等于 (比较两个数是否不相等)
-lt 小于 (比较前面的整数是否小于后面的整数)
-le 小于等于 (比较前面的整数是否小于或等于后面的整数)
例:
[root@server0 ~]# [ $a -eq 10 ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ $a -gt 8 ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ $a -ge 8 ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ $a -lt 20 ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ $a -le 10 ]
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ $a -ne 30 ]
[root@server0 ~]# echo $?
0

提取当前登录的用户数，比较是否大于等于3
例:
[root@server0 ~]# who | wc -l

每2分钟向root用户发送邮件当前人数登录信息
例:
[root@server0 ~]# crontab -e -u root  #或 [root@server0 ~]# crontab -e
*/2 * * * * chmod +x /opt/zhai.sh  #给脚本添加x权限
*/2 * * * * /opt/zhai.sh
[root@server0 ~]# vim /opt/zhai.sh
#!/bin/bash
n=$(who | wc -l)
[ $n -ge 3 ] &&  echo "现在有$n人登录系统" | mail -s "zhai"  root
[root@server0 ~]# mail -u root #查看邮件

====================================================================
识别文件与目录的状态

1）-e 判断对象是否存在（不管是目录还是文件）
例:
[root@server0 ~]# [ -e zhai ] #文档存在时
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ -e zha ]  #文档不存在时
[root@server0 ~]# echo $?
1

2）-d 判断对象是否为目录（存在且是目录）
例:
[root@server0 ~]# [ -d zhai ] #目录存在时
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ -d zha ]  #目录不存在时
[root@server0 ~]# echo $?
1

3)-f 判断对象是否为文件（存在且是文件）
例:
[root@server0 ~]# [ -f /yan.txt ]  #文件存在时
[root@server0 ~]# echo $?
0
[root@server0 ~]# [ -f /ya.txt ]  #文件不存在时
[root@server0 ~]# echo $?
1

[root@server0 ~]# ls -ld /quan.txt
-rw-r--r--. 1 root root 4 5月   9 14:25 /quan.txt

4）-r 判断对象是否可读
此测试对root用户无效，无论文件是否设置r权限，root都可读：
例:
[root@server0 ~]# [ -r /quan.txt ]
[root@server0 ~]# echo $?
0

5）-w 判断对象是否可写
此测试同样对root用户无效，无论文件是否设置w权限，root都可写：
例:
[root@server0 ~]# [ -w /quan.txt ]
[root@server0 ~]# echo $?
0

6）-x 判断对象是否具有可执行权限
这个取决于文件本身、文件系统级的控制，root或普通用户都适用：
例:
[root@server0 ~]# [ -x /quan.txt ]
[root@server0 ~]# echo $?
1

文件没有任何权限,root用户一样可以对文件读写,但不能执行,其它用户没有任何读写执行操作
[root@server0 ~]# ls -ld /quan.txt
----------. 1 root root 4 5月   9 14:25 /quan.txt
[root@server0 ~]# echo 5634 >> /quan.txt
[root@server0 ~]# cat /quan.txt
123
5634

====================================================================
多个条件与操作的逻辑组合

1）&&，逻辑与
给定条件必须都成立，整个测试结果才为真。
检查变量X的值是否大于10，且小于30：
例:
[root@svr5 ~]# X=20                      //设置X变量的值为20
[root@svr5 ~]# [ $X -gt 10 ] && [ $X -lt 30 ] && echo "YES"
YES

2）||，逻辑或
只要其中一个条件成立，则整个测试结果为真。
只要/tmp/、/var/spool/目录中有一个可写，则条件成立：
[root@svr5 ~]# [ -w "/tmp/" ] || [ -w "/var/spool/" ] && echo "OK"
OK

if单分支的语法组成：
if  条件测试 ;then  
命令序列
fi
例:
if [ ! -f zhai.txt ];then
    touch zhai.txt
fi 

if双分支的语法组成：
if  条件测试 ;then
命令序列1
else  
命令序列2
fi
ping -c 限定次数 -i 限定ping间隔时间 -W 等待反馈时间 172.25.0.100
例:
[root@server0 ~]# vim /opt/ping.sh
#!/bin/bash
read -p "请输入IP地址:" p
ping -c 4 -i 0.2 -W 1 $p &> /dev/null
if [ $? -eq 0 ];then
    echo "可以通信"
else
    echo "不可以通信"
fi
[root@server0 ~]# chmod +x /opt/ping.sh

if多分支的语法组成：
if   条件测试1 ;then  
命令序列1
elif  条件测试2 ;then  
命令序列2
else
命令序列n
fi

例:
[root@server0 ~]# vim /random.sh
#!/bin/bash
n=$[RANDOM%11]
read -p "请输入数字(0-10):" s
if [ $n -eq $s ];then
     echo "你猜对了!"
elif [ $n -lt $s ];then
     echo "你猜大了!"
else
     echo "你猜小了!"
fi
echo $n
[root@server0 ~]# chmod +x /random.sh

===========================================================
使用for循环结构
for  变量名  in  值列表
do
    命令序列
done
例:
[root@server0 ~]# chmod +x /for.sh
#!/bin/bash
for i in {1..12}
do
      ping -c 2 -i 0.2 -W 1 172.25.0.$i &> /dev/null
      if [ $? -eq 0 ];then
          echo "172.25.0.$i ok" 
      else
          echo "172.25.0.$i no" 
      fi
done
[root@server0 ~]# chmod +x /for.sh

=============================================================
使用while循环结构
while  条件测试
do
    命令序列
done
例:
有效循环脚本：
例:
[root@svr5 ~]# vim while02.sh
#!/bin/bash
i=1
while [ $i -le 5 ]
do
        echo "$i"
        let i++
done
[root@svr5 ~]# chmod +x while02.sh
[root@svr5 ~]# ./while02.sh

无心的死循环脚本：
例:
[root@svr5 ~]# vim while01.sh
#!/bin/bash
i=1
while [ $i -le 5 ]
do
        echo "$i"
done
[root@svr5 ~]# chmod +x while01.sh
[root@svr5 ~]# ./while01.sh          #死循环，需要使用Ctrl+C终止脚本

死循环的一般格式
[root@server0 ~]# vim /while2.sh
#!/bin/bash
n=$[RANDOM%101]
x=0
while :
do
    read -p "请输入数字(0-100):" s
    let x++
    if [ $n -eq $s ];then
        echo "你猜对了"
        echo " 你猜对了 总猜${x}次  中奖码:${n}"
        exit
    elif [ $s -gt $n ];then
          echo "你猜大了"
    else
          echo "你猜小了"
    fi
done
[root@server0 ~]# chmod +x /while2.sh

shell_day03====================================================================================

基于case分支编写脚本

case分支属于匹配执行的方式，它针对指定的变量预先设置一个可能的取值，判断该变量的实际取值是否与预设的某一个值相匹配，
如果匹配上了，就执行相应的一组操作，如果没有任何值能够匹配，就执行预先设置的默认操作。case分支的语法结构如下所示：
case  变量  in
模式1)
    命令序列1 ;;
模式2)
    命令序列2 ;;
    .. ..
*)
    默认命令序列
esac
例:
[root@server0 ~]# vim /case.sh
#!/bin/bash
case $1 in
start|sta) #输入start或sta
   /usr/local/nginx/sbin/nginx ;;
stop|sp) #输入stop或sp
   /usr/local/nginx/sbin/nginx -s stop ;;
restart)
   /usr/local/nginx/sbin/nginx -s stop
   /usr/local/nginx/sbin/nginx ;;
status)
   netstat -ntulp | grep -q nginx
   [ $? -eq 0 ] && echo "服务启动" || echo "服务未启动" ;;
*)
echo "start|stop|restart|status" ;;  
esac

====================================================================
编写一键部署软件脚本

1）依赖包
源码安装Nginx需要提前安装依赖包软件gcc,openssl-devel,pcre-devel
#将真机桌面的nginx-1.12.2.tar.gz上传到虚拟机sever
[root@room12pc2 桌面]# scp -r nginx-1.12.2.tar.gz root@172.25.0.11:/root

[root@server0 sbin]# vim /ngin.sh
#/bin/bash
yum -y install gcc openssl-devel pcre-devel
tar -xf /root/nginx-1.12.2.tar.gz
cd nginx-1.12.2
./configure
make
make install
[root@server0 sbin]# chmod +x /ngin.sh
[root@server0 sbin]# netstat -ntulp | grep nginx

2）确认安装效果
Nginx默认安装路径为/usr/local/nginx,该目录下会提供4个子目录，分别如下：
/usr/local/nginx/conf	配置文件目录
/usr/local/nginx/html	网站页面目录
/usr/local/nginx/logs	Nginx日志目录
/usr/local/nginx/sbin	主程序目录
主程序命令参数：
[root@svr5 ~]# /usr/local/nginx/sbin/nginx           #启动服务,首先没其它服务使用80端口为前提
[root@svr5 ~]# /usr/local/nginx/sbin/nginx -s stop   #关闭服务
[root@svr5 ~]# /usr/local/nginx/sbin/nginx    -V     #查看软件信息
[root@server0 sbin]# netstat -ntulp | grep -q nginx  #查看服务状态,-q是在屏幕不回显

启动脚本
脚本通过位置变量$1读取用户的操作指令，判断是start、stop、restart还是status。
netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：
-n以数字格式显示端口号
-t显示TCP连接的端口
-u显示UDP连接的端口
-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
-p显示监听端口的服务名称是什么（也就是程序名称）
例:
[root@server0 ~]# vim /case.sh
#!/bin/bash
case $1 in
start)
   /usr/local/nginx/sbin/nginx ;;
stop)
   /usr/local/nginx/sbin/nginx    -s stop ;;
restart)
   /usr/local/nginx/sbin/nginx    -s stop
   /usr/local/nginx/sbin/nginx ;;
status)
   netstat -ntulp | grep -q nginx
   [ $? -eq 0 ] && echo "服务启动" || echo "服务未启动" ;;
*)
echo "start|stop|restart|status" ;;
esac

====================================================================
使用Shell函数

在Shell脚本中，将一些需重复使用的操作，定义为公共的语句块，即可称为函数。通过使用函数，可以使脚本代码更加简洁，
增强易读性，提高Shell脚本的执行效率
1）函数的定义方法

格式1：
function  函数名 {
    命令序列
    .. ..
}
例:
[root@server0 ~]# vim /b.sh
#!/bin/bash
function b {  #b是函数名,自定义
   echo 654
}
b #调用函数
[root@server0 ~]#chmod +x /b.sh

格式2：
函数名() {
    命令序列
    .. ..
}
例:
[root@server0 ~]# vim /a.sh
a(){  #a是函数名,自定义
echo 123
echo rewr
}
a #调用函数
[root@server0 ~]#chmod +x /a.sh

3X为字体颜色，4X为背景颜色。
格式: -e \033[数字m文本\033[0m
例:
[root@server0 ~]# echo -e "\033[32mzhaiy\033[0m"
zhaiy

格式: echo -e "\033[字背景颜色;字体颜色m字符串\033[0m" 
例如: 
echo -e "\033[41;36m something here \033[0m" 
其中41的位置代表底色, 36的位置是代表字的颜色 
那些ascii code 是对颜色调用的始末. 
\033[ ; m …… \033[0m 

字背景颜色范围:40----49 
40:黑 
41:深红 
42:绿 
43:黄色 
44:蓝色 
45:紫色 
46:深绿 
47:白色 
字颜色:30-----------39 
30:黑 
31:红 
32:绿 
33:黄 
34:蓝色 
35:紫色 
36:深绿 
37:白色 
===============================================ANSI控制码的说明 
\33[0m 关闭所有属性 
\33[1m 设置高亮度 
\33[4m 下划线 
\33[5m 闪烁 
\33[7m 反显 
\33[8m 消隐 
\33[30m -- \33[37m 设置前景色 
\33[40m -- \33[47m 设置背景色 
\33[nA 光标上移n行 
\33[nB 光标下移n行 
\33[nC 光标右移n行 
\33[nD 光标左移n行 
\33[y;xH设置光标位置 
\33[2J 清屏 
\33[K 清除从光标到行尾的内容 
\33[s 保存光标位置 
\33[u 恢复光标位置 
\33[?25l 隐藏光标 
\33[?25h 显示光标
--------------------- 
作者：JoinChao 
来源：CSDN 
原文：https://blog.csdn.net/qq_35964941/article/details/70226181 
版权声明：本文为博主原创文章，转载请附上博文链接！

Shell脚本的fork炸弹: 会导致机器死机
[root@svr5 ~]# vim test.sh
#!/bin/bash
.(){
.|.&
}
.
或
[root@svr5 ~]# vim test.sh
#!/bin/bash
a(){
a|a&
}
a
[root@svr5 ~]# chmod +x /test.sh

==============================================================
中断及退出

通过break、continue、exit在Shell脚本中实现中断与退出的功能

exit 结束整个脚本
break 可以结束整个循环
continue 结束本次循环,进行下一次循环

break 可以结束整个循环
例:
[root@server0 ~]# vim /he.sh
#!/bin/bash
n=0
while :
do
    read -p "请输入一个数字(0是结束):" s
    [ $s -eq 0 ] && break  
    let n+=s
done
echo "总和是$n"
[root@server0 ~]# chmod +x /he.sh

continue 结束本次循环,进行下一次循环
例:
#!/bin/bash
n=0
for i in {1..20}
do
     n=$[i%6]
     [ $n -ne 0 ] && continue
     echo $[i*i] 
done
[root@server0 ~]# chmod +x /test.sh

====================================================================
字符串截取及切割

子串截取的用法：
${变量名:起始位置:长度}

子串替换的两种用法：
     只替换第一个匹配结果：${变量名/old/new}
     替换全部匹配结果：${变量名//old/new}


字符串掐头去尾：
   从左向右，最短匹配删除：${变量名#*关键词}
   从左向右，最长匹配删除：${变量名##*关键词}
   从右向左，最短匹配删除：${变量名%关键词*}
   从右向左，最长匹配删除：${变量名%%关键词*}

字符串的截取
1）使用 ${}表达式
   格式：${变量名:起始位置:长度}
   使用${}方式截取字符串时，起始位置是从0开始的。
例:
[root@server0 ~]# zyq=zhaiyanquan
[root@server0 ~]# echo ${zyq:0:4} #0是截取位置,4是截取长度
zhai
[root@server0 ~]# echo ${zyq:1:4}
haiy
[root@server0 ~]# echo ${#zyq} #确认其字符串长度
11

一个随机密码(8位)
例:
[root@server0 ~]# vim /test.sh
#!/bin/bash
x=qwertyuiopasdfghjklzxcvbnmQWERTYUIOPASDFGHJKLZXCVBNM1234567890
for i in {1..8}
do
n=$[RANDOM%62]
pass=${x:n:1}
pass1=$pass1$pass
done
echo $pass1
[root@server0 ~]# chmod +x /test.sh
或
[root@room9pc01 ~]# p=$(cat /dev/random | tr -dc 'A-Za-z0-9!@# ?' | head -c 8) #随机密码8位

==================================================================
字符串的替换

1）只替换第1个子串
格式：${变量名/old/new}
例:
[root@server0 ~]# zyq=abcabc
[root@server0 ~]# echo ${zyq/a/m}
mbcabc

2）替换全部子串
格式：${变量名//old/new}
将phone字符串中的所有8都替换为X:
例:
[root@server0 ~]# zyq=abcabc
[root@server0 ~]# echo ${zyq//b/n}
ancanc

==================================================================
字符串的匹配删除

1）从左向右，最短匹配删除
格式：${变量名#*关键词}
删除从左侧第1个字符到最近的关键词“：”的部分，* 作通配符理解：
例:
[root@server0 ~]# a=$(head -1 /etc/passwd)
[root@server0 ~]# echo $a
root:x:0:0:root:/root:/bin/bash
[root@server0 ~]# echo ${a#*:} #删除第一个冒号前的字符串
x:0:0:root:/root:/bin/bash

2）从左向右，最长匹配删除
格式：${变量名##*关键词}
删除从左侧第1个字符到最远的关键词“:”的部分：
例:
[root@server0 ~]# a=$(head -1 /etc/passwd)
[root@server0 ~]# echo $a
root:x:0:0:root:/root:/bin/bash
[root@server0 ~]#  echo ${a#root} #从左往右删除第一个root
:x:0:0:root:/root:/bin/bash
[root@server0 ~]#  echo ${a#*:}   #从左往右删除第一个冒号,以及冒号左边所有
x:0:0:root:/root:/bin/bash
[root@server0 ~]# echo ${a##*:}   #从左往右删除最后一个冒号,以及冒号左边所有
/bin/bash

3）从右向左，最短匹配删除
格式：${变量名%关键词*}
删除从右侧最后1个字符到往左最近的关键词“:”的部分，* 做通配符理解：
例:
[root@server0 ~]# a=$(head -1 /etc/passwd)
[root@server0 ~]# echo $a
root:x:0:0:root:/root:/bin/bash
[root@server0 ~]#  echo ${a%root} #从右往左删除第一个root
root:x:0:0:root:/root:/bin/bash
[root@server0 ~]#  echo ${a%:*}   #从右往左删除第一个冒号,以及冒号左边所有
root:x:0:0:root:/root
[root@server0 ~]# echo ${a%%:*}   #从右往左删除最后一个冒号,以及冒号右边所有
root

=====================================================================
批量修改文件扩展名的脚本

例:
[root@server0 ~]# cd /zhai
[root@server0 zhai]# touch {1..10}.txt
[root@server0 ~]# vim /doc.sh
#!/bin/bash
for i in $(ls /zhai/*.txt)
do
     m=${i%.*}
     mv $i $m.doc
done
改进版脚本(批量修改扩展名)
[root@svr5 rendir]# vim /doc.sh
#!/bin/bash
#version:2
for i in `ls *.$1`
do
    mv $i  ${i%.*}.$2
done

=======================================================================
字符串初值的处理
    通过${var:-word}判断变量是否存在，决定变量的初始值

shell_day04====================================================================================

基本正则表达式

  什么是正则表达式
        使用"一串符号"来描述有共同属性的数据 

^ 匹配行首(以什么什么为开头的行)
例:
[root@server0 ~]# grep "^root" /etc/passwd
root:x:0:0:root:/root:/bin/bash

& 匹配行尾(以什么什么为结尾的行)
例:
[root@server0 ~]# grep "bash$" /etc/passwd
root:x:0:0:root:/root:/bin/bash
student:x:1000:1000:Student User:/home/student:/bin/bash
u:x:1001:1001::/home/u:/bin/bash
fdsf:x:1002:1002::/home/fdsf:/bin/bash
gfd:x:1003:1003::/home/gfd:/bin/bash

[ ] 查找有字符a或b的行(集合,匹配集合中的任意单个字符)
例:
[root@server0 ~]# cat /zhai.txt
abc
aaa 
asaaa
[root@server0 ~]# grep "[ab]" /zhai.txt
abc
aaa
xyzaaa
或
[root@localhost ~]# egrep 'root[:]' /etc/passwd  #匹配root右边接有：

同时查找多个以什么什么开头
例:
[root@client ~]# grep -E '^(root|daemon)' /etc/passwd

-q 不显示查找到信息
例:
[root@zhai ~]# grep -q '^127.0.0.1' /etc/hosts && echo "dfas" || echo "fds"

[^] 对集合取反
例:
[root@server0 ~]# grep "[a^]" /zyq.txt #查找包含a的行
abc
qqdfa
dsaf098
dsa
sa
[root@server0 ~]# grep "[^a]" /zyq.txt #查找包含a的行和不包含a的行
abc
qqdfa
dsaf098
dsa
sa
yy

==================================================================
扩展正则表达式

egrep过滤工具
   文本处理顺序: 以行为单位,逐行处理
   默认只输出与表达相匹配的文本行
基本用法
   格式1: egrep [选项] '正则表达式'  文件..
   格式2: 前置命令 | egrep [选项] '正则表达式'

常用命令选项
  -i： 忽略字母大小写
  -v: 条件取反
  -c: 统计匹配的行数
  -q: 静默 无任何输出 一般用于检测
  -n: 显示出匹配结果所在的行号
 --color: 标红显示匹配字串

egrep 等价于 grep -E
grep -E或egrep命令

-m 匹配前几行
例：
[root@server0 ~]# egrep -m3 "bash$" /etc/passwd #以字符串bash行尾的行，只匹配3行

-c 输出匹配行数
与通过管道再 wc -l的效果是相同的，但是写法更简便。
例：
[root@server0 ~]# egrep -c "bin/bash$" /etc/passwd
或
[root@server0 ~]# egrep "bin/bash$" /etc/passwd | wc -l

输出空行
[root@server0 ~]# egrep -v "." /etc/rc.local
或
[root@server0 ~]# egrep "^$" /etc/rc.local

{n,m} 匹配n次到m次
例:
[root@server0 ~]# cat /zhai.txt
abc
aaa
xyzaaa
ccc
[root@server0 ~]# egrep "a{2,3}" /zhai.txt #查找a出现2次到3次的行
aaa
xyzaaa

{n} 匹配前一个字符n次
例:
[root@server0 ~]# cat /zhai.txt
abc
aaa
xyzaaa
ccc
[root@server0 ~]# egrep "a{2}" /zhai.txt
aaa
xyzaaa
或
[root@server0 ~]# cat /zhai02.txt
good
goood
goooood
[root@server0 ~]# egrep "go{2}d" /zhai02.txt
good

{n,}  匹配前一个字符n次以上
例:
[root@server0 ~]# cat /zhai.txt
abc 
aaa 
xyzaaa 
ccc
[root@server0 ~]# egrep "a{2,}" /zhai.txt  #查找a出现2次以及2次以上的行
aaa
xyzaaa

+ 最少匹配一次(至少出现一次)
例:
[root@server0 ~]# cat /zhai.txt
abc 
aaa 
xyzaaa 
ccc
[root@server0 ~]# egrep "a+" /zhai.txt  #查找a出现1次以及1次以上的行,相当于"a{1,}"
abc
aaa
xyzaaa

? 最多匹配一次(最多出现一次（可能没有）)
例:
[root@server0 ~]# cat /zhai.txt
abc
aaa
xyzaaa
ccc
[root@server0 ~]# egrep "a?" /zhai.txt #查找a出现1次或0次的行
abc
aaa
xyzaaa
ccc
或
[root@server0 ~]# egrep "abc?" /zhai.txt  #查找单词abc,其中c可以出现1次或0次
abc

| 或者
例:
[root@server0 ~]# cat  /zhai.txt
abc
aaa
xyzaaa
ccc
[root@server0 ~]# egrep "ab|xy" /zhai.txt #查找包含ab或xy行
abc
xyzaaa
或
[root@server0 ~]# grep -E "(ab|xy)" /zhai.txt
abc
xyzaaa

() 组合为整体,保留
例:
[root@server0 ~]# cat  /zhai03.txt
zyzyzyzyzyzy
zy
[root@server0 ~]# egrep "(zy){2}" /zhai03.txt  #查找单词zy出现了2次的行
zyzyzyzyzyzy

\b 单词边界
例:
[root@server0 ~]# cat /zhai.txt
abc
aaa
xyzaaa
ccc
[root@server0 ~]# egrep "\bab" /zhai.txt #查找单词ab,前面必须与其他字符隔开或前面没有任何字符
abc
或

[A-Z] 包括大写字母的行
例：
[root@localhost ~]# egrep '[A-Z]' /etc/passwd

[a-z] 包括小写字母的行
例：
[root@localhost ~]# egrep '[a-z]' /etc/passwd

过滤“非小写字母”的其它字符
例：
[root@localhost ~]# egrep '[^a-z]' /etc/passwd

\b \b 或\< \>输出包括单词
例：
[root@localhost ~]# egrep '\bboot\b' /etc/rc.local
或
[root@localhost ~]# egrep '\<all\>' /etc/rc.local

\>或\b 输出包括以“ll”结尾的单词的行
[root@server0 ~]#  egrep 'll\>' /etc/rc.local
或
[root@server0 ~]#  egrep 'll\b' /etc/rc.local

输出/etc/passwd文件内“r”开头且以“nologin”结尾的用户记录，即中间可以是任意字符：
[root@svr5 ~]# egrep '^r.*nologin$' /etc/passwd

\w  匹配字母数字下划线 [a-Z0-9]
例:
[root@server0 ~]# cat /zhai04.txt
bc45
_fassdf
reerae9
fdsrt fdsfi
rro{}.ewrwe
[root@server0 ~]# grep "\w" /zhai04.txt  #
bc45
_fassdf
reerae9
fdsrt fdsfi
rro{}.ewrwe

\s 匹配空格,制表符
例:
[root@server0 ~]# cat /zhai04.txt
bc45
_fassdf
reerae9
fdsrt fdsfi
rro{}.ewrwe
[root@server0 ~]# grep "\s" /zhai04.txt  #查找包含空格的行
fdsrt fdsfi

-P \d  匹配数字 [0-9]
例:
[root@server0 ~]# cat /zhai04.txt
bc45
_fassdf
reerae9
fdsrt fdsfi
rro{}.ewrwe
[root@server0 ~]# grep -P "\d" /zhai04.txt
bc45
reerae9

======================================================================
sed基本用法: 流式编辑器,可以查看和编辑文档,
   删除文件中每行的第二个、最后一个字符
   将文件中每行的第一个、第二个字符互换
   删除文件中所有的数字
   为文件中每个大写字母添加括号

sed文本处理工具的用法：
    用法1：前置命令 | sed  [选项]  '条件指令'
    用法2：sed  [选项]  '条件指令'  文件.. ..

sed命令的常用选项如下：
  -n（屏蔽默认输出，默认sed会输出读取文档的全部内容）
  -r（让sed支持扩展正则）
  -i（sed直接修改源文件，默认sed只是通过内存临时修改文件，源文件无影响）
   p  输出文本内容
1）sed命令的 -n 选项
   执行p打印等过滤操作时，希望看到的是符合条件的文本。但不使用任何选项时，默认会将原始文本一并输出，
   从而干扰过滤效果。比如，尝试用sed输出/etc/hosts的第1行

======================================================================
sed的输出

例:
[root@server0 ~]# cat /zhai06.txt
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin

[root@server0 ~]# sed  "p" /zhai06.txt #输出文本所有行,并附加默认输出的行
root:x:0:0:root:/root:/bin/bash
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin

[root@server0 ~]# sed -n  "p" /zhai06.txt #输出文本所有行,没有默认输出的行
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin

[root@server0 ~]# sed -n  "1p" /zhai06.txt #输出文本第一行
root:x:0:0:root:/root:/bin/bash
或
[root@server0 ~]# sed -n  "3p" /zhai06.txt #输出文本第三行
daemon:x:2:2:daemon:/sbin:/sbin/nologin

[root@server0 ~]# sed -n  "2p;4p" /zhai06.txt #输出文本第二行和第三行
bin:x:1:1:bin:/bin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin

[root@server0 ~]# sed -n  "1,3p" /zhai06.txt #输出文本第一行至第三行
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin

[root@server0 ~]# sed -n "1,+2p" /zhai06.txt #输出文本第一行以及后面两行
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin

[root@server0 ~]# sed -n "3,+2p" /zhai06.txt #输出文本第三行以及后面两行
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin

[root@server0 ~]# sed -n "1~2p" /zhai06.txt #输出奇数行
root:x:0:0:root:/root:/bin/bash
daemon:x:2:2:daemon:/sbin:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin

[root@server0 ~]# sed -n "1~2p" /zhai06.txt  #输出偶数行
root:x:0:0:root:/root:/bin/bash
daemon:x:2:2:daemon:/sbin:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
[root@server0 ~]# sed -n "2~2p" /zhai06.txt
bin:x:1:1:bin:/bin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin

[root@server0 ~]# sed -n '/o\{2\}/p' /zhai06.txt  输出有两个连续的o的行
root:x:0:0:root:/root:/bin/bash
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin

-r（sed直接修改源文件，默认sed只是通过内存临时修改文件，源文件无影响）
例:
[root@server0 ~]# sed -rn '/o{2}/p' /zhai06.txt
root:x:0:0:root:/root:/bin/bash
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
[root@server0 ~]# cat /zhai06.txt
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt
[root@server0 ~]# sed -rn '/o{2}/p' /zhai06.txt  #使用扩展正则,输出有两个连续的o的行
root:x:0:0:root:/root:/bin/bash
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin

$=
例:
[root@server0 ~]# sed -n '$=' /zhai06.txt #统计文件有多少行
8

注释掉
[root@svr5 ~]# sed '4,7s/^/#/'   a.txt         //将第4~7行注释掉（行首加#号）

=====================================================================
sed的删除
[root@server0 ~]# sed 'd' /zhai06.txt #删除所有行

[root@server0 ~]# sed '4d' /zhai06.txt #删除第四行
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt

[root@server0 ~]# sed '1,4d' /zhai06.txt #删除第一行至第四行
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt

[root@server0 ~]# sed '1,+2d' /zhai06.txt #删除第一行以及后面两行
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt

[root@server0 ~]# sed '1~2d' /zhai06.txt #删除奇数行
bin:x:1:1:bin:/bin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
halt:x:7:0:halt:/sbin:/sbin/halt

[root@server0 ~]# sed '2~2d' /zhai06.txt #删除偶数行
root:x:0:0:root:/root:/bin/bash
daemon:x:2:2:daemon:/sbin:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown

[root@server0 ~]# sed '/^root/d' /zhai06.txt  #删除以root开头的行
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt

[root@server0 ~]# sed '/root&/d' /zhai06.txt #删除以root结尾的行
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
adm:x:3:4:adm:/var/adm:/sbin/nologin
lp:x:4:7:lp:/var/spool/lpd:/sbin/nologin
sync:x:5:0:sync:/sbin:/bin/sync
shutdown:x:6:0:shutdown:/sbin:/sbin/shutdown
halt:x:7:0:halt:/sbin:/sbin/halt

[root@server0 ~]# cat /z.txt
Hello the world
   Ni haO Ma Beijing 
[root@server0 ~]# sed 's/.//2 ; s/.$//' /z.txt  #删除文件中第一行的第二个、最后一个字符
Hllo the worl
  Ni haO Ma Beijing

删除文件中所有的数字
因原文件内没有数字，行首也没有空格，这里稍作做一点处理，生成一个新测试文件：
[root@svr5 ~]# sed 's/[0-9]//' nssw.txt

====================================================================
set的替换

例:
[root@server0 ~]# cat /zhai07.txt
2017 2011 2018
2017 2017 2024
2017 2017 2017
[root@server0 ~]# sed  's/2017/888/' /zhai07.txt  #把所有行的第1行2017替换888
888 2011 2018
888 2017 2024
888 2017 2017
[root@server0 ~]# sed  's/2017/888/g' /zhai07.txt #把所有行的所有2017替换为888
888 2011 2018
888 888 2024
888 888 888

[root@server0 ~]# sed  's/2017/888/2' /zhai07.txt #把所有行的第二个2017替换为888
2017 2011 2018
2017 888 2024
2017 888 2017

[root@server0 ~]# sed  '3s/2017/888/2' /zhai07.txt #把第三行的第二个2017替换为888
2017 2011 2018
2017 2017 2024
2017 888 2017

把第三行的第二个2017替换为888和把第三行的第三个2017替换为888
[root@server0 ~]# sed  '3s/2017/888/2 ; 3s/2017/888/2' /zhai07.txt 
2017 2011 2018
2017 2017 2024
2017 888 888

[root@server0 ~]# cat p.txt
root:x:0:0:root:/root:/bin/bash
[root@server0 ~]# sed 's!/bin/bash!/sbin/sh!' p.txt #把/bin/bash换成/sbin/sh
root:x:0:0:root:/root:/sbin/sh

[root@server0 ~]# cat /z.txt
Hello the world
ni hao ma beijing 
[root@server0 ~]# sed 's/.//2 ; s/.$//' /z.txt 
Hllo the worl
n hao ma beijing

Hello the world
   Ni haO Ma Beijing 
[root@server0 ~]# sed -r 's/([A-Z])/{\1}/g' /z.txt  #将文本所有大写字母添加上大括号
{H}ello the world
   {N}i ha{O} {M}a {B}eijing 

========================================================================

2）sed命令的 -i 选项
正常情况下，sed命令所做的处理只是把操作结果（包括打印、删除等）输出到当前终端屏幕，而并不会对原始文件做任何更改：

删除文件中每行的第二个、最后一个字符
分两次替换操作，第一次替换掉第2个字符，第二次替换掉最后一个字符：
[root@svr5 ~]# sed 's/.//2 ; s/.$//' nssw.txt 

将文件中每行的第一个、倒数第1个字符互换
每行文本拆分为“第1个字符”、“中间的所有字符”、“倒数第1个字符”三个部分，然后通过替换操作重排顺序为“3-2-1”：
[root@svr5 ~]# sed -r 's/^(.)(.*)(.)$/\3\2\1/' nssw.txt

删除文件中所有的数字
因原文件内没有数字，行首也没有空格，这里稍作做一点处理，生成一个新测试文件：
[root@svr5 ~]# sed 's/[0-9]//' nssw.txt

为文件中每个大写字母添加括号
使用“（）”可实现保留功能，所以可参考下列操作解决：
[root@svr5 ~]# sed -r 's/([A-Z])/[\1]/g' nssw.txt

=========================================================================
虚拟机server:
vim  /ftp.sh
#!/bin/bash
yum -y reinstall vsftpd
cp /etc/vsftpd/vsftpd.conf  /etc/vsftpd/vsftpd.conf.old
sed -i 's/^#anon/anon/'  /etc/vsftpd/vsftpd.conf 
systemctl restart vsftpd
systemctl enable vsftpd
chmod 77 /var/ftp/pub
setenforce 0 
systemctl stop firewalld

bash /ftp.sh

真机
ftp:172.25.0.11

==========================================================================
空格与换行

[root@server0 ~]# echo -e "Hello\tword" #空格
Hello	word
[root@server0 ~]# echo -e "Hello\nword" #换行
Hello
word

字符串与文件的内容倒的显示
[root@server0 ~]# echo 123456789 | rev #将字符串倒着显示
987654321
[root@server0 ~]# tac /etc/passwd       #使文件行排列倒过来
[root@server0 ~]# tac /etc/passwd | rev #使文件行排列倒过来,同时每行内容倒过来显示

行号与行数
[root@server0 ~]# sed '=' /etc/passwd     #显示行号
[root@server0 ~]# sed -n '$=' /etc/passwd #输出文件行数
[root@server0 ~]# sed  '$=' /etc/passwd   #输入文本内容及行数

输出文本内容
[root@server0 ~]# sed '' /etc/passwd 
[root@server0 ~]# cat /etc/passwd
[root@server0 ~]# sed  '/.$/p' /etc/passwd

=======================================================================
sed多行文本处理

 sed [选项] '条件指令' 文件..
 sed工具的多行文本处理操作：
   i： 在指定的行之前插入文本
   a：在指定的行之后追加文本
   c：替换指定的行

[root@server0 ~]# cat /1.txt
tre
rewr
rewr
abc
aabbcc
yy
xx

ｉ行前插入文本
例：
[root@server0 ~]# sed '2izhai' /1.txt　＃在第二行前面插入行
tre
zhai
rewr
rewr
abc
aabbcc
yy
xx

a 行后插入文本
例:
[root@server0 ~]# sed '2aZHAIYANQUAN' /1.txt  在第2行之后添加一行ZHAIYANQUAN
tre
rewr
ZHAIYANQUAN
rewr
abc
aabbcc
yy
xx

c 替换当前行
[root@server0 ~]# sed '4czhaiyanquan' /1.txt #将第2行的内容修改为zhaiyanquan
tre
rewr
rewr
zhaiyanquan
aabbcc
yy
xx

shell_day05====================================================================================

文件导入导出

基本动作
  r 读取文件 
  w 保存到文件

r 读取文件 
例:
[root@server0 ~]# sed '2r /b.txt' /a.txt    #在a.txt文件第2行行后插入b.txt文件所有内容
或
[root@server0 ~]# sed '2,3r /b.txt' /a.txt  #在第2-3每行一行后插入文本b.txt

w 保存到文件
例:
[root@server0 ~]# sed '1w /b.txt' /a.txt #将a.txt第1行;另存为文件b.txt,b.txt文件是另存的内容
或
[root@server0 ~]# sed '1,3w /b.txt' /a.txt #将a.txt第1-3行;另存为文件b.txt,b.txt文件是另存的内容

==================================================================
sed流控制

! 取反操作
用途: 根据定址条件取反
例:
[root@server0 ~]# sed '/bash$/!p' /etc/passwd

提取 /etc/passwd 的用户名
[root@server0 ~]# sed -n '/bash$/p' /etc/passwd

匹配 shell 的用户名
[root@server0 ~]# sed  's/:.*//' /etc/passwd

获取用户名
[root@server0 ~]# sed -n '/bash$/s/:.*//p' /etc/passwd

[root@server0 ~]# sed -n 's/root://p' /etc/passwd

=================================================================
awk基本用法

格式：awk [选项] '[条件]{指令}' 文件
其中，print 是最常用的编辑指令；若有多条编辑指令，可用分号分隔。
Awk过滤数据时支持仅打印某一列，如第2列、第5列等。
处理文本时，若未指定分隔符，则默认将空格、制表符等作为分隔符。

awk常用内置变量：
$0 文本当前行的全部内容
$1	文本的第1列
$2	文件的第2列
$3	文件的第3列，依此类推
NR	文件当前行的行号
NF	文件当前行的列数（有几列）

1）基本操作方法
格式：awk [选项] '[条件]{指令}' 文件
例:
[root@server0 ~]# cat /a.txt
a h y 0 y
r 0 8 7 y 
p 0 u e e
[root@server0 ~]# awk '{print $3}' /a.txt    #显示文本第3列
[root@server0 ~]# awk '{print $3,$5}' /a.txt #显示文本第3列和第4列

2）选项 -F 可指定分隔符
例:
[root@server0 ~]# awk -F: '{print $1}' /etc/passwd  #打印文件第一列

NR	文件当前行的行号
NF	文件当前行的列数（有几列）
例:
[root@server0 ~]# awk '{print NR,NF}' /a.txt
1 1
2 1
3 4

2）awk的print指令不仅可以打印变量，还可以打印常量
例:
[root@server0 ~]# awk -F: '{print $1,"的解析器",$7}' /etc/passwd 

利用awk提取本机的网络流量、根分区剩余容量、获取远程失败的IP地址
1）提取IP地址
[root@server0 ~]# ifconfig eth0 | awk 'NR=="2"{print $2}'
172.25.0.11格式化输出

[root@svr5 ~]# df -h | awk '{print $4}'        //打印磁盘的剩余空间

选项 -F 可指定分隔符
输出passwd文件中以分号分隔的第1、7个字段，显示的不同字段之间以逗号隔开，操作如下：
[root@zhai ~]# awk -F: '{print $1,$7}' /etc/passwd

awk还识别多种单个的字符，比如以“:”或“/”分隔，输出第1、10个字段：
[root@zhai ~]# awk -F[:/] '{print $1,$10}' /etc/passwd

删除文件中所有的数字
[root@web1 ~]# sed 's/[0-9]//g' /etc/passwd

为文件中每个小写字母添加括号
[root@web1 ~]# sed -r 's/([a-z])/[\1]/g' /etc/passwd



===================================================================
awk过滤的时机

例:[root@server0 ~]# awk 'BEGIN{A=20;print A*10}'
200

[root@server0 ~]# awk 'BEGIN {FS= ":"}{print $1}' /etc/passwd
或
[root@server0 ~]# awk -F: '{print $1}' /etc/passwd

local_transport = error:local delivery disabled

===================================================================
格式化输出

awk处理的时机
awk会逐行处理文本，支持在处理第一行之前做一些准备工作，以及在处理完最后一行之后做一些总结性质的工作。在命令格式上分别体现如下：
awk  [选项]  '[条件]{指令}'  文件
awk  [选项]  ' BEGIN{指令} {指令} END{指令}'  文件

[root@server0 ~]# awk 'BEGIN{A=20;print A*10}'
200

[root@server0 ~]# awk -F: 'BEGIN{User Uid Home}{print $1,$3,$6}' /etc/passwd | column -t #column -t是对齐

~ 匹配
例: 
[root@server0 ~]# awk -F: '$4~/0/{print $4}' /etc/passwd

!~ 不匹配
例:
[root@server0 ~]# awk -F: '$4~/0/{print $4}' /etc/passwd

数值比较
== 等于
例:
[root@server0 ~]# awk -F: 'NR==1{print}' /etc/passwd

!= 不等于

>= 大于或等于
例:
[root@server0 ~]# awk -F: '$3>=1000{print $1,$3}' /etc/passwd

<（小于）
例:
[root@server0 ~]# awk -F: '$3<10{print $1,$3}' /etc/passwd

大于并且小
例:  
[root@server0 ~]# awk -F: '$3>10 && $3<20' /etc/passwd   #输出账户UID大于10并且小于20的账户信息

大于或小于
例:
[root@server0 ~]# awk -F: '$3>1000 || $3<3' /etc/passwd

|| 逻辑或
例:`
[root@server0 ~]# seq 100 | awk '$1%7==0 || $1~/7/{print $1}'


只做预处理的时候，可以没有操作文件
例：
[root@svr7 ~]# awk 'BEGIN{a=10;print a*2}'
20

统计系统中使用bash作为登录Shell的用户总个数
[root@svr5 ~]# awk 'BEGIN{x=0}/bash$/{x++} END{print x}' /etc/passwd

=========================================================================
awk数组

1）数组的语法格式
数组是一个可以存储多个值的变量，具体使用的格式如下：
定义数组的格式：数组名[下标]=元素值
调用数组的格式：数组名[下标]
遍历数组的用法：for(变量 in 数组名){print 数组名[变量]}。
例:
[root@server0 ~]# awk 'BEGIN{sqa[0]="sdf"; sqa[1]="765";sqa[2]="146854";print sqa[0];print sqa[1]; print sqa[2]}'

sort -n 或 sort -rn #大小排序
例:
[root@server0 ~]# awk -F: '{print $3}' /etc/passwd | sort -n  #从小到大
[root@server0 ~]# awk -F: '{print $3}' /etc/passwd | sort -rn #从大到小

查看cpu使用最多的进程
[root@server0 ~]# ps -eo %cpu,%mem,ucmd | awk '{A[$3]+=$2}END{for(i in A)print A[i],i}' | sort -rn | awk 'NR==1{print $1}'
12.3
查看内存使用最多的进程
[root@server0 ~]# ps -eo %mem,%cpu,ucmd | awk '{A[$3]+=$2}END{for(i in A)print A[i],i}' | sort -rn | awk 'NR==1{print $1}'
2.5

查看 nginx 进程启动的精确时间和启动后所流逝的时间：
[root@room0pc99 桌面]# ps -eo pid,lstart,etime,cmd | grep nginx

[root@server0 ~]# uptime    #cpu负载
[root@server0 ~]# ifconfig  #网卡流量
[root@server0 ~]# free #内

shell_day06====================================================================================


6.operation=============================================================================================================

operation_day01===============================================================================================


[root@room12pc2 桌面]# scp -p lnmp_soft.tar.gz root@192.168.4.5:/

[root@proxy ~]# md5sum /lnmp_soft.tar.gz
--user：指定账户
b959d307666ae8ddeb578ce8e95a5341  /lnmp_soft.tar.gz

构建Nginx服务器
[root@proxy ~]# tar -xf lnmp_soft.tar.gz /  
[root@proxy ~]# tar -xf nginx-1.10.3.tar.gz -C /
[root@proxy ~]# cd /nginx-1.10.3
[root@proxy nginx-1.10.3]# yum -y install gcc
[root@proxy nginx-1.10.3]# ./configure
[root@proxy nginx-1.10.3]# yum -y install pcre-devel
[root@proxy nginx-1.10.3]# ./configure
[root@proxy nginx-1.10.3]# yum -y install zlib-devel
[root@proxy nginx-1.10.3]# useradd -s /sbin/nologin nginx
[root@proxy nginx-1.10.3]# ./configure --user=nginx --group=nginx --with-http_ssl_module
[root@proxy nginx-1.10.3]# make && make install
[root@proxy ~]# /usr/local/nginx/sbin/nginx   #启动服务
或
步骤一：构建Nginx服务器
[root@web1 nginx-1.12.2]# ./configure --help  #查看所有模块

1）使用源码包安装nginx软件包
[root@proxy ~]# yum -y install gcc pcre-devel openssl-devel  #安装依赖包
[root@proxy ~]# useradd -s /sbin/nologin nginx
[root@proxy ~]# tar  -xf   nginx-1.10.3.tar.gz
[root@proxy ~]# cd  nginx-1.10.3
[root@proxy nginx-1.10.3]# ./configure   \
> --prefix=/usr/local/nginx   \                  #指定安装路径
> --user=nginx   \                               #指定用户
> --group=nginx  \                               #指定组
> --with-http_ssl_module                         #开启SSL加密功能
[root@proxy nginx-1.10.3]# make && make install  #编译并安装

2）nginx命令的用法
[root@proxy ~]# /usr/local/nginx/sbin/nginx               #启动服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s stop       #关闭服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload     #重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx -V            #查看软件信息
[root@proxy ~]# ln -s /usr/local/nginx/sbin/nginx /sbin/  #方便后期使用

netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：
  -a显示所有端口的信息
  -n以数字格式显示端口号
  -t显示TCP连接的端口
  -u显示UDP连接的端口
  -l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
  -p显示监听端口的服务名称是什么（也就是程序名称）
nginx服务默认通过TCP 80端口监听客户端请求：
root@proxy ~]# netstat  -anptu  |  grep nginx
tcp        0        0 0.0.0.0:80        0.0.0.0:*        LISTEN        10441/nginx

=======================================================================
升级Nginx服务器

1）编译新版本nginx软件
[root@proxy ~]# tar  -zxvf   nginx-1.12.2.tar.gz
[root@proxy ~]# cd nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   \
> --prefix=/usr/local/nginx   \ 
> --user=nginx   \ 
> --group=nginx  \ 
> --with-http_ssl_module
[root@proxy nginx-1.12.2]# make     
       
2) 备份老的nginx主程序，并使用编译好的新版本nginx替换老版本
[root@proxy nginx-1.12.2]# mv /usr/local/nginx/sbin/nginx  \
>/usr/local/nginx/sbin/nginxold
[root@proxy nginx-1.12.2]# cp objs/nginx  /usr/local/nginx/sbin/  #拷贝新版本
[root@proxy nginx-1.12.2]# make upgrade                           #升级
#或者使用killall nginx杀死进程后再启动nginx。
/usr/local/nginx/sbin/nginx -t
nginx: the configuration file /usr/local/nginx/conf/nginx.conf syntax is ok
nginx: configuration file /usr/local/nginx/conf/nginx.conf test is successful
kill -USR2 `cat /usr/local/nginx/logs/nginx.pid`
sleep 1
test -f /usr/local/nginx/logs/nginx.pid.oldbin
kill -QUIT `cat /usr/local/nginx/logs/nginx.pid.oldbin`
[root@proxy ~]# /usr/local/nginx/sbin/nginx –v  #查看版本

================================================================
基于域名的虚拟主机

修改配置文件
1）修改Nginx服务配置，添加相关虚拟主机配置如下
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server 
        listen       80;                               #端口
        server_name  www.a.com;                        #域名
auth_basic "Input Password:";                          #认证提示符
        auth_basic_user_file "/usr/local/nginx/pass";  #认证密码文件
location / {
            root   html;                               #指定网站根路径
            index  index.html index.htm;
       }
}

server {
        listen  80;              #端口
        server_name  www.b.com;  #域名
   location / { 
   root   www;                   #指定网站根路径
   index  index.html index.htm;
   }
}

2）创建网站根目录及对应首页文件
[root@proxy ~]# mkdir /usr/local/nginx/www
[root@proxy ~]# echo "www" > /usr/local/nginx/www/index.html

3）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

客户端测试
1）修改客户端主机192.168.4.10的/etc/hosts文件，进行域名解析
[root@client ~]# vim /etc/hosts
192.168.4.5    www.a.com  www.b.com

2）登录192.168.4.10客户端主机进行测试
注意：请先关闭真实机的firefox，再SSH -X远程连接调用虚拟机的firefox。
[root@client ~]# firefox http://www.a.com   #输入密码后可以访问
[root@client ~]# firefox http://www.b.com   #直接访问

========================================================================
基于端口的虚拟主机(不同端口,同域名)

server {
        listen       8080;              #端口
        server_name  web1.example.com;  #域名

}
server {
        listen       8000;             #端口
        server_name  web1.example.com; #域名
 }

========================================================================
基于IP的虚拟主机

server {
        listen       192.168.0.1:80;   #IP地址与端口
        server_name  web1.example.com; #域名
}
server {
        listen       192.168.0.2:80;   #IP地址与端口
        server_name  web1.example.com;
}

=========================================================================
SSL虚拟主机

源码安装Nginx时必须使用--with-http_ssl_module参数，启用加密模块，对于需要进行SSL加密处理的站点添加ssl相关指令（设置网站需要的私钥和证书）。
加密算法一般分为对称算法、非对称算法、信息摘要。
对称算法有：AES、DES，主要应用在单机数据加密。
非对称算法有：RSA、DSA，主要应用在网络数据加密。
信息摘要：MD5、sha256，主要应用在数据完整性校验。

配置SSL虚拟主
1）生成私钥与证书
[root@proxy ~]# cd /usr/local/nginx/conf
[root@proxy ~]# openssl genrsa > cert.key                        #生成私钥,名称自定义
[root@proxy ~]# openssl req -new -x509 -key cert.key > cert.pem  #生成证书,名称自定义

2）修改Nginx配置文件，设置加密网站的虚拟主机
[root@proxy ~]# vim  /usr/local/nginx/conf/nginx.conf
server {
        listen       443 ssl;
        server_name            www.c.com;
        ssl_certificate      cert.pem;         #这里是证书文件,公钥cert.pem的名称
        ssl_certificate_key  cert.key;         #这里是私钥文件,私钥cert.key的名称
        ssl_session_cache    shared:SSL:1m;
        ssl_session_timeout  5m;
        ssl_ciphers  HIGH:!aNULL:!MD5;
        ssl_prefer_server_ciphers  on;
        location / {
            root   html;
            index  index.html index.htm;
        }
}

3）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

operation_day02===============================================================================================

部署LNMP环境

安装部署Nginx、MariaDB、PHP环境
安装部署Nginx、MariaDB、PHP、PHP-FPM；
启动Nginx、MariaDB、FPM服务；
并测试LNMP是否工作正常。

LNMP（Linux、Nginx、MySQL、PHP）
在RHEL7系统中，源码安装Nginx，使用RPM包安装MariaDB、PHP、PHP-FPM软件。
操作过程中需要安装的软件列表如下：
nginx
mariadb、mariadb-server、mariadb-devel
php、php-fpm、php-mysql
备注：mariadb（数据库客户端软件）、mariadb-server（数据库服务器软件）、mariadb-devel（其他客户端软件的依赖包）、php（解释器）、php-fpm（进程管理器服务）、php-mysql（PHP的数据库扩展包）。
1.3 步骤

安装软件
1）使用yum安装基础依赖包
[root@proxy ~]# yum -y install gcc openssl-devel pcre-devel

2）源码安装Nginx（如果前面课程中已经安装Nginx，则忽略这一步）
[root@proxy ~]# useradd -s /sbin/nologin nginx
[root@proxy ~]# tar -xvf nginx-1.12.2.tar.gz  #解压包在当前目录下
[root@proxy ~]# cd nginx-1.12.2   #进入nginx-1.12.2目录
[root@proxy nginx-1.12.2]# ./configure --user=nginx --group=nginx --with-http_ssl_module   
[root@proxy nginx-1.12.2]# make && make install  #编译并安装

3）安装MariaDB
Mariadb在新版RHEL7光盘中包含有该软件，配置yum源后可以直接使用yum安装：
[root@proxy ~]# yum -y install mariadb mariadb-server mariadb-devel

4）php和php-fpm
[root@proxy ~]# yum -y  install  php   php-mysql
[root@proxy ~]# yum -y  install php-fpm

启动服务
1）启动Nginx服务（如果已经启动nginx，则可以忽略这一步）
这里需要注意的是，如果服务器上已经启动了其他监听80端口的服务软件（如httpd），则需要先关闭该服务，否则会出现冲突。 
[root@proxy ~]# systemctl stop httpd          #如果该服务存在则关闭该服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx   #启动Nginx服务
[root@proxy ~]# netstat -utnlp | grep :80
tcp    0    0 0.0.0.0:80        0.0.0.0:*        LISTEN        32428/nginx         

2）启动MySQL服务
[root@proxy ~]# systemctl start  mariadb  #启动服务器
[root@proxy ~]# systemctl status mariadb  #查看服务状态
[root@proxy ~]# systemctl enable mariadb  #设置开机启动

3）启动PHP-FPM服务
[root@proxy ~]# systemctl start php-fpm   #启动服务
[root@proxy ~]# systemctl status php-fpm  #查看服务状态
[root@proxy ~]# systemctl enable php-fpm  #设置开机启动

===================================================================================
构建LNMP平台

步骤一： php-fpm配置文件

1）查看php-fpm配置文件（实验中不需要修改该文件）
[root@zhai02 nginx-1.12.2]# grep  -v ";" /etc/php-fpm.d/www.conf | grep -v '^$'

步骤二：修改Nginx配置文件并启动服务
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
location / {
            root   html;
            index  index.php  index.html   index.htm; #把index.php作为首页
#设置默认首页为index.php，当用户在浏览器地址栏中只写域名或IP，不说访问什么页面时，服务器会把默认首页index.php返回给用户
  }
 location  ~  \.php$  {
            root           html;
            fastcgi_pass   127.0.0.1:9000;    #将请求转发给本机9000端口，PHP解释器
            fastcgi_index  index.php;
            #fastcgi_param   SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            include        fastcgi.conf;      #加载其他配置文件
        }
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload

步骤三：创建PHP页面，测试LNMP架构能否解析PHP页面

1）创建PHP测试页面1，可以参考lnmp_soft/php_scripts/test.php：
[root@proxy ~]# vim /usr/local/nginx/html/test.php
<?php
$i="This is a test Page";
echo $i;
?>

2）创建PHP测试页面,连接并查询MariaDB数据库。
可以参考lnmp_soft/php_scripts/mysql.php:
[root@proxy ~]# vim /usr/local/nginx/html/mysql.php
<?php
$mysqli = new mysqli('localhost','root','密码','mysql');
#注意：root为mysql数据库的账户名称，密码需要修改为实际mysql密码，无密码则留空即可
#localhost是数据库的域名或IP，mysql是数据库的名称
if (mysqli_connect_errno()){
    die('Unable to connect!'). mysqli_connect_error();
}
$sql = "select * from user";
$result = $mysqli->query($sql);
while($row = $result->fetch_array()){
    printf("Host:%s",$row[0]);
    printf("</br>");
    printf("Name:%s",$row[1]);
    printf("</br>");
}
?>

3）客户端使用浏览器访问服务器PHP首页文档，检验是否成功：
[root@client ~]# firefox http://192.168.4.5/test.php
[root@client ~]# firefox http://192.168.4.5/mysql.php

4）LNMP常见问题
Nginx的默认访问日志文件为/usr/local/nginx/logs/access.log
Nginx的默认错误日志文件为/usr/local/nginx/logs/error.log
PHP默认错误日志文件为/var/log/php-fpm/www-error.log
如果动态网站访问失败，可用参考错误日志，查找错误信息。

======================================================================================
地址重写

关于Nginx服务器的地址重写，主要用到的配置参数是rewrite：
   rewrite regex replacement flag
   rewrite 旧地址 新地址 [选项]

步骤一：修改配置文件(访问a.html重定向到b.html)

1）修改Nginx服务配置：
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf

server {
        listen       80;
        server_name  localhost;
rewrite /a.html  /b.html;            
location / {
    root   html;
index  index.html index.htm;
   }
}
[root@proxy ~]# echo "BB" > /usr/local/nginx/html/b.html

2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload

3）客户端测试
[root@client ~]# firefox  http://192.168.4.5/a.html

步骤二：访问a.html重定向到b.html（跳转地址栏）
1）修改Nginx服务配置：
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
server {
        listen       80;
        server_name  localhost;
rewrite /a.html  /b.html  redirect;            
location / {
    root   html;
index  index.html index.htm;
    }
}

2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

3）客户端测试（仔细观察浏览器地址栏的变化）
[root@client ~]# firefox  http://192.168.4.5/a.html

步骤三：修改配置文件(访问192.168.4.5/下面子页面，重定向至www.tmooc.cn/下相同的页面)
1) 修改Nginx服务配置
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf

server {
        listen       80;
        server_name  localhost;
rewrite ^/(.*)$  http://www.tmooc.cn/$1;
location / {
    root   html;
index  index.html index.htm;
  }
}

2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

3）客户端测试（真实机测试，真实机才可以连接tmooc）
[root@room9pc01 ~]# firefox  http://192.168.4.5

步骤四：修改配置文件(访问192.168.4.5/下面子页面，重定向至www.tmooc.cn/下相同的页面)

1) 修改Nginx服务配置
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf

server {
        listen       80;
        server_name  localhost;
rewrite ^/(.*)$  http://www.tmooc.cn/$1;
location / {
    root   html;
index  index.html index.htm;
    }
}

2）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

3）客户端测试（真实机测试，真实机才可以连接tmooc）
[root@room9pc01 ~]# firefox  http://192.168.4.5
[root@room9pc01 ~]# firefox  http://192.168.4.5/test

步骤五：修改配置文件(实现curl和火狐访问相同链接返回的页面不同)
1) 创建网页目录以及对应的页面文件：
[root@proxy ~]# echo "I am Normal page" > /usr/local/nginx/html/test.html
[root@proxy ~]# mkdir  -p  /usr/local/nginx/html/firefox/
[root@proxy ~]# echo "firefox page" > /usr/local/nginx/html/firefox/test.html

2) 修改Nginx服务配置
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf

server {
        listen       80;
        server_name  localhost;
location / {
    root   html;
index  index.html index.htm;
}
#这里，~符号代表正则匹配，*符号代表不区分大小写
if ($http_user_agent ~* firefox) {     #识别客户端firefox浏览器
rewrite ^(.*)$  /firefox/$1;
   }
}

3）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx  -s  reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

4）客户端测试
[root@client ~]# firefox  http://192.168.4.5/test.html
[root@client ~]# curl     http://192.168.4.5/test.html

5）地址重写格式【总结】
rewrite 旧地址 新地址 [选项];
last 不再读其他rewrite
break 不再读其他语句，结束请求
redirect 临时重定向
permament 永久重定向


operation_day03===============================================================================================

Nginx反向代理

部署实施后端Web服务器

1）部署后端Web1服务器
后端Web服务器可以简单使用yum方式安装httpd实现Web服务，为了可以看出后端服务器的不同，
可以将两台后端服务器的首页文档内容设置为不同的内容。

[root@web1 ~]# yum  -y  install  httpd
[root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html
[root@web1 ~]# systemctl restart httpd
[root@web1 ~]# firewall-cmd --set-default-zone=trusted
[root@web1 ~]# setenforce 0

2）部署后端Web2服务器
[root@web2 ~]# yum  -y  install  httpd
[root@web2 ~]# echo "192.168.2.200" > /var/www/html/index.html
[root@web2 ~]# systemctl restart httpd
[root@web2 ~]# firewall-cmd --set-default-zone=trusted
[root@web2 ~]# setenforce 0

配置Nginx服务器，添加服务器池，实现反向代理功能

1）修改/usr/local/nginx/conf/nginx.conf配置文件
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf

http {

#使用upstream定义后端服务器集群，集群名称任意(如webserver)
#使用server定义集群中的具体服务器和端口
upstream webserver {
      server 192.168.2.100:80;
      server 192.168.2.200:80;
}

server {
        listen        80;
        server_name  localhost;
        location / {
#通过proxy_pass将用户的请求转发给webserver集群
            proxy_pass http://webserver;
          }
}

2）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

3）客户端使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5   #使用该命令多次访问查看效果
[root@client ~]# curl http://192.168.4.5   #使用该命令多次访问查看效果

配置upstream服务器集群池属性

1）设置失败次数，超时时间，权重
weight可以设置后台服务器的权重，max_fails可以设置后台服务器的失败次数，fail_timeout可以设置后台服务器的失败超时时间。
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf

http {

upstream webserver {
       server 192.168.2.100 weight=1 max_fails=1 fail_timeout=30;
       server 192.168.2.200 weight=2 max_fails=2 fail_timeout=30;
       server 192.168.2.101 down;
 }
#weight设置服务器权重值，默认值为1
#max_fails设置最大失败次数
#fail_timeout设置失败超时时间，单位为秒
#down标记服务器已关机，不参与集群调度

server {
        listen        80;
        server_name  localhost;
            location / {
            proxy_pass http://webserver;
        }
}

2）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

3）关闭一台后端服务器（如web1）
[root@web1 ~]# systemctl stop httpd

4）客户端使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5  #使用该命令多次访问查看效果

5）再次启动后端服务器的httpd（如web1）
[root@web1 ~]# systemctl start httpd

6）客户端再次使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5  #使用该命令多次访问查看效果

步骤三：配置upstream服务器集群的调度算法

1）设置相同客户端访问相同Web服务器
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf

http {

upstream webserver {
#通过ip_hash设置调度规则为：相同客户端访问相同服务器
                ip_hash;
                server 192.168.2.100 weight=1 max_fails=2 fail_timeout=10;
                server 192.168.2.200 weight=2 max_fails=2 fail_timeout=10;
        }

server {
        listen        80;
        server_name  www.tarena.com;
            location / {
            proxy_pass http://webserver;
        }
}

2）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

3）客户端使用浏览器访问代理服务器测试轮询效果
[root@client ~]# curl http://192.168.4.5            //使用该命令多次访问查看效果

===================================================================
Nginx的TCP/UDP调度器

使用Nginx实现TCP/UDP调度器功能，实现如下功能：
    后端SSH服务器两台
   Nginx编译安装时需要使用--with-stream，开启ngx_stream_core_module模块
   Nginx采用轮询的方式调用后端SSH服务器

部署支持4层TCP/UDP代理的Nginx服务器

1）部署nginx服务器
编译安装必须要使用--with-stream参数开启4层代理模块。

[root@proxy ~]# tar -xf nginx-1.12.2.tar.gz -C /
[root@proxy ~]# cd /nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure --user=nginx --group=nginx --with-http_ssl_module --with-stream
[root@proxy nginx-1.12.2]# make && make install  #编译并安装

步骤一：配置Nginx服务器，添加服务器池，实现TCP/UDP反向代理功能
1）修改/usr/local/nginx/conf/nginx.conf配置文件
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
stream {
     upstream backend {
           server 192.168.2.100:22;     #后端SSH服务器的IP和端口
           server 192.168.2.200:22;
       }
     server {
            listen 12345;               #Nginx监听的端口
            proxy_connect_timeout 1s;   #连接的超时时间，可选配置
            proxy_timeout 3s;
            proxy_pass backend;
        }
}

http {

}

2）重启nginx服务
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

3）客户端使用访问代理服务器测试轮询效果
[root@client ~]# ssh 192.168.4.5 -p 12345  #使用该命令多次访问查看效果

==========================================================================
Nginx常见问题处理

本案例要求对Nginx服务器进行适当优化，解决如下问题，以提升服务器的处理性能：
   如何自定义返回给客户端的404错误页面
   如何查看服务器状态信息
   如果客户端访问服务器提示“Too many open files”如何解决
   如何解决客户端访问头部信息过长的问题
   如何让客户端浏览器缓存数据
   日志切割
   开启gzip压缩功能，提高数据传输效率
   开启文件缓存功能
然后客户机访问此Web服务器验证效果：
   使用ab压力测试软件测试并发量
   编写测试脚本生成长头部信息的访问请求
   客户端访问不存在的页面，测试404错误页面是否重定向

自定义报错页面

1）优化前，客户端使用浏览器访问不存在的页面，会提示404文件未找到
[root@client ~]# firefox http://192.168.4.5/xxxxx   #访问一个不存在的页面

2）修改Nginx配置文件，自定义报错页面
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf

   charset utf-8;                #仅需要中文时需要改选项，可选项
   error_page   404  /404.html;  #自定义错误页面

[root@proxy ~]# vim /usr/local/nginx/html/404.html     #生成错误页面
Oops,No NO no page …

[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload  #重启nginx服务
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

3）优化后，客户端使用浏览器访问不存在的页面，会提示自己定义的40x.html页面
[root@client ~]# firefox http://192.168.4.5/xxxxx  #访问一个不存在的页面

===========================================================================
如何查看服务器状态信息（非常重要的功能）

1）编译安装时使用--with-http_stub_status_module开启状态页面模块
[root@proxy ~]# tar  -zxvf   nginx-1.12.2.tar.gz
[root@proxy ~]# cd  nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure   \
> --with-http_ssl_module                         #开启SSL加密功能
> --with-stream                                  #开启TCP/UDP代理模块
> --with-http_stub_status_module                 #开启status状态页面
[root@proxy nginx-1.12.2]# make && make install  #编译并安装

2）启用Nginx服务并查看监听端口状态
ss命令可以查看系统中启动的端口信息，该命令常用选项如下：
-a显示所有端口的信息
-n以数字格式显示端口号
-t显示TCP连接的端口
-u显示UDP连接的端口
-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
-p显示监听端口的服务名称是什么（也就是程序名称）
注意：在RHEL7系统中可以使用ss命令替代netstat命令，功能一样，选项一样。

[root@proxy ~]# /usr/local/nginx/sbin/nginx
[root@proxy ~]# netstat  -anptu  |  grep nginx
tcp        0        0 0.0.0.0:80        0.0.0.0:*        LISTEN        10441/nginx
[root@proxy ~]# ss  -anptu  |  grep nginx

3）修改Nginx配置文件，定义状态页面
[root@proxy ~]# cat /usr/local/nginx/conf/nginx.conf

location /status {
            stub_status on;
            #allow IP地址;
            #deny IP地址;
}

[root@proxy ~]# nginx

4）优化后，查看状态页面信息
[root@proxy ~]# curl  http://192.168.4.5/status

Active connections：当前活动的连接数量。
Accepts：已经接受客户端的连接总数量。
Handled：已经处理客户端的连接总数量。
（一般与accepts一致，除非服务器限制了连接数量）。
Requests：客户端发送的请求数量。
Reading：当前服务器正在读取客户端请求头的数量。
Writing：当前服务器正在写响应信息的数量。
Waiting：当前多少客户端在等待服务器的响应。

==========================================================================
优化Nginx并发量

1）优化前使用ab高并发测试
[root@proxy ~]# ab -n 2000 -c 2000 http://192.168.4.5/
Benchmarking 192.168.4.5 (be patient)
socket: Too many open files (24)       #提示打开文件数量过多

2）修改Nginx配置文件，增加并发量
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf

worker_processes  2;          #与CPU核心数量一致
events {
   worker_connections 65535;  #每个worker最大并发连接数
}

[root@proxy ~]# nginx -s reload

3）优化Linux内核参数（最大文件数量）
[root@proxy ~]# ulimit -a            #查看所有属性值
[root@proxy ~]# ulimit -Hn 100000    #设置硬限制（临时规则）
[root@proxy ~]# ulimit -Sn 100000    #设置软限制（临时规则）
[root@proxy ~]# vim /etc/security/limits.conf
    .. ..
*           soft    nofile         100000
*           hard    nofile         100000
#该配置文件分4列，分别如下：
#用户或组    硬限制或软限制    需要限制的项目   限制的值

4）优化后测试服务器并发量（因为客户端没调内核参数，所以在proxy测试）
[root@proxy ~]# ab -n 2000 -c 2000 http://192.168.4.5/

============================================================================
优化Nginx数据包头缓存

1）优化前，使用脚本测试长头部请求是否能获得响应
[root@proxy ~]# cat lnmp_soft/buffer.sh 
#!/bin/bash
URL=http://192.168.4.5/index.html?
for i in {1..5000}
do
    URL=${URL}v$i=$i
done
curl $URL    #经过5000次循环后，生成一个长的URL地址栏
[root@proxy ~]# ./buffer.sh
.. ..
<center><h1>414 Request-URI Too Large</h1></center>   #提示头部信息过大

2）修改Nginx配置文件，增加数据包头部缓存大小
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
http {
client_header_buffer_size    1k;    #默认请求包头信息的缓存    
large_client_header_buffers  4 4k;  #大请求包头部信息的缓存个数与容量
.. ..
}
[root@proxy ~]# nginx -s reload

3）优化后，使用脚本测试长头部请求是否能获得响应
[root@proxy ~]#cat cat buffer.sh 
#!/bin/bash
URL=http://192.168.4.5/index.html?
for i in {1..5000}
do
    URL=${URL}v$i=$i
done
curl $URL
[root@proxy ~]# ./buffer.sh

=============================================================================
浏览器本地缓存静态数据

1）使用Firefox浏览器查看缓存
以Firefox浏览器为例，在Firefox地址栏内输入about:cache将显示Firefox浏览器的缓存信息，如图-3所示，
点击List Cache Entries可以查看详细信息。

2）清空firefox本地缓存数据

3）修改Nginx配置文件，定义对静态页面的缓存时间
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
server {
        listen       80;
        server_name  localhost;
        location / {
            root   html;
            index  index.html index.htm;
        }
location ~* \.(jpg|jpeg|gif|png|css|js|ico|xml)$ {
expires        30d;            //定义客户端缓存时间为30天
}
}
[root@proxy ~]# cp /usr/share/backgrounds/day.jpg /usr/local/nginx/html
[root@proxy ~]# nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
#[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

4）优化后，使用Firefox浏览器访问图片，再次查看缓存信息
[root@client ~]# firefox http://192.168.4.5/day.jpg

=========================================================================
日志切割

日志文件越来越大怎么办？单个文件10G? 如何切割？（非常常见的面试题）
步骤：1. 把旧的日志重命名
2. kill USR1 PID(nginx的进程PID号)

1）手动执行
备注：/usr/local/nginx/logs/nginx.pid文件中存放的是nginx的进程PID号。
[root@proxy ~]#  mv access.log access2.log
[root@proxy ~]# kill -USR1 $(cat /usr/local/nginx/logs/nginx.pid)

2）自动完成
每周5的03点03分自动执行脚本完成日志切割工作。
[root@proxy ~]# vim /usr/local/nginx/logbak.sh
#!/bin/bash
date=`date +%Y%m%d`
logpath=/usr/local/nginx/logs
mv $logpath/access.log $logpath/access-$date.log
mv $logpath/error.log $logpath/error-$date.log
kill -USR1 $(cat $logpath/nginx.pid)
[root@proxy ~]# crontab -e
03 03 * * 5  /usr/local/nginx/logbak.sh

============================================================================
对页面进行压缩处理

1）修改Nginx配置文件
[root@proxy ~]# cat /usr/local/nginx/conf/nginx.conf
http {
.. ..
gzip on;                            //开启压缩
gzip_min_length 1000;                //小文件不压缩
gzip_comp_level 4;                //压缩比率
gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;
                                    //对特定文件压缩，类型参考mime.types
.. ..
}

============================================================================
服务器内存缓存

1）如果需要处理大量静态文件，可以将文件缓存在内存，下次访问会更快。
http { 
open_file_cache          max=2000  inactive=20s;
        open_file_cache_valid    60s;
        open_file_cache_min_uses 5;
        open_file_cache_errors   off;
//设置服务器最大缓存2000个文件句柄，关闭20秒内无请求的文件句柄
//文件句柄的有效时间是60秒，60秒后过期
//只有访问次数超过5次会被缓存
} 

operation_day04===============================================================================================

PHP的本地Session信息

Session：存储在服务器端，保存用户名、登陆状态等信息。
Cookies：由服务器下发给客户端，保存在客户端的一个文件里。
保存的内容主要包括：SessionID。
实验拓扑环境：
使用4台RHEL7虚拟机，其中一台作为Nginx前端调度器服务器（eth0:192.168.4.5,eth1:192.168.2.5）、两台虚拟机部署为LNMP服务器，分别为Web1服务器（192.168.2.100）和Web2服务器（192.168.2.200），另外一台作为测试用的Linux客户机（192.168.4.10），拓扑如图-2所示。

步骤一：部署后端LNMP服务器相关软件

注意:以下部署LNMP服务器的操作，需要在两台后端服务器做相同的操作，下面我们以一台Web2服务器（192.168.2.200）为例，对Web1服务器执行相同操作即可。
1）使用yum安装基础依赖包
[root@web2 ~]# yum -y install gcc openssl-devel pcre-devel

2）源码安装Nginx
[root@web2 ~]# tar -xf nginx-1.12.2.tar.gz
[root@web2 ~]# cd nginx-1.12.2
[root@web2 nginx-1.12.2]#  ./configure --with-http_ssl_module 
[root@web2 nginx-1.12.2]# make && make install

3）安装MariaDB数据库
[root@web2 ~]# yum -y install  mariadb  mariadb-server  mariadb-devel

4）安装PHP
[root@web2 ~]# yum -y install  php  php-mysql
[root@web2 ~]# yum -y install  php-fpm

5）修改Nginx配置文件（修改默认首页与动静分离）
[root@web2 ~]# vim /usr/local/nginx/conf/nginx.conf
location / {
            root   html;
            index  index.php  index.html   index.htm;
        }
 location  ~  \.php$  {
            root           html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
            #fastcgi_param   SCRIPT_FILENAME  $document_root$fastcgi_script_name;
            include        fastcgi.conf;
        }


步骤二：启动LNMP服务器相关的服务
1）启动Nginx服务
这里需要注意的是，如果服务器上已经启动了其他监听80端口的服务软件（如httpd），则需要先关闭该服务，否则会出现冲突。
[root@web2 ~]# systemctl stop  httpd          #如果该服务存在，则关闭该服务
[root@web2 ~]# /usr/local/nginx/sbin/nginx
[root@web2 ~]# netstat -utnlp | grep :80
tcp    0    0 0.0.0.0:80        0.0.0.0:*        LISTEN        32428/nginx         

2）启动MySQL服务
[root@web2 ~]# systemctl start mariadb
[root@web2 ~]# systemctl status mariadb

3）启动PHP-FPM服务
[root@web2 ~]# systemctl start  php-fpm
[root@web2 ~]# systemctl status php-fpm

步骤三：部署前端Nginx调度服务器
1）使用源码安装nginx软件（如果Nginx软件包已安装可以忽略此步骤）
[root@proxy ~]# yum  -y  install   gcc pcre-devel openssl-devel
[root@proxy ~]# tar -xf nginx-1.12.2.tar.gz
[root@proxy ~]# cd nginx-1.12.2
[root@proxy nginx-1.12.2]# ./configure
[root@proxy nginx-1.12.2]# make && make install

2）修改Nginx配置文件，实现代理服务器
Nginx配置文件中，通过upstream定义后端服务器地址池，默认调度策略为轮询，使用proxy_pass调用upstream定义的服务器地址池：
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
.. ..
upstream webs  {
        server 192.168.2.100:80;
        server 192.168.2.200:80;
  }
 server  {
          listen       80;
          server_name  localhost;
          location  /  {
              proxy_pass http://webs;
            root   html;
            index  index.php index.html index.htm;
          }
}

3）重新加载配置文件
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
#请先确保nginx是启动状态，否则运行该命令会报错,报错信息如下：
[error] open() "/usr/local/nginx/logs/nginx.pid" failed (2: No such file or directory)

步骤四：测试环境是否配置成功
1）浏览器访问测试页面验证。
[root@client ~]# curl  http://192.168.4.5/index.html  #查看是否有数据

步骤五：部署测试页面
1）部署测试页面(Web1服务器）。
测试页面可以参考lnmp_soft/php_scripts/php-memcached-demo.tar.gz。
[root@web1 ~]# cd lnmp_soft/php_scripts/
[root@web1 php_scripts]# tar -xf php-memcached-demo.tar.gz
[root@web1 php_scripts]# cd php-memcached-demo
[root@web1 php-memcached-demo]# cp -r  *  /usr/local/nginx/html/

2）浏览器直接访问后端服务器的测试页面（Web1服务器）。
[root@web1 ~]# firefox http://192.168.2.100       #填写账户信息
[root@web1 ~]# cd /var/lib/php/session/           #查看服务器本地的Session信息
[root@web1 ~]# ls
sess_ahilcq9bguot0vqsjtd84k7244                   #注意这里的ID是随机的
[root@web1 ~]# cat sess_ahilcq9bguot0vqsjtd84k7244
注意：可用修改index.php和home.php两个文件的内容，添加页面颜色属性，以区别后端两台不同的服务器:<body bgcolor=blue>。

3）部署测试页面(Web2服务器）。
测试页面可以参考lnmp_soft/php_scripts/php-memcached-demo.tar.gz。
[root@web2 ~]# cd lnmp_soft/php_scripts/
[root@web2 php_scripts]# tar -xf php-memcached-demo.tar.gz
[root@web2 php_scripts]# cd php-memcached-demo
[root@web2 php-memcached-demo]# cp -a  *  /usr/local/nginx/html/

4）浏览器直接访问后端服务器的测试页面（Web2服务器）。
[root@web2 ~]# firefox http://192.168.2.100 #填写账户信息
[root@web2 ~]# cd /var/lib/php/session/     #查看服务器本地的Session信息
[root@web2 ~]# ls
sess_qqek1tmel07br8f63d6v9ch401             #注意这里的ID是随机的
[root@web2 ~]# cat sess_qqek1tmel07br8f63d6v9ch401    

5）浏览器访问前端调度器测试（不同后端服务器Session不一致）。
推荐使用google浏览器测试。
[root@client ~]# google-chrome http://192.168.4.5
#填写注册信息后，刷新，还需要再次注册，说明两台计算机使用的是本地Session
#第二台主机并不知道你再第一台主机已经登录，第一台主机的登录信息也没有传递给第二台主机

=========================================================================================
构建memcached服务

本案例要求先快速搭建好一台memcached服务器，并对memcached进行简单的增、删、改、查操作：
   安装memcached软件，并启动服务
   使用telnet测试memcached服务
   对memcached进行增、删、改、查等操作

使用1台RHEL7虚拟机作为memcached服务器（192.168.4.5）。
在RHEL7系统光盘中包含有memcached，因此需要提前配置yum源，即可直接使用yum安装，客户端测试时需要提前安装telnet远程工具。
验证时需要客户端主机安装telnet，远程memcached来验证服务器的功能：
add name 0 180 10	#变量不存在则添加
set name 0 180 10	#添加或替换变量
replace name 0 180 10  #替换
get name	#读取变量
append name 0 180 10   #向变量中追加数据
delete name	#删除变量
flush_all	#清空所有
提示：0表示不压缩，180为数据缓存时间，10为需要存储的数据字节数量。

步骤一：构建memcached服务
1）使用yum安装软件包memcached
[root@proxy ~]# yum -y  install   memcached
[root@proxy ~]# rpm -qa memcached
memcached-1.4.15-10.el7_3.1.x86_64

2) memcached配置文件（查看即可，不需要修改）
[root@proxy ~]# vim /usr/lib/systemd/system/memcached.service
ExecStart=/usr/bin/memcached -u $USER -p $PORT -m $CACHESIZE -c $MAXCONN $OPTIONS
[root@proxy ~]# vim /etc/sysconfig/memcached
PORT="11211"
USER="memcached"
MAXCONN="1024"
CACHESIZE="64"
OPTIONS=""

3）启动服务并查看网络连接状态验证是否开启成功：
netstat命令可以查看系统中启动的端口信息，该命令常用选项如下：
-a显示所有端口的信息
-n以数字格式显示端口号
-t显示TCP连接的端口
-u显示UDP连接的端口
-l显示服务正在监听的端口信息，如httpd启动后，会一直监听80端口
-p显示监听端口的服务名称是什么（也就是程序名称）
注意：在RHEL7系统中，使用ss命令可以替代netstat，功能与选项一样。

[root@proxy ~]# systemctl  start  memcached
[root@proxy ~]# systemctl  status  memcached
[root@proxy ~]# netstat  -anptu  |  grep memcached
tcp    0    0 0.0.0.0:11211        0.0.0.0:*        LISTEN        2839/memcached      
tcp    0    0 :::11211            :::*                LISTEN        2839/memcached      
udp    0    0 0.0.0.0:11211        0.0.0.0:*                    2839/memcached      
udp    0    0 :::11211            :::*                            2839/memcached
[root@proxy ~]# setenforce 0
[root@proxy ~]# firewall-cmd --set-default-zone=trusted

步骤二：使用telnet访问memcached服务器
1）使用yum安装telnet
[root@proxy ~]# yum -y install telnet

2)使用telnet连接服务器测试memcached服务器功能，包括增、删、改、查等操作。
[root@proxy ~]# telnet  192.168.4.5  11211
Trying 192.168.4.5...
……
##提示：0表示不压缩，180为数据缓存时间，3为需要存储的数据字节数量。
set name 0 180 3  #定义变量，变量名称为name
plj               #输入变量的值，值为plj                
STORED
get name          #获取变量的值
VALUE name 0 3    #输出结果
plj
END
##提示：0表示不压缩，180为数据缓存时间，3为需要存储的数据字节数量。
add myname 0 180 10      #新建，myname不存在则添加，存在则报错
set myname 0 180 10      #添加或替换变量
replace myname 0 180 10  #替换，如果myname不存在则报错
get myname               #读取变量
append myname 0 180 10   #向变量中追加数据
delete myname            #删除变量
flush_all                #清空所有
quit                     #退出登录                                  

===================================================================================
LNMP+memcached

如果希望使用PHP来操作memcached，注意必须要为PHP安装memcache扩展（php-pecl-memcache），否则PHP无法解析连接memcached的指令。
客户端测试时需要提前安装telnet远程工具。

步骤一：创建PHP页面，使用PHP语言测试memcached服务
1）部署测试页面
创建PHP首页文档/usr/local/nginx/html/index.php，测试页面可以参考lnmp_soft/php_scripts/mem.php。
注意：192.168.2.5是memcached数据库。
 [root@web1 ~]# vim /usr/local/nginx/html/mem.php
<?php
$memcache=new Memcache;  #创建memcache对象
$memcache->connect('192.168.2.5',11211) or die ('could not connect!!');
$memcache->set('key','test');       #定义变量
$get_values=$memcache->get('key');  #获取变量值
echo $get_values;
?>

2）客户端测试（结果会失败）
客户端使用浏览器访问服务器PHP首页文档，检验对memcached的操作是否成功：
[root@web1 ~]# firefox http://192.168.2.100/test.php
注意：这里因为没有给PHP安装扩展包，默认PHP无法连接memcached数据库，需要给PHP安装扩展模块才可以连接memcached数据库。

3）为PHP添加memcache扩展
[root@web1 ~]# yum -y install  php-pecl-memcache
[root@web1 ~]# systemctl restart php-fpm

======================================================================================
PHP实现session共享

在练习三拓扑的基础上，Nginx服务器除了承担调度器外，还需要担任memcached数据库的角色，并在两台后端LNMP服务器上实现PHP的session会话共享。
拓扑结构如图-4所示。

步骤一：在后端LNMP服务器上部署Session共享
注意：这些操作在两台后端Web服务器上均需要执行，以下操作以Web1（192.168.2.100）服务器为例。
1）为PHP添加memcache扩展
注意，因为后端两台web服务器(web1,web2)都需要连接memcached数据库，所以两台主机都需要安装PHP扩展模块(下面也web1为例)。
[root@web1 ~]# yum -y install  php-pecl-memcache

2）修改PHP-FPM配置文件，并重启服务
注意，因为后端两台web服务器(web1,web2)都需要修改配置文件(下面也web1为例)。
[root@web1 ~]# vim  /etc/php-fpm.d/www.conf            //修改该配置文件的两个参数
#文件的最后2行
修改前效果如下:
php_value[session.save_handler] = files
php_value[session.save_path] = /var/lib/php/session
#原始文件，默认定义Sessoin会话信息本地计算机（默认在/var/lib/php/session）
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
修改后效果如下:
php_value[session.save_handler] = memcache
php_value[session.save_path] = "tcp://192.168.2.5:11211"
#定义Session信息存储在公共的memcached服务器上，主机参数中为memcache（没有d）
#通过path参数定义公共的memcached服务器在哪（服务器的IP和端口）
[root@web1 ~]# systemctl  restart  php-fpm


步骤三：客户端测试
客户端使用浏览器访问两台不同的Web服务器。
操作步骤参考练习一，最终可以获得相关的Session ID信息。

operation_day05===============================================================================================

安装部署Tomcat服务器

本案例要求部署Tomcat服务器，具体要求如下：
   安装部署JDK基础环境
   安装部署Tomcat服务器
创建JSP测试页面，文件名为test.jsp，显示服务器当前时间
然后客户机访问此Web服务器验证效果：
   使用火狐浏览器访问Tomcat服务器的8080端口，浏览默认首页
   使用火狐浏览器访问Tomcat服务器的8080端口，浏览默认测试页面

步骤一：部署Tomcat服务器软件(192.168.2.100/24)
1）使用RPM安装JDK环境
[root@web1 ~]# yum -y install  java-1.8.0-openjdk          #安装JDK
[root@web1 ~]# yum -y install java-1.8.0-openjdk-headless  #安装JDK
[root@web1 ~]# java -version                               #查看JAVA版本

2）安装Tomcat（apache-tomcat-8.0.30.tar.gz软件包，在lnmp_soft中有提供）
[root@web1 ~]# tar -xf  apache-tomcat-8.0.30.tar.gz
[root@web1 ~]# mv apache-tomcat-8.0.30  /usr/local/tomcat
[root@web1 ~]# ls /usr/local/tomcat
bin/       #主程序目录
lib/       #库文件目录
logs/      #日志目录  
temp/      #临时目录
work/      #自动编译目录jsp代码转换servlet
conf/      #配置文件目录
webapps/   #页面目录

3）启动服务
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh

4）服务器验证端口信息
[root@web1 ~]# netstat -nutlp |grep java  #查看java监听的端口
tcp        0      0 :::8080              :::*                LISTEN      2778/java           
tcp        0      0 ::ffff:127.0.0.1:8005     :::*         LISTEN       2778/java  
提示：如果检查端口时，8005端口启动非常慢，可用使用下面的命令用urandom替换random（非必须操作）。
[root@web1 ~]# mv /dev/random  /dev/random.bak
[root@web1 ~]# ln -s /dev/urandom  /dev/random

5）客户端浏览测试页面(proxy作为客户端)
[root@proxy ~]# firefox http://192.168.2.100:8080

步骤二：修改Tomcat配置文件
1）创建测试JSP页面
[root@web1 ~]# vim  /usr/local/tomcat/webapps/ROOT/test.jsp
<html>
<body>
<center>
Now time is: <%=new java.util.Date()%>            //显示服务器当前时间
</center>
</body>
</html>

2）重启服务
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh

步骤三：验证测试
1）服务器验证端口信息
[root@web1 ~]# netstat -nutlp |grep java  #查看java监听的端口
tcp        0      0 :::8080              :::*                LISTEN      2778/java           
tcp        0      0 ::ffff:127.0.0.1:8005     :::*         LISTEN       2778/java  
提示：如果检查端口时，8005端口启动非常慢，可用使用下面的命令用urandom替换random（非必须操作）。
[root@web1 ~]# mv /dev/random  /dev/random.bak
[root@web1 ~]# ln -s /dev/urandom  /dev/random

2）客户端浏览测试页面(proxy充当客户端角色)
[root@proxy ~]# firefox http://192.168.2.100:8080
[root@proxy ~]# firefox http://192.168.2.100:8080/test.jsp

===============================================================================
使用Tomcat部署虚拟主机

沿用练习二，使用Tomcat部署加密虚拟主机，实现以下要求：
   实现两个基于域名的虚拟主机，域名分别为：www.a.com和 www.b.com
   使用www.a.com域名访问的页面根路径为/usr/local/tomcat/a/ROOT
   使用www.b.com域名访问的页面根路径为/usr/local/tomcat/b/base
   访问www.a.com/test时，页面自动跳转到/var/www/html目录下的页面
   访问页面时支持SSL加密通讯
   私钥、证书存储路径为/usr/local/tomcat/conf/cert
   每个虚拟主机都拥有独立的访问日志文件
   配置tomcat集群环境

修改server.xml配置文件，创建两个域名的虚拟主机，修改如下两个参数块：

[root@web1 ~]# cat /usr/local/tomcat/conf/server.xml
<Server>
   <Service>
     <Connector port=8080 />
     <Connector port=8009 />
     <Engine name="Catalina" defaultHost="localhost">
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
</Host>


步骤一：配置服务器虚拟主机
1）修改server.xml配置文件，创建虚拟主机
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml
<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
</Host>

2）创建虚拟主机对应的页面根路径
[root@web1 ~]# mkdir -p  /usr/local/tomcat/{a,b}/ROOT
[root@web1 ~]# echo "AAA"   > /usr/local/tomcat/a/ROOT/index.html
[root@web1 ~]# echo "BBB" > /usr/local/tomcat/b/ROOT/index.html

3）重启Tomcat服务器
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh

4）客户端设置hosts文件，并浏览测试页面进行测试(proxy充当客户端角色)
注意：ssh远程连接时使用使用-X参数才可以！！！
[root@proxy ~]# vim /etc/hosts
192.168.2.100      www.a.com  www.b.com
[root@proxy ~]# firefox http://www.a.com:8080/        //注意访问的端口为8080
[root@proxy ~]# firefox http://www.b.com:8080/

步骤二：修改www.b.com网站的首页目录为base
1）使用docBase参数可以修改默认网站首页路径
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml

<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
<Context path="" docBase="base"/>
</Host>

[root@web1 ~]# mkdir  /usr/local/tomcat/b/base
[root@web1 ~]# echo "BASE" > /usr/local/tomcat/b/base/index.html
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh

2）测试查看页面是否正确(proxy充当客户端角色)
[root@proxy ~]# firefox http://www.b.com:8080/   #结果为base目录下的页面内容

步骤三：跳转
1）当用户访问http://www.a.com/test打开/var/www/html目录下的页面
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml

<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
<Context path="/test" docBase="/var/www/html/" />
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
<Context path="" docBase="base" />
</Host>

[root@web1 ~]# echo "Test" > /var/www/html/index.html
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh

2）测试查看页面是否正确(proxy充当客户端角色)
[root@proxy ~]# firefox http://www.a.com:8080/test    
#返回/var/www/html/index.html的内容
#注意，访问的端口为8080

步骤四：配置Tomcat支持SSL加密网站
1）创建加密用的私钥和证书文件
[root@web1 ~]# keytool -genkeypair -alias tomcat -keyalg RSA -keystore /usr/local/tomcat/keystore  #提示输入密码为:123456
#-genkeypair     生成密钥对
#-alias tomcat     密钥别名
#-keyalg RSA     定义密钥算法为RSA算法
#-keystore         定义密钥文件存储在:/usr/local/tomcat/keystore

3）重启Tomcat服务器
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh

4）客户端设置host文件，并浏览测试页面进行测试(proxy充当客户端角色)
[root@proxy ~]# vim /etc/hosts

192.168.2.100      www.a.com  www.b.com
[root@proxy ~]# firefox https://www.a.com:8443/
[root@proxy ~]# firefox https://www.b.com:8443/
[root@proxy ~]# firefox https://192.168.2.100:8443/

步骤五：配置Tomcat日志
1)为每个虚拟主机设置不同的日志文件
[root@web1 ~]# vim /usr/local/tomcat/conf/server.xml

<Host name="www.a.com" appBase="a" unpackWARS="true" autoDeploy="true">
<Context path="/test" docBase="/var/www/html/" />
#从默认localhost虚拟主机中把Valve这段复制过来，适当修改下即可
<Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
               prefix=" a_access" suffix=".txt"
               pattern="%h %l %u %t &quot;%r&quot; %s %b" />
</Host>
<Host name="www.b.com" appBase="b" unpackWARS="true" autoDeploy="true">
<Context path="" docBase="base" />
<Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs"
               prefix=" b_access" suffix=".txt"
               pattern="%h %l %u %t &quot;%r&quot; %s %b" />
</Host>

2）重启Tomcat服务器
[root@web1 ~]# /usr/local/tomcat/bin/shutdown.sh
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh

3）查看服务器日志文件
[root@web1 ~]# ls /usr/local/tomcat/logs/

步骤六：扩展实验(配置Tomcat集群)
1) 在192.168.4.5主机上配置Nginx调度器（具体安装步骤参考前面的章节）
[root@proxy ~]# vim  /usr/local/nginx/conf/nginx.conf
http{
    upstream toms {
        server 192.168.2.100:8080;
        server 192.168.2.200:8080;
    }
    server  {
        listen 80;
        server_name localhost;
        location / {
            proxy_pass  http://toms;
        }
    }
}  

2) 在192.168.2.100和192.168.2.200主机上配置Tomcat调度器
以下以Web1为例：
[root@web1 ~]# yum -y install  java-1.8.0-openjdk           #安装JDK
[root@web1 ~]# yum -y install java-1.8.0-openjdk-headless   #安装JDK
[root@web1 ~]# tar -xzf  apache-tomcat-8.0.30.tar.gz
[root@web1 ~]# mv apache-tomcat-8.0.30  /usr/local/tomcat

3）启动服务
[root@web1 ~]# /usr/local/tomcat/bin/startup.sh

==========================================================================
使用Varnish加速Web

通过配置Varnish缓存服务器，实现如下目标：
   使用Varnish加速后端Web服务
   代理服务器可以将远程的Web服务器页面缓存在本地
   远程Web服务器对客户端用户是透明的
   利用缓存机制提高网站的响应速度
   使用varnishadm命令管理缓存页面
   使用varnishstat命令查看Varnish状态

通过源码编译安装Varnish缓存服务器
       编译安装Varnish软件
  修改配置文件，缓存代理源Web服务器，实现Web加速功能
  使用3台RHEL7虚拟机，其中一台作为Web服务器（192.168.2.100）、一台作为Varnish代理服务器（192.168.4.5,192.168.2.5)，另外一台作为测试用的Linux客户机 （192.168.4.10），如图-2所示。

步骤一：构建Web服务器
1）使用yum安装web软件包
[root@web1 ~]# yum  -y  install  httpd

2）启用httpd服务（注意需要关闭nginx，否则端口冲突）
[root@web1 ~]# systemctl start httpd
httpd服务默认通过TCP 80端口监听客户端请求：
[root@web1 ~]# netstat  -anptu  |  grep httpd
tcp        0        0        :::80        :::*        LISTEN        2813/httpd

3）为Web访问建立测试文件
在网站根目录/var/www/html下创建一个名为index.html的首页文件：
[root@web1 ~]# cat /var/www/html/index.html 
192.168.2.100

4）测试页面是否正常（代理服务器测试后台web）
[root@proxy ~]# firefox http://192.168.2.100

步骤二：部署Varnish缓存服务器(192.168.4.5)
1）编译安装软件
[root@proxy ~]# yum -y install gcc readline-devel  #安装软件依赖包
[root@proxy ~]# yum -y install ncurses-devel       #安装软件依赖包
[root@proxy ~]# yum -y install pcre-devel          #安装软件依赖包
[root@proxy ~]# yum -y install python-docutils     #安装软件依赖包
 [root@proxy ~]# useradd -s /sbin/nologin varnish  #创建账户
[root@proxy ~]# tar -xf varnish-5.2.1.tar.gz
[root@proxy ~]# cd varnish-5.2.1
[root@proxy varnish-5.2.1]# ./configure
[root@proxy varnish-5.2.1]# make && make install

2）复制启动脚本及配置文件
[root@proxy varnish-5.2.1]# cp  etc/example.vcl   /usr/local/etc/default.vcl

3）修改代理配置文件
[root@proxy ~]# vim  /usr/local/etc/default.vcl
backend default {
     .host = "192.168.2.100";
     .port = "80";
 }

4）启动服务
[root@proxy ~]# varnishd  -f /usr/local/etc/default.vcl
#varnishd命令的其他选项说明如下：
#varnishd -s malloc,128M        定义varnish使用内存作为缓存，空间为128M
#varnishd -s file,/var/lib/varnish_storage.bin,1G 定义varnish使用文件作为缓存

步骤三：客户端测试
1）客户端开启浏览器访问
[root@client ~]# curl http://192.168.4.5

步骤四：其他操作
1）查看varnish日志
[root@proxy ~]# varnishlog  #varnish日志
[root@proxy ~]# varnishncsa #访问日志

2）更新缓存数据，在后台web服务器更新页面内容后，用户访问代理服务器看到的还是之前的数据，说明缓存中的数据过期了需要更新（默认也会自动更新，但非实时更新）。
[root@proxy ~]# varnishadm  
varnish> ban req.url ~ .*
//清空缓存数据，支持正则表达式

operation_day06===============================================================================================

Git基本操作
1.1 问题

本案例要求先快速搭建好一台Git服务器，并测试该版本控制软件，要求如下：
    安装Git软件
    创建版本库
    客户端克隆版本仓库到本地
    本地工作目录修改数据
    提交本地修改到服务器

步骤一：部署Git服务器（192.168.2.100作为远程git服务器）
1）YUM安装Git软件。
  [root@web1 ~]# yum -y install git
  [root@web1 ~]# git --version

2)初始化一个空仓库。
  [root@web1 ~]# mkdir /var/git
  [root@web1 ~]# git init /var/git/project --bare 
  [root@web1 ~]# ls /var/git/
  config  description  HEAD  hooks  info  objects  refs   

1) clone克隆服务器仓库到本地。
  [root@web2 ~]# yum -y install git
  [root@web2 ~]# git clone root@192.168.2.100:/var/git/project 
  [root@web2 ~]# cd project
  [root@web2 ~]# ls 

2) 修改git配置。
  [root@web2 project]# git config --global user.email "you@example.com"
  [root@web2 project]# git config --global user.name "Your Name"
  [root@web2 project]# cat ~/.gitconfig 
  [user]
      email = you@example.com
      name = Your Name

3）本地工作区对数据进行增删改查(必须要先进入仓库再操作数据)。
  [root@web2 project]# echo "init date" > init.txt
  [root@web2 project]# mkdir demo
  [root@web2 project]# cp /etc/hosts demo

4） 查看仓库中数据的状态。
[root@web2 project]# git status

5）将工作区的修改提交到暂存区。
  [root@web2 project]# git add .

6) 将暂存区修改提交到本地仓库。
  [root@web2 project]# git commit  -m  "注释，可以为任意字符"
  [root@web2 project]# git status

7）将本地仓库中的数据推送到远程服务器(web2将数据推送到web1)。
  [root@web2 project]# git config --global push.default simple
  [root@web2 project]# git push
  root@192.168.2.100's password:  输入服务器root密码
  [root@web2 project]# git status

8) 将服务器上的数据更新到本地（web1的数据更新到web2）。
   备注：可能其他人也在修改数据并提交服务器，就会导致自己的本地数据为旧数据，使用pull就可以将服务器上新的数据更新到本地。
  [root@web2 project]# git pull

9) 查看版本日志。
  [root@web2 project]# git log
  [root@web2 project]# git log --pretty=oneline
  [root@web2 project]# git log --oneline
  [root@web2 project]# git reflog

==================================================================================
HEAD指针操作

   沿用练习一，学习操作HEAD指针，具体要求如下：
   查看Git版本信息
   移动指针
   通过移动HEAD指针恢复数据
   合并版本

HEAD指针是一个可以在任何分支和版本移动的指针，通过移动指针我们可以将数据还原至任何版本。每做一次提交操作都会导致git更新一个版本，HEAD指针也跟着自动移动。

步骤一：HEAD指针基本操作
1）准备工作（多对数据仓库进行修改、提交操作，以产生多个版本）。
[root@web2 project]# echo "new file" > new.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "add new.txt"

[root@web2 project]# echo "first" >> new.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "new.txt:first line"

[root@web2 project]# echo "second" >> new.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "new.txt:second"

[root@web2 project]# echo "third" >> new.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "new.txt:third"
[root@web2 project]# git push

[root@web2 project]# echo "123" > num.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "num.txt:123"

[root@web2 project]# echo "456" > num.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "num.txt:456"

[root@web2 project]# echo "789" > num.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "num.txt:789"
[root@web2 project]# git push

2) 查看Git版本信息。
[root@web2 project]# git reflog
[root@web2 project]# git log --oneline
04ddc0f num.txt:789
7bba57b num.txt:456
301c090 num.txt:123
b427164 new.txt:third
0584949 new.txt:second
ece2dfd new.txt:first line
e1112ac add new.txt
1a0d908 初始化

3）移动HEAD指针，将数据还原到任意版本。
提示：当前HEAD指针为HEAD@{0}。
[root@web2 project]# git reset --hard 301c0
[root@web2 project]# git reflog
301c090 HEAD@{0}: reset: moving to 301c0
04ddc0f HEAD@{1}: commit: num.txt:789
7bba57b HEAD@{2}: commit: num.txt:456
301c090 HEAD@{3}: commit: num.txt:123
b427164 HEAD@{5}: commit: new.txt:third
0584949 HEAD@{6}: commit: new.txt:second
ece2dfd HEAD@{7}: commit: new.txt:first line
e1112ac HEAD@{8}: commit: add new.txt
1a0d908 HEAD@{9}: commit (initial): 初始化
[root@web2 project]# cat num.txt              #查看文件是否为123
123
[root@web2 project]# git reset --hard 7bba57b
[root@web2 project]# cat num.txt              #查看文件是否为123，456
123
456

[root@web2 project]# git reflog               #查看指针移动历史
7bba57b HEAD@{0}: reset: moving to 7bba57b
301c090 HEAD@{1}: reset: moving to 301c0
… …
[root@web2 project]# git reset --hard 04ddc0f #恢复num.txt的所有数据

4)模拟误删后的数据还原操作。
[root@web2 project]# git rm init.txt                  #删除文件
rm 'init.txt'
[root@web2 project]# git commit -m "delete init.txt"  #提交本地仓库
[root@web2 project]# git reflog                       #查看版本历史
0dc2b76 HEAD@{0}: commit: delete init.txt
7bba57b HEAD@{0}: reset: moving to 7bba57b
301c090 HEAD@{1}: reset: moving to 301c0
… …
[root@web2 project]# git reset --hard 04ddc0f         #恢复数据
[root@web2 project]# ls
demo  init.txt  new.txt  num.txt

=====================================================================
Git分支操作

沿用练习二，学习操作Git分支，具体要求如下：
   查看分支
   创建分支
   切换分支
   合并分支
   解决分支的冲突

3.2 方案
   Git支持按功能模块、时间、版本等标准创建分支，分支可以让开发分多条主线同时进行，每条主线互不影响，分支效果如图-4所示。

常见的分支规范如下：
   MASTER分支（MASTER是主分支，是代码的核心）。
   DEVELOP分支（DEVELOP最新开发成果的分支）。
   RELEASE分支（为发布新产品设置的分支）。
   HOTFIX分支（为了修复软件BUG缺陷的分支）。
   FEATURE分支（为开发新功能设置的分支）。

步骤一：查看并创建分支
1）查看当前分支。
[root@web2 project]# git status
# On branch master
nothing to commit, working directory clean
[root@web2 project]# git branch -v
* master 0dc2b76 delete init.txt

2）创建分支。
[root@web2 project]# git branch hotfix
[root@web2 project]# git branch feature
[root@web2 project]# git branch -v
  feature 0dc2b76 delete init.txt
  hotfix  0dc2b76 delete init.txt
* master  0dc2b76 delete init.txt

步骤二：切换与合并分支
1）切换分支。
[root@web2 project]# git checkout hotfix
[root@web2 project]# git branch -v
  feature 0dc2b76 delete init.txt
* hotfix  0dc2b76 delete init.txt
master  0dc2b76 delete init.txt

2）在新的分支上可以继续进行数据操作（增、删、改、查）。
[root@web2 project]# echo "fix a bug" >> new.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "fix a bug"

3）将hotfix修改的数据合并到master分支。
注意，合并前必须要先切换到master分支，然后再执行merge命令。
[root@web2 project]# git checkout master
[root@web2 project]# cat new.txt        #默认master分支中没有hotfix分支中的数据
[root@web2 project]# git merge hotfix
Updating 0dc2b76..5b4a755
Fast-forward
 new.txt | 1 ++
 1 file changed, 1 insertions(+)

4）将所有本地修改提交远程服务器。
[root@web2 project]# git push

步骤二：解决版本分支的冲突问题
1）在不同分支中修改相同文件的相同行数据，模拟数据冲突。
[root@web2 project]# git checkout hotfix
[root@web2 project]# echo "AAA" > a.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "add a.txt by hotfix"
[root@web2 project]# echo "BBB" > a.txt
[root@web2 project]# git add .
[root@web2 project]# git commit -m "add a.txt by master"
自动合并 a.txt
冲突（添加/添加）：合并冲突于 a.txt
自动合并失败，修正冲突然后提交修正的结果。

2）查看有冲突的文件内容，修改文件为最终版本的数据，解决冲突。
[root@web2 project]# cat a.txt                #该文件中包含有冲突的内容
<<<<<<< HEAD
BBB
=======
AAA
>>>>>>> hotfix
[root@web2 project]# vim a.txt              #修改该文件，为最终需要的数据，解决冲突
BBB
[root@web2 project]# git add .
[root@web2 project]# git commit -m "resolved"

总结：分支指针与HEAD指针的关系。
创建分支的本质是在当前提交上创建一个可以移动的指针
如何判断当前分支呢？答案是根据HEAD这个特殊指针

============================================================================
Git服务器

沿用练习三，学习Git不同的服务器形式，具体要求如下：
    创建SSH协议服务器
    创建Git协议服务器
    创建HTTP协议服务器

Git支持很多服务器协议形式，不同协议的Git服务器，客户端就可以使用不同的形式访问服务器。创建的服务器协议有SSH协议、Git协议、HTTP协议。
步骤一：SSH协议服务器（支持读写操作）
1）创建基于密码验证的SSH协议服务器（web1主机操作）。
[root@web1 ~]# git init --bare /var/git/base_ssh
Initialized empty Git repository in /var/git/base_ssh/

2)客户端访问的方式（web2主机操作）。
[root@web2 ~]# git clone root@192.168.2.100:/var/git/base_ssh
[root@web2 ~]# rm -rf base_ssh

3）客户端生成SSH密钥，实现免密码登陆git服务器（web2主机操作）。
[root@web2 ~]# ssh-keygen -f /root/.ssh/id_rsa -N ''
[root@web2 ~]# ssh-copy-id  192.168.2.100
[root@web2 ~]# git clone root@192.168.2.100:/var/git
[root@web2 ~]# git push

步骤二：Git协议服务器（只读操作的服务器）
1）安装git-daemon软件包（web1主机操作）。
[root@web1 ~]# yum -y install git-daemon

2）创建版本库（web1主机操作）。
[root@web1 ~]# git init --bare /var/git/base_git
Initialized empty Git repository in /var/git/base_git/

3）修改配置文件，启动git服务（web1主机操作）。
[root@web1 ~]# vim /usr/lib/systemd/system/git@.service
修改前内容如下：
ExecStart=-/usr/libexec/git-core/git-daemon --base-path=/var/lib/git 
--export-all --user-path=public_git --syslog --inetd –verbose
修改后内容如下：
ExecStart=-/usr/libexec/git-core/git-daemon --base-path=/var/git 
--export-all --user-path=public_git --syslog --inetd –verbose
[root@web1 ~]# systemctl  start  git.socket

4）客户端访问方式（web2主机操作）
[root@web2 ~]# git clone git://192.168.2.100/base_git

步骤三：HTTP协议服务器（只读操作的服务器）
1）安装gitweb、httpd软件包（web1主机操作）。
[root@web1 ~]# yum -y install httpd gitweb

2）修改配置文件，设置仓库根目录（web1主机操作）。
[root@web1 ~]# vim +11 /etc/gitweb.conf 
$projectroot = "/var/git";                #添加一行

3) 创建版本仓库（web1主机操作）
[root@web1 ~]# git init --bare /var/git/base_http

4）启动httpd服务器
[root@web1 ~]# systemctl start httpd

5）客户端访问方式（web2主机操作）
注意：调用虚拟机中的firefox浏览器，需要在远程时使用ssh -X 服务器IP，并且确保真实主机的firefox已经关闭。
[root@web2 ~]# firefox http://192.168.2.100/git/

步骤四：课外扩展知识：注册使用Github
1.登陆网站https://github.com，点击Sign up（注册），如图-1所示。
2.填写注册信息（用户名，邮箱，密码），如图-2所示。
3. 初始化操作，如图-3和图-4所示。
注意，初始化完成后，到邮箱中去激活Github账户。
4. 创建仓库、使用仓库
点击Start a project（如图-5所示），
填写项目名称（项目名称任意），如图-6所示。
往仓库中上传文件或新建文件，如图-7所示
下载仓库中的代码，如图-8所示。
5. 命令行操作（需要联网的主机，如真实机）
[root@pc001 ~]# yum -y install git
[root@pc001 ~]# git clone https://github.com/账户名称/仓库名称
#clone指令用于将服务器仓库中的资料打包下载到本地
[root@pc001 ~]# cd 仓库名称
[root@pc001 ~]# 任意修改文件，或新建文件
[root@pc001 ~]# git add .
#add添加新文件
[root@pc001 ~]# git commit -m "test"
[root@pc001 ~]# git push
#commit和push实现提交代码的功能
[root@pc001 ~]# git pull

==================================================================================
制作nginx的RPM包

5.1 问题
  本案例使用nginx-1.12.2版本的源码软件，生成对应的RPM包软件，具体要求如下：
     软件名称为nginx
     软件版本为1.12.2
    RPM软件包可以查询描述信息
    RPM软件包可以安装及卸载

5.2 方案
   安装rpm-build软件包，编写SPEC配置文件，创建新的RPM软件包。

实现此案例需要按照如下步骤进行。
步骤一：安装rpm-build软件
1）安装rpm-build软件包
[root@web1 ~]# yum -y install  rpm-build

2）生成rpmbuild目录结构
[root@web1 ~]# rpmbuild -ba nginx.spec #会报错，没有文件或目录
[root@web1 ~]# ls /root/rpmbuild       #自动生成的目录结构
BUILD  BUILDROOT  RPMS  SOURCES  SPECS  SRPMS

3）准备工作，将源码软件复制到SOURCES目录
[root@web1 ~]# cp nginx-1.12.2.tar.gz /root/rpmbuild/SOURCES/

4）创建并修改SPEC配置文件
[root@web1 ~]# vim /root/rpmbuild/SPECS/nginx.spec 
Name:nginx                                #源码包软件名称
Version:1.12.2                            #源码包软件的版本号
Release:    10                            #制作的RPM包版本号
Summary: Nginx is a web server software.  #RPM软件的概述    
License:GPL                               #软件的协议
URL:    www.test.com                      #网址
Source0:nginx-1.12.2.tar.gz               #源码包文件的全称
#BuildRequires:                           #制作RPM时的依赖关系
#Requires:                                #安装RPM时的依赖关系
%description
nginx [engine x] is an HTTP and reverse proxy server.  #软件的详细描述
%post
useradd nginx  #非必需操作：安装后脚本(创建账户)
%prep
%setup -q      #自动解压源码包，并cd进入目录
%build
./configure
make %{?_smp_mflags}
%install
make install DESTDIR=%{buildroot}
%files
%doc
/usr/local/nginx/*   #对哪些文件与目录打包
%changelog


步骤二：使用配置文件创建RPM包
1）安装依赖软件包
[root@web1 ~]# yum -y install  gcc  pcre-devel openssl-devel

2）rpmbuild创建RPM软件包
[root@web1 ~]# rpmbuild -ba /root/rpmbuild/SPECS/nginx.spec
[root@web1 ~]# ls /root/rpmbuild/RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm
[root@web1 ~]# rpm -qpi RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm 
Name        : nginx        Relocations: (not relocatable)
Version     : 1.12.2        Vendor: (none)
Release     : 10            Build Date: Mon 02 May 2016 02:30:53 AM PDT
Install Date: (not installed)            Build Host: localhost
Group       : Applications/Internet        Source RPM: nginx-1.8.0-1.src.rpm
Size        : 721243                    License: GPL
Signature   : (none)
URL         : www.nginx.org
Summary     : Nginx is a web server software.
Description :
nginx [engine x] is an HTTP and reverse proxy server.
[root@web1 ~]# rpm -qpl nginx-1.12.2-10.x86_64.rpm 
/usr
/usr/local
/usr/local/nginx
/usr/local/nginx/conf
/usr/local/nginx/conf/fastcgi.conf
/usr/local/nginx/conf/fastcgi.conf.default
/usr/local/nginx/conf/fastcgi_params
/usr/local/nginx/conf/fastcgi_params.default
/usr/local/nginx/conf/koi-utf
/usr/local/nginx/conf/koi-win
/usr/local/nginx/conf/mime.types
/usr/local/nginx/conf/mime.types.default
/usr/local/nginx/conf/nginx.conf
/usr/local/nginx/conf/nginx.conf.default
/usr/local/nginx/conf/scgi_params
/usr/local/nginx/conf/scgi_params.default
/usr/local/nginx/conf/uwsgi_params
/usr/local/nginx/conf/uwsgi_params.default
/usr/local/nginx/conf/win-utf
/usr/local/nginx/html
/usr/local/nginx/html/50x.html
/usr/local/nginx/html/index.html
/usr/local/nginx/logs
/usr/local/nginx/sbin
/usr/local/nginx/sbin/nginx

步骤三：安装、卸载软件
[root@web1 ~]# rpm -ivh RPMS/x86_64/nginx-1.12.2-10.x86_64.rpm 
[root@web1 ~]# rpm -qa |grep nginx
[root@web1 ~]# /usr/local/nginx/sbin/nginx
[root@web1 ~]# curl http://127.0.0.1/

operation_day07===============================================================================================

配置GRE VPN

1.1 问题

本案例要求搭建一个GRE VPN环境，并测试该VPN网络是否能够正常通讯，要求如下：
启用内核模块ip_gre
创建一个虚拟VPN隧道(10.10.10.0/24)
实现两台主机点到点的隧道通讯

1.2 方案
   使用lsmod查看当前计算机已经加载的模块，使用modprobe加载Linux内核模块，使用modinfo可以查看内核模块的信息。
   准备实验所需的虚拟机环境，实验环境所需要的主机及对应的IP设置列表如表-1所示，正确配置IP地址、主机名称，并且为每台主机配置YUM源。

1.3 步骤
实现此案例需要按照如下步骤进行。
步骤一：启用GRE模块（client和proxy都需要操作）
1）查看计算机当前加载的模块
[root@client ~]# lsmod                 #显示模块列表
[root@client ~]# lsmod  | grep ip_gre  #确定是否加载了gre模块

2)加载模块ip_gre
[root@client ~]# modprobe  ip_gre 

3）查看模块信息
[root@client ~]# modinfo ip_gre
filename:       /lib/modules/3.10.0-693.el7.x86_64/kernel/net/ipv4/ip_gre.ko.xz
alias:          netdev-gretap0
alias:          netdev-gre0
alias:          rtnl-link-gretap
alias:          rtnl-link-gre
license:        GPL
rhelversion:    7.4
srcversion:     F37A2BF90692F86E3A8BD15
depends:        ip_tunnel,gre
intree:         Y
vermagic:       3.10.0-693.el7.x86_64 SMP mod_unload modversions 
signer:         CentOS Linux kernel signing key
sig_key:        DA:18:7D:CA:7D:BE:53:AB:05:BD:13:BD:0C:4E:21:F4:22:B6:A4:9C
sig_hashalgo:   sha256
parm:           log_ecn_error:Log packets received with corrupted ECN (bool)
      
步骤二：Client主机创建VPN隧道
1）创建隧道
[root@client ~]# ip tunnel add tun0  mode gre \ 
>  remote 201.1.2.5 local 201.1.2.10
//ip tunnel add创建隧道（隧道名称为tun0），ip tunnel help可以查看帮助
//mode设置隧道使用gre模式
//local后面跟本机的IP地址，remote后面是与其他主机建立隧道的对方IP地址

2）启用该隧道（类似与设置网卡up）
[root@client ~]# ip link show
[root@client ~]# ip link set tun0 up   #设置UP
[root@client ~]# ip link show

2）为VPN配置隧道IP地址
[root@client ~]# ip addr add 10.10.10.10/24 peer 10.10.10.5/24 \
>  dev tun0
//为隧道tun0设置本地IP地址（10.10.10.10.10/24）
//隧道对面的主机IP的隧道IP为10.10.10.5/24
[root@client ~]# ip a s    #查看IP地址

3）关闭防火墙
[root@client ~]# firewall-cmd --set-default-zone=trusted

步骤三：Proxy主机创建VPN隧道
1）查看计算机当前加载的模块
[root@client ~]# lsmod                #显示模块列表
[root@client ~]# lsmod  | grep ip_gre #确定是否加载了gre模块

2)加载模块ip_gre
[root@client ~]# modprobe  ip_gre

3）创建隧道
[root@proxy ~]# ~]# ip tunnel add tun0  mode gre \ 
>  remote 201.1.2.10 local 201.1.2.5
#ip tunnel add创建隧道（隧道名称为tun0），ip tunnel help可以查看帮助
#mode设置隧道使用gre模式
#local后面跟本机的IP地址，remote后面是与其他主机建立隧道的对方IP地址

4）启用该隧道（类似与设置网卡up）
[root@proxy ~]# ip link show
[root@proxy ~]# ip link set tun0 up  #设置UP
[root@proxy ~]# ip link show

5）为VPN配置隧道IP地址
[root@proxy ~]# ip addr add 10.10.10.5/24 peer 10.10.10.10/24 \
>  dev tun0
//为隧道tun0设置本地IP地址（10.10.10.10.5/24）
//隧道对面的主机IP的隧道IP为10.10.10.10/24
[root@proxy ~]# ip a s   #查看IP地址

6）开启路由转发、关闭防火墙
[root@proxy ~]# echo "1" > /proc/sys/net/ipv4/ip_forward
[root@proxy ~]# firewall-cmd --set-default-zone=trusted

7)测试连通性
[root@client ~]#  ping 10.10.10.5
[root@proxy ~]#   ping 10.10.10.10

==================================================================
创建PPTP VPN

 2.1 问题

  本案例要求搭建一个PPTP VPN环境，并测试该VPN网络是否能够正常通讯，要求如下:
     使用PPTP协议创建一个支持身份验证的隧道连接
     使用MPPE对数据进行加密
     为客户端分配192.168.3.0/24的地址池
     客户端连接的用户名为jacob，密码为123456

步骤一：部署VPN服务器

1）安装软件包（软件包参考lnmp_soft）
[root@proxy ~]# yum localinstall pptpd-1.4.0-2.el7.x86_64.rpm  或 [root@proxy ~]# yum -y install pptp
[root@proxy ~]# rpm -qc pptpd
/etc/ppp/options.pptpd
/etc/pptpd.conf
/etc/sysconfig/pptpd

2)修改配置文件
[root@proxy ~]# vim /etc/pptpd.conf
.. ..
localip 201.1.2.5                           #服务器本地IP
remoteip 192.168.3.1-50                     #分配给客户端的IP池
[root@proxy ~]# vim /etc/ppp/options.pptpd
require-mppe-128                            #使用MPPE加密数据
ms-dns 8.8.8.8                              #DNS服务器
[root@proxy ~]# vim /etc/ppp/chap-secrets   #修改账户配置文件
jacob           *               123456      *
//用户名    服务器标记    密码    客户端
[root@proxy ~]# echo "1" > /proc/sys/net/ipv4/ip_forward #开启路由转发

3）启动服务
[root@proxy ~]# systemctl start pptpd
[root@proxy ~]# systemctl enable pptpd
[root@proxy ~]# firewall-cmd --set-default-zone=trusted

4）翻墙设置（非必需操作）
[root@proxy ~]# iptables -t nat -A POSTROUTING -s 192.168.3.0/24 \
>  -j SNAT --to-source 201.1.2.5


步骤二：客户端设置
启动一台Windows虚拟机，将虚拟机网卡桥接到public2，配置IP地址为201.1.2.20。
新建网络连接（具体操作如图-3所示），输入VPN服务器账户与密码（具体操作如图-4所示），连接VPN并测试网络连通性

=========================================================================
创建L2TP+IPSec VPN

3.1 问题
  本案例要求搭建一个L2TP+IPSec VPN环境，并测试该VPN网络是否能够正常通讯，具体要求如下：
    使用L2TP协议创建一个支持身份验证与加密的隧道连接
    使用IPSec对数据进行加密
    为客户端分配192.168.3.0/24的地址池
    客户端连接的用户名为：jacob，密码为：123456
    预共享密钥为：randpass

3.2 方案
   准备实验所需的虚拟机环境，实验环境所需要的主机及对应的IP设置列表如表-3所示，正确配置IP地址、主机名称，并且为每台主机配置YUM源。

3.3 步骤
实现此案例需要按照如下步骤进行。
步骤一：部署IPSec服务
1）安装软件包
[root@client ~]# yum -y install libreswan

2)新建IPSec密钥验证配置文件
[root@client ~]# cat /etc/ipsec.conf #仅查看一下该主配置文件
include /etc/ipsec.d/*.conf  #加载该目录下的所有配置文件
[root@client ~]# vim /etc/ipsec.d/myipsec.conf            
//新建该文件，参考lnmp_soft/vpn/myipsec.conf    
conn IDC-PSK-NAT
    rightsubnet=vhost:%priv  #允许建立的VPN虚拟网络
    also=IDC-PSK-noNAT
conn IDC-PSK-noNAT
    authby=secret                       #加密认证
        ike=3des-sha1;modp1024          #算法
        phase2alg=aes256-sha1;modp2048  #算法
    pfs=no
    auto=add
    keyingtries=3
    rekey=no
    ikelifetime=8h
    keylife=3h
    type=transport
    left=201.1.2.10  #重要，服务器本机的外网IP
    leftprotoport=17/1701
    right=%any  #允许任何客户端连接
    rightprotoport=17/%any

3)创建IPSec预定义共享密钥
[root@client ~]# cat /etc/ipsec.secrets          #仅查看，不要修改该文件
include /etc/ipsec.d/*.secrets
[root@client ~]# vim /etc/ipsec.d/mypass.secrets #新建该文件
201.1.2.10   %any:    PSK    "randpass"          #randpass为预共享密钥
                                                #201.1.2.10是VPN服务器的IP

4)启动IPSec服务
[root@client ~]# systemctl start ipsec        
[root@client ~]# netstat -ntulp |grep pluto
udp        0      0 127.0.0.1:4500          0.0.0.0:*           3148/pluto          
udp        0      0 192.168.4.10:4500      0.0.0.0:*           3148/pluto          
udp        0      0 201.1.2.10:4500         0.0.0.0:*           3148/pluto          
udp        0      0 127.0.0.1:500           0.0.0.0:*           3148/pluto          
udp        0      0 192.168.4.10:500       0.0.0.0:*           3148/pluto          
udp        0      0 201.1.2.10:500          0.0.0.0:*           3148/pluto          
udp6       0      0 ::1:500                 :::*                 3148/pluto

步骤二：部署XL2TP服务
1）安装软件包（软件包参考lnmp_soft）
[root@client ~]# yum localinstall xl2tpd-1.3.8-2.el7.x86_64.rpm

2)新建IPSec密钥验证配置文件
[root@client ~]# cat /etc/ipsec.conf  #仅查看一下该主配置文件
.. ..
include /etc/ipsec.d/*.conf  #加载该目录下的所有配置文件
[root@client ~]# vim /etc/ipsec.d/myipsec.conf            
//新建该文件，参考lnmp_soft/vpn/myipsec.conf    
conn IDC-PSK-NAT
    rightsubnet=vhost:%priv  #允许建立的VPN虚拟网络
    also=IDC-PSK-noNAT
conn IDC-PSK-noNAT
    authby=secret   #加密认证
        ike=3des-sha1;modp1024          #算法
        phase2alg=aes256-sha1;modp2048  #算法
    pfs=no
    auto=add
    keyingtries=3
    rekey=no
    ikelifetime=8h
    keylife=3h
    type=transport
    left=201.1.2.10  #重要，服务器本机的外网IP
    leftprotoport=17/1701
    right=%any  #允许任何客户端连接
    rightprotoport=17/%any

3)创建IPSec预定义共享密钥
[root@client ~]# cat /etc/ipsec.secrets           #仅查看，不要修改该文件
include /etc/ipsec.d/*.secrets
[root@client ~]# vim /etc/ipsec.d/mypass.secrets  #新建该文件
201.1.2.10   %any:    PSK    "randpass"           #randpass为预共享密钥
                                                                #201.1.2.10是VPN服务器的IP
4)启动IPSec服务
[root@client ~]# systemctl start ipsec        
[root@client ~]# netstat -ntulp |grep pluto
udp        0      0 127.0.0.1:4500          0.0.0.0:*           3148/pluto          
udp        0      0 192.168.4.10:4500      0.0.0.0:*           3148/pluto          
udp        0      0 201.1.2.10:4500         0.0.0.0:*           3148/pluto          
udp        0      0 127.0.0.1:500           0.0.0.0:*           3148/pluto          
udp        0      0 192.168.4.10:500       0.0.0.0:*           3148/pluto          
udp        0      0 201.1.2.10:500          0.0.0.0:*           3148/pluto          
udp6       0      0 ::1:500                 :::*                 3148/pluto

步骤二：部署XL2TP服务
1）安装软件包（软件包参考lnmp_soft）
[root@client ~]# yum localinstall xl2tpd-1.3.8-2.el7.x86_64.rpm

2) 修改xl2tp配置文件（修改3个配置文件的内容）
[root@client ~]#  vim  /etc/xl2tpd/xl2tpd.conf #修改主配置文件
[global]
  
[lns default]

ip range = 192.168.3.128-192.168.3.254        #分配给客户端的IP池
local ip = 201.1.2.10                         #VPN服务器的IP地址
[root@client ~]# vim /etc/ppp/options.xl2tpd  #认证配置
require-mschap-v2                             #添加一行，强制要求认证
#crtscts                                      #注释或删除该行
#lock                                         #注释或删除该行
root@client ~]# vim /etc/ppp/chap-secrets     #修改密码文件
jacob   *       123456  *                     #账户名称   服务器标记   密码   客户端IP

3）启动服务
[root@client ~]# systemctl start xl2tpd
[root@client ~]# netstat  -ntulp |grep xl2tpd        
udp     0      0 0.0.0.0:1701      0.0.0.0:*          3580/xl2tpd

4）设置路由转发，防火墙
[root@client ~]# echo "1" > /proc/sys/net/ipv4/ip_forward
[root@client ~]# firewall-cmd --set-default-zone=trusted

5）翻墙设置（非必需操作）
[root@client ~]# iptables -t nat -A POSTROUTING -s 192.168.3.0/24 \
>  -j SNAT --to-source 201.1.2.10

步骤二：客户端设置
启动一台Windows虚拟机，将虚拟机网卡桥接到public2，配置IP地址为201.1.2.20。
1. 新建网络连接（参考案例2），输入VPN服务器账户与密码（参考案例2）。
设置VPN连接的属性，预共享密钥是IPSec配置文件中填写的randpass

2. 设置Windows注册表（不修改注册表，连接VPN默认会报789错误），具体操作如下：
单击"开始"，单击"运行"，键入"regedit"，然后单击"确定"
找到下面的注册表子项，然后单击它：
HKEY_LOCAL_MACHINE\ System\CurrentControlSet\Services\Rasman\Parameters
在"编辑"菜单上，单击"新建"->"DWORD值"
在"名称"框中，键入"ProhibitIpSec"
在"数值数据"框中，键入"1"，然后单击"确定"
退出注册表编辑器，然后重新启动计算机

=======================================================================
NTP时间同步

4.1 问题
本案例要求搭建一个NTP服务器，为整个网络环境中的所有主机提供时间校准服务，具体要求如下：
   部署一台NTP时间服务器
   设置时间服务器上层与0.centos.pool.ntp.org同步
   设置本地服务器层级数量为10
   允许192.168.4.0/24网络的主机同步时间
   客户端验证时间是否同步

4.2 方案
准备实验所需的虚拟机环境，实验环境所需要的主机及对应的IP设置列表如表-4所示，正确配置IP地址、主机名称，并且为每台主机配置YUM源。
Network Time Protocol（网络时间协议）采用的是分层设计，如图-9所示，Stratum层的总数限制在15以内（包括15）

4.3 步骤
实现此案例需要按照如下步骤进行。

步骤一：部署NTP服务

1）安装软件包
[root@proxy ~]# yum -y install chrony
[root@proxy ~]# rpm -qc chrony  #查看配置文件列表
/etc/chrony.conf
/etc/chrony.keys

2)修改配置文件
[root@proxy ~]# cat /etc/chrony.conf
...
server 0.centos.pool.ntp.org iburst  #server用户客户端指向上层NTP服务器
allow 192.168.4.0/24                 #允许那个IP或网络访问NTP
#deny  192.168.4.1                   #拒绝那个IP或网络访问NTP
local stratum 10                     #设置NTP服务器的层数量
...

4)启动NTP服务
[root@proxy ~]# systemctl  restart  chronyd
[root@proxy ~]# systemctl  enable  chronyd

5)设置防火墙
[root@proxy ~]# firewall-cmd --set-default-zone=trusted

步骤二：配置客户端
1）安装软件包
[root@client ~]# yum -y install chrony

2) 修改配置文件
[root@client ~]# vim /etc/chrony.conf
server 192.168.4.5 iburst   #设置与哪台服务器同步数据
                            #iburst参数设置重启服务后尽快同步时间

3) 将客户端时间修改为错误的时间
[root@client ~]#  date  -s  "hour:minute"   #调整时间（小时：分钟）
[root@client ~]#  date                      #查看修改后的时间

4) 重启chrony与服务器同步时间
[root@client ~]# systemctl  restart  chronyd

5) 确认时间是否已经同步
[root@client ~]# date  #多执行几次查看结果

华为云NTP服务器信息一览
https://support.huaweicloud.com/ecs_faq/zh-cn_topic_0093971249.html

7.cluster================================================================================================

cluster_day01============================================================================================

1 案例1：ipvsadm命令用法
1.1 问题

  准备一台Linux服务器，安装ipvsadm软件包，练习使用ipvsadm命令，实现如下功能：
    使用命令添加基于TCP一些的集群服务
    在集群中添加若干台后端真实服务器
    实现同一客户端访问，调度器分配固定服务器
    会使用ipvsadm实现规则的增、删、改
    保存ipvsadm规则

1.2 方案

   安装ipvsadm软件包，关于ipvsadm的用法可以参考man ipvsadm资料。
   常用ipvsadm命令语法格式如表-1及表-2所示。

1.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：使用命令增、删、改LVS集群规则

1）创建LVS虚拟集群服务器（算法为加权轮询：wrr）
[root@proxy ~]# yum -y install ipvsadm
[root@proxy ~]# ipvsadm -A -t 192.168.4.5:80 -s wrr
[root@proxy ~]# ipvsadm -Ln  #查看LVS规则表
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.4.5:80 wrr

2）为集群添加若干real server
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.100 -m -w 1
[root@proxy ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.4.5:80 wrr
  -> 192.168.2.100:80             Masq    1      0          0
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:80 -r 192.168.2.200 -m -w 2
[root@proxy ~]# ipvsadm –a -t 192.168.4.5:80 -r 192.168.2.201 -m -w 3
[root@proxy ~]# ipvsadm –a -t 192.168.4.5:80 -r 192.168.2.202 -m -w 4

3）修改集群服务器设置(修改调度器算法，将加权轮询修改为轮询)
[root@proxy ~]# ipvsadm -E -t 192.168.4.5:80 -s rr
[root@proxy ~]# ipvsadm -Ln
IP Virtual Server version 1.2.1 (size=4096)
Prot LocalAddress:Port Scheduler Flags
  -> RemoteAddress:Port           Forward Weight ActiveConn InActConn
TCP  192.168.4.5:80 rr
  -> 192.168.2.100:80             Masq    1      0          0         
  -> 192.168.2.200:80             Masq    2      0          0         
  -> 192.168.2.201:80             Masq    2      0          0         
  -> 192.168.2.202:80             Masq    1      0          0

4）修改read server（使用-g选项，将模式改为DR模式）
[root@proxy ~]# ipvsadm -e -t 192.168.4.5:80 -r 192.168.2.202 -g

5）查看LVS状态
[root@proxy ~]# ipvsadm -Ln

6）创建另一个集群（算法为最少连接算法；使用-m选项，设置工作模式为NAT模式）
[root@proxy ~]# ipvsadm -A -t 192.168.4.5:3306 -s lc
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:3306 -r 192.168.2.100 -m
[root@proxy ~]# ipvsadm -a -t 192.168.4.5:3306 -r 192.168.2.200 -m

6）永久保存所有规则
[root@proxy ~]# ipvsadm-save -n > /etc/sysconfig/ipvsadm

7）清空所有规则
[root@proxy ~]# ipvsadm -C

8)删除一个集群
root@proxy ~]# ipvsadm -D 

====================================================================
部署LVS-NAT集群

2.1 问题

  使用LVS实现NAT模式的集群调度服务器，为用户提供Web服务：
    集群对外公网IP地址为192.168.4.5
    调度器内网IP地址为192.168.2.5
    真实Web服务器地址分别为192.168.2.100、192.168.2.200
    使用加权轮询调度算法，真实服务器权重分别为1和2

说明：
CIP是客户端的IP地址；
VIP是对客户端提供服务的IP地址；
RIP是后端服务器的真实IP地址；
DIP是调度器与后端服务器通信的IP地址（VIP必须配置在虚拟接口）。

3.3 步骤
实现此案例需要按照如下步骤进行。
说明：
CIP是客户端的IP地址；
VIP是对客户端提供服务的IP地址；
RIP是后端服务器的真实IP地址；
DIP是调度器与后端服务器通信的IP地址（VIP必须配置在虚拟接口）。
步骤一：配置实验网络环境

1）设置Proxy代理服务器的VIP和DIP

注意：为了防止冲突，VIP必须要配置在网卡的虚拟接口！！！
[root@proxy ~]# cd /etc/sysconfig/network-scripts/
[root@proxy ~]# cp ifcfg-eth0{,:0}
[root@proxy ~]# vim ifcfg-eth0
TYPE=Ethernet
BOOTPROTO=none
NAME=eth0
DEVICE=eth0
ONBOOT=yes
IPADDR=192.168.4.5
PREFIX=24
[root@proxy ~]# vim ifcfg-eth0:0
TYPE=Ethernet
BOOTPROTO=none
DEFROUTE=yes
NAME=eth0:0
DEVICE=eth0:0
ONBOOT=yes
IPADDR=192.168.4.15
PREFIX=24
[root@proxy ~]# systemctl restart network

2）设置Web1服务器网络参数
[root@web1 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth0

接下来给web1配置VIP地址。
注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。
[root@web1 ~]# cd /etc/sysconfig/network-scripts/
[root@web1 ~]# cp ifcfg-lo{,:0}
[root@web1 ~]# vim ifcfg-lo:0
DEVICE=lo:0
IPADDR=192.168.4.15
NETMASK=255.255.255.255
NETWORK=192.168.4.15
BROADCAST=192.168.4.15
ONBOOT=yes
NAME=lo:0

防止地址冲突的问题：
这里因为web1也配置与代理一样的VIP地址，默认肯定会出现地址冲突；
sysctl.conf文件写入这下面四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应，这样防止地址冲突的问题。
[root@web1 ~]# vim /etc/sysctl.conf
#手动写入如下4行内容
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
net.ipv4.conf.all.arp_announce = 2
#当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应
#本机不要向外宣告自己的lo回环地址是192.168.4.15
[root@web1 ~]# sysctl -p

重启网络服务，设置防火墙与SELinux
[root@web1 ~]# systemctl restart network
[root@web1 ~]# ifconfig
[root@web1 ~]# systemctl stop firewalld
[root@web1 ~]# setenforce 0

3）设置Web2服务器网络参数
[root@web2 ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.200/24 connection.autoconnect yes
[root@web2 ~]# nmcli connection up eth0

接下来给web2配置VIP地址
注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。
[root@web2 ~]# cd /etc/sysconfig/network-scripts/
[root@web2 ~]# cp ifcfg-lo{,:0}
[root@web2 ~]# vim ifcfg-lo:0
DEVICE=lo:0
IPADDR=192.168.4.15
NETMASK=255.255.255.255
NETWORK=192.168.4.15
BROADCAST=192.168.4.15
ONBOOT=yes
NAME=lo:0

防止地址冲突的问题：
这里因为web1也配置与代理一样的VIP地址，默认肯定会出现地址冲突；
sysctl.conf文件写入这下面四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应，这样防止地址冲突的问题。
[root@web2 ~]# vim /etc/sysctl.conf
#手动写入如下4行内容
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
net.ipv4.conf.all.arp_announce = 2
#当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应
#本机不要向外宣告自己的lo回环地址是192.168.4.15
[root@web2 ~]# sysctl -p

重启网络服务，设置防火墙与SELinux
[root@web2 ~]# systemctl restart network
[root@web2 ~]# ifconfig
[root@web2 ~]# systemctl stop firewalld
[root@web2 ~]# setenforce 0

步骤二：配置后端Web服务器
1）自定义Web页面
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# echo "192.168.4.100" > /var/www/html/index.html
[root@web2 ~]# yum -y install httpd
[root@web2 ~]# echo "192.168.4.200" > /var/www/html/index.html

2）启动Web服务器软件
[root@web1 ~]# systemctl restart httpd
[root@web2 ~]# systemctl enable httpd

步骤三：proxy调度器安装软件并部署LVS-DR模式调度器
1）安装软件（如果已经安装，此步骤可以忽略）
[root@proxy ~]# yum -y install ipvsadm

2）清理之前实验的规则，创建新的集群服务器规则
[root@proxy ~]# ipvsadm -C  #清空所有规则
[root@proxy ~]# ipvsadm -A -t 192.168.4.15:80 -s wrr

3）添加真实服务器(-g参数设置LVS工作模式为DR模式，-w设置权重)
[root@proxy ~]# ipvsadm -a -t 192.168.4.15:80 -r 192.168.4.100 -g -w 1
[root@proxy ~]# ipvsadm -a -t 192.168.4.15:80 -r 192.168.4.200 -g -w 1

4）查看规则列表，并保存规则
[root@proxy ~]# ipvsadm -Ln
TCP  192.168.4.15:80 wrr
  -> 192.168.4.100:80             Route   1      0          0         
  -> 192.168.4.200:80             Route   2      0          0
[root@proxy ~]# ipvsadm-save -n > /etc/sysconfig/ipvsadm

步骤四：客户端测试
客户端使用curl命令反复连接http://192.168.4.15，查看访问的页面是否会轮询到不同的后端真实服务器。
扩展知识：默认LVS不带健康检查功能，需要自己手动编写动态检测脚本，实现该功能：(参考脚本如下，仅供参考)
[root@proxy ~]# vim check.sh
#!/bin/bash
VIP=192.168.4.15:80
RIP1=192.168.4.100
RIP2=192.168.4.200
while :
do
   for IP in $RIP1 $RIP2
   do
           curl -s http://$IP &>/dev/vnull
if [ $? -eq 0 ];then
            ipvsadm -Ln |grep -q $IP || ipvsadm -a -t $VIP -r $IP
        else
             ipvsadm -Ln |grep -q $IP && ipvsadm -d -t $VIP -r $IP
        fi
   done
sleep 1
done

===========================================================================
部署LVS-DR集群

3.1 问题
  使用LVS实现DR模式的集群调度服务器，为用户提供Web服务：
    客户端IP地址为192.168.4.10
    LVS调度器VIP地址为192.168.4.15
    LVS调度器DIP地址设置为192.168.4.5
     真实Web服务器地址分别为192.168.4.100、192.168.4.200
     使用加权轮询调度算法，web1的权重为1，web2的权重为2
说明：
CIP是客户端的IP地址；
VIP是对客户端提供服务的IP地址；
RIP是后端服务器的真实IP地址；
DIP是调度器与后端服务器通信的IP地址（VIP必须配置在虚拟接口）。
3.2 方案

使用4台虚拟机，1台作为客户端、1台作为Director调度器、2台作为Real Server，

3.3 步骤

实现此案例需要按照如下步骤进行。
说明：
CIP是客户端的IP地址；
VIP是对客户端提供服务的IP地址；
RIP是后端服务器的真实IP地址；
DIP是调度器与后端服务器通信的IP地址（VIP必须配置在虚拟接口）。
步骤一：配置实验网络环境

1）设置Proxy代理服务器的VIP和DIP
注意：为了防止冲突，VIP必须要配置在网卡的虚拟接口！！！
[root@proxy ~]# cd /etc/sysconfig/network-scripts/
[root@proxy ~]# cp ifcfg-eth0{,:0}
[root@proxy ~]# vim ifcfg-eth0
TYPE=Ethernet
BOOTPROTO=none
NAME=eth0
DEVICE=eth0
ONBOOT=yes
IPADDR=192.168.4.5
PREFIX=24
[root@proxy ~]# vim ifcfg-eth0:0
TYPE=Ethernet
BOOTPROTO=none
DEFROUTE=yes
NAME=eth0:0
DEVICE=eth0:0
ONBOOT=yes
IPADDR=192.168.4.15
PREFIX=24
[root@proxy ~]# systemctl restart network

2）设置Web1服务器网络参数
[root@web1 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth0

接下来给web1配置VIP地址。
注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。
[root@web1 ~]# cd /etc/sysconfig/network-scripts/
[root@web1 ~]# cp ifcfg-lo{,:0}
[root@web1 ~]# vim ifcfg-lo:0
DEVICE=lo:0
IPADDR=192.168.4.15
NETMASK=255.255.255.255
NETWORK=192.168.4.15
BROADCAST=192.168.4.15
ONBOOT=yes
NAME=lo:0

防止地址冲突的问题：
这里因为web1也配置与代理一样的VIP地址，默认肯定会出现地址冲突；
sysctl.conf文件写入这下面四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应，这样防止地址冲突的问题。
[root@web1 ~]# vim /etc/sysctl.conf
#手动写入如下4行内容
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
net.ipv4.conf.all.arp_announce = 2
#当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应
#本机不要向外宣告自己的lo回环地址是192.168.4.15
[root@web1 ~]# sysctl -p

重启网络服务，设置防火墙与SELinux
[root@web1 ~]# systemctl restart network
[root@web1 ~]# ifconfig
[root@web1 ~]# systemctl stop firewalld
[root@web1 ~]# setenforce 0

3）设置Web2服务器网络参数
[root@web2 ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.200/24 connection.autoconnect yes
[root@web2 ~]# nmcli connection up eth0

接下来给web2配置VIP地址
注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。
[root@web2 ~]# cd /etc/sysconfig/network-scripts/
[root@web2 ~]# cp ifcfg-lo{,:0}
[root@web2 ~]# vim ifcfg-lo:0
DEVICE=lo:0
IPADDR=192.168.4.15
NETMASK=255.255.255.255
NETWORK=192.168.4.15
BROADCAST=192.168.4.15
ONBOOT=yes
NAME=lo:0

防止地址冲突的问题：
这里因为web1也配置与代理一样的VIP地址，默认肯定会出现地址冲突；
sysctl.conf文件写入这下面四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应，这样防止地址冲突的问题。
[root@web2 ~]# vim /etc/sysctl.conf
#手动写入如下4行内容
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
net.ipv4.conf.all.arp_announce = 2
#当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应
#本机不要向外宣告自己的lo回环地址是192.168.4.15
[root@web2 ~]# sysctl -p

重启网络服务，设置防火墙与SELinux
[root@web2 ~]# systemctl restart network
[root@web2 ~]# ifconfig
[root@web2 ~]# systemctl stop firewalld
[root@web2 ~]# setenforce 0

步骤二：配置后端Web服务器
1）自定义Web页面
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# echo "192.168.4.100" > /var/www/html/index.html
[root@web2 ~]# yum -y install httpd
[root@web2 ~]# echo "192.168.4.200" > /var/www/html/index.html

2）启动Web服务器软件
[root@web1 ~]# systemctl restart httpd
[root@web2 ~]# systemctl restart httpd

步骤三：proxy调度器安装软件并部署LVS-DR模式调度器
1）安装软件（如果已经安装，此步骤可以忽略）
[root@proxy ~]# yum -y install ipvsadm

2）清理之前实验的规则，创建新的集群服务器规则
[root@proxy ~]# ipvsadm -C     #清空所有规则
[root@proxy ~]# ipvsadm -A -t 192.168.4.15:80 -s wrr

3）添加真实服务器(-g参数设置LVS工作模式为DR模式，-w设置权重)
[root@proxy ~]# ipvsadm -a -t 192.168.4.15:80 -r 192.168.4.100 -g -w 1
[root@proxy ~]# ipvsadm -a -t 192.168.4.15:80 -r 192.168.4.200 -g -w 1

4）查看规则列表，并保存规则
[root@proxy ~]# ipvsadm -Ln
TCP  192.168.4.15:80 wrr
  -> 192.168.4.100:80             Route   1      0          0         
  -> 192.168.4.200:80             Route   2      0          0
[root@proxy ~]# ipvsadm-save -n > /etc/sysconfig/ipvsadm

步骤四：客户端测试
客户端使用curl命令反复连接http://192.168.4.15，查看访问的页面是否会轮询到不同的后端真实服务器。
扩展知识：默认LVS不带健康检查功能，需要自己手动编写动态检测脚本，实现该功能：(参考脚本如下，仅供参考)
[root@proxy ~]# vim check.sh
#!/bin/bash
VIP=192.168.4.15:80
RIP1=192.168.4.100
RIP2=192.168.4.200
while :
do
   for IP in $RIP1 $RIP2
   do
           curl -s http://$IP &>/dev/vnull
if [ $? -eq 0 ];then
            ipvsadm -Ln |grep -q $IP || ipvsadm -a -t $VIP -r $IP
        else
             ipvsadm -Ln |grep -q $IP && ipvsadm -d -t $VIP -r $IP
        fi
   done
sleep 1
done

cluster_day02============================================================================================

Keepalived高可用服务器

1.1 问题
  准备三台Linux服务器，两台做Web服务器，并部署Keepalived高可用软件，一台作为客户端主机，实现如下功能：
      使用Keepalived实现web服务器的高可用
     Web服务器IP地址分别为192.168.4.100和192.168.4.200
     Web服务器的浮动VIP地址为192.168.4.80
      客户端通过访问VIP地址访问Web页面

1.2 方案
使用3台虚拟机，2台作为Web服务器，并部署Keepalived、1台作为客户端，拓扑结构

1.3 步骤
实现此案例需要按照如下步骤进行。
步骤一：配置网络环境（如果在前面课程已经完成该配置，可以忽略此步骤）
1）设置Web1服务器网络参数、配置Web服务
[root@web1 ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth0
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# echo "192.168.4.100" > /var/www/html/index.html
[root@web1 ~]# systemctl restart httpd

2）设置Web2服务器网络参数、配置Web服务
[root@web2 ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.200/24 connection.autoconnect yes
[root@web2 ~]# nmcli connection up eth0
[root@web2 ~]# yum -y install httpd
[root@web2 ~]# echo "192.168.4.200" > /var/www/html/index.html
[root@web2 ~]# systemctl restart httpd

3）配置proxy主机的网络参数（如果已经设置，可以忽略此步骤）
[root@proxy ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.5/24 connection.autoconnect yes
[root@proxy ~]# nmcli connection up eth0

步骤二：安装Keepalived软件

注意：两台Web服务器做相同的操作。
[root@web1 ~]# yum install -y keepalived
[root@web2 ~]# yum install -y keepalived 

步骤三：部署Keepalived服务
1）修改web1服务器Keepalived配置文件
[root@web1 ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  notification_email {
    admin@tarena.com.cn                #设置报警收件人邮箱
  }
  notification_email_from ka@localhost #设置发件人
  smtp_server 127.0.0.1                #定义邮件服务器
  smtp_connect_timeout 30
  router_id  web1                      #设置路由ID号（实验需要修改）
}
vrrp_instance VI_1 {
  state MASTER                         #主服务器为MASTER（备服务器需要修改为BACKUP）
  interface eth0                       #定义网络接口
  virtual_router_id 51                 #主备服务器VRID号必须一致
  priority 100                         #服务器优先级,优先级高优先获取VIP（实验需要修改）
  advert_int 1
  authentication {
    auth_type pass
    auth_pass 1111                     #主备服务器密码必须一致
  }
  virtual_ipaddress {                  #谁是主服务器谁获得该VIP（实验需要修改）
       192.168.4.80 
   }    
}

2）修改web2服务器Keepalived配置文件
[root@web1 ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  notification_email {
    admin@tarena.com.cn                #设置报警收件人邮箱
  }
  notification_email_from ka@localhost #设置发件人
  smtp_server 127.0.0.1                #定义邮件服务器
  smtp_connect_timeout 30
  router_id  web2                     #设置路由ID号（实验需要修改）
}
vrrp_instance VI_1 {
  state BACKUP                        #主服务器为MASTER（备服务器需要修改为BACKUP）
  interface eth0                      #定义网络接口
  virtual_router_id 51                #主备服务器VRID号必须一致
  priority 100                        #服务器优先级,优先级高优先获取VIP（实验需要修改）
  advert_int 1
  authentication {
    auth_type pass
    auth_pass 1111                    #主备服务器密码必须一致
  }
  virtual_ipaddress {                 #谁是主服务器谁获得该VIP（实验需要修改）
     192.168.4.80 
  }    
}

3）启动服务
[root@web1 ~]# systemctl start keepalived
[root@web2 ~]# systemctl start keepalived

4）配置防火墙和SELinux
启动keepalived会自动添加一个drop的防火墙规则，需要清空！
[root@web1 ~]# iptables -F
[root@web1 ~]# setenforce 0
[root@web2 ~]# iptables -F
[root@web1 ~]# setenforce 0

步骤四：测试
1）登录两台Web服务器查看VIP信息
[root@web1 ~]# ip addr show
[root@web2 ~]# ip addr show

2) 客户端访问
客户端使用curl命令连接http://192.168.4.80，查看Web页面；关闭Web1服务器的网卡，客户端再次访问http://192.168.4.80，验证是否可以正常访问服务。

==============================================================================
Keepalived+LVS服务器

2.1 问题
  使用Keepalived为LVS调度器提供高可用功能，防止调度器单点故障，为用户提供Web服务：
   LVS1调度器真实IP地址为192.168.4.5
   LVS2调度器真实IP地址为192.168.4.6
    服务器VIP地址设置为192.168.4.15
    真实Web服务器地址分别为192.168.4.100、192.168.4.200
    使用加权轮询调度算法，真实web服务器权重不同

2.2 方案
   使用5台虚拟机，1台作为客户端主机、2台作为LVS调度器、2台作为Real Server，实验拓扑环境结构

注意：所有主机都需要配置IP地址与有效的YUM源。

2.3 步骤
实现此案例需要按照如下步骤进行。
步骤一：配置网络环境
1）设置Web1服务器的网络参数
[root@web1 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth0

接下来给web1配置VIP地址
注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。
[root@web1 ~]# cd /etc/sysconfig/network-scripts/
[root@web1 ~]# cp ifcfg-lo{,:0}
[root@web1 ~]# vim ifcfg-lo:0
DEVICE=lo:0
IPADDR=192.168.4.15
NETMASK=255.255.255.255
NETWORK=192.168.4.15
BROADCAST=192.168.4.15
ONBOOT=yes
NAME=lo:0

注意：这里因为web1也配置与调度器一样的VIP地址，默认肯定会出现地址冲突。
写入这四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应。
[root@web1 ~]# vim /etc/sysctl.conf
#手动写入如下4行内容
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
net.ipv4.conf.all.arp_announce = 2
#当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应
#本机不要向外宣告自己的lo回环地址是192.168.4.15

重启网络服务，设置防火墙与SELinux
[root@web1 ~]# systemctl restart network
[root@web1 ~]# ifconfig
[root@web1 ~]# systemctl stop firewalld
[root@web1 ~]# setenforce 0

2）设置Web2服务器的网络参数
[root@web2 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.200/24 connection.autoconnect yes
[root@web2 ~]# nmcli connection up eth0

接下来给web2配置VIP地址
注意：这里的子网掩码必须是32（也就是全255），网络地址与IP地址一样，广播地址与IP地址也一样。
[root@web2 ~]# cd /etc/sysconfig/network-scripts/
[root@web2 ~]# cp ifcfg-lo{,:0}
[root@web2 ~]# vim ifcfg-lo:0
DEVICE=lo:0
IPADDR=192.168.4.15
NETMASK=255.255.255.255
NETWORK=192.168.4.15
BROADCAST=192.168.4.15
ONBOOT=yes
NAME=lo:0

注意：这里因为web2也配置与代理一样的VIP地址，默认肯定会出现地址冲突。
写入这四行的主要目的就是访问192.168.4.15的数据包，只有调度器会响应，其他主机都不做任何响应。
[root@web2 ~]# vim /etc/sysctl.conf
#手动写入如下4行内容
net.ipv4.conf.all.arp_ignore = 1
net.ipv4.conf.lo.arp_ignore = 1
net.ipv4.conf.lo.arp_announce = 2
net.ipv4.conf.all.arp_announce = 2
#当有arp广播问谁是192.168.4.15时，本机忽略该ARP广播，不做任何回应
#本机不要向外宣告自己的lo回环地址是192.168.4.15

重启网络服务，设置防火墙与SELinux
[root@web2 ~]# systemctl restart network
[root@web2 ~]# ifconfig
[root@web2 ~]# systemctl stop firewalld
[root@web2 ~]# setenforce 0

3）配置proxy1主机的网络参数(不配置VIP，由keepalvied自动配置)
[root@proxy1 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.5/24 connection.autoconnect yes
[root@proxy1 ~]# nmcli connection up eth0

4）配置proxy2主机的网络参数(不配置VIP，由keepalvied自动配置)
注意：按照前面的课程环境，默认没有该虚拟机，需要重新建一台虚拟机proxy2。
[root@proxy2 ~]# nmcli connection modify eth0 ipv4.method manual \
ipv4.addresses 192.168.4.6/24 connection.autoconnect yes
[root@proxy2 ~]# nmcli connection up eth0

步骤二：配置后台web服务
1）安装软件，自定义Web页面（web1和web2主机）
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# echo "192.168.4.100" > /var/www/html/index.html
[root@web2 ~]# yum -y install httpd
[root@web2 ~]# echo "192.168.4.200" > /var/www/html/index.html

3）启动Web服务器软件(web1和web2主机)
[root@web1 ~]# systemctl start httpd ; systemctl enable httpd
[root@web2 ~]# systemctl start httpd ; systemctl enable httpd

步骤三：调度器安装Keepalived与ipvsadm软件
注意：两台LVS调度器执行相同的操作（如何已经安装软件，可用忽略此步骤）。
安装软件
[root@proxy1 ~]# yum install -y keepalived
[root@proxy1 ~]# systemctl enable keepalived
[root@proxy1 ~]# yum install -y ipvsadm
[root@proxy1 ~]# ipvsadm -C
[root@proxy2 ~]# yum install -y keepalived
[root@proxy2 ~]# systemctl enable keepalived
[root@proxy2 ~]# yum install -y ipvsadm
[root@proxy2 ~]# ipvsadm -C

步骤四：部署Keepalived实现LVS-DR模式调度器的高可用
1）LVS1调度器设置Keepalived，并启动服务
[root@proxy1 ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  notification_email {
    admin@tarena.com.cn                #设置报警收件人邮箱
  }
  notification_email_from ka@localhost #设置发件人
  smtp_server 127.0.0.1    #定义邮件服务器
  smtp_connect_timeout 30
  router_id  lvs1       #设置路由ID号(实验需要修改)
}
vrrp_instance VI_1 {
  state MASTER          #主服务器为MASTER
  interface eth0        #定义网络接口
  virtual_router_id 50  #主辅VRID号必须一致
  priority 100        #服务器优先级
  advert_int 1
  authentication {
    auth_type pass
    auth_pass 1111    #主辅服务器密码必须一致
  }
  virtual_ipaddress { #配置VIP（实验需要修改）
192.168.4.15 
 }   
}
virtual_server 192.168.4.15 80 { #设置ipvsadm的VIP规则（实验需要修改）
  delay_loop 6
  lb_algo wrr                    #设置LVS调度算法为WRR
  lb_kind DR                     #设置LVS的模式为DR
  #persistence_timeout 50
#注意这样的作用是保持连接，开启后，客户端在一定时间内始终访问相同服务器
  protocol TCP
  real_server 192.168.4.100 80 {         #设置后端web服务器真实IP（实验需要修改）
    weight 1                             #设置权重为1
    TCP_CHECK {                          #对后台real_server做健康检查
    connect_timeout 3
    nb_get_retry 3
    delay_before_retry 3
    }
  }
 real_server 192.168.4.200 80 { #设置后端web服务器真实IP（实验需要修改）
    weight 2                    #设置权重为2
    TCP_CHECK {
    connect_timeout 3
    nb_get_retry 3
    delay_before_retry 3
    }
  }
}
[root@proxy1 ~]# systemctl start keepalived
[root@proxy1 ~]# ipvsadm -Ln    #查看LVS规则
[root@proxy1 ~]# ip a  s        #查看VIP配置

2）LVS2调度器设置Keepalived，并启动服务
[root@proxy1 ~]# vim /etc/keepalived/keepalived.conf
global_defs {
  notification_email {
    admin@tarena.com.cn                #设置报警收件人邮箱
  }
  notification_email_from ka@localhost #设置发件人
  smtp_server 127.0.0.1    #定义邮件服务器
  smtp_connect_timeout 30
  router_id  lvs2       #设置路由ID号(实验需要修改)
}
vrrp_instance VI_1 {
  state MASTER          #主服务器为MASTER
  interface eth0        #定义网络接口
  virtual_router_id 50  #主辅VRID号必须一致
  priority 80            #服务器优先级
  advert_int 1
  authentication {
    auth_type pass
    auth_pass 1111    #主辅服务器密码必须一致
  }
  virtual_ipaddress { #配置VIP（实验需要修改）
192.168.4.15 
 }   
}
virtual_server 192.168.4.15 80 { #设置ipvsadm的VIP规则（实验需要修改）
  delay_loop 6
  lb_algo wrr                    #设置LVS调度算法为WRR
  lb_kind DR                     #设置LVS的模式为DR
  #persistence_timeout 50
#注意这样的作用是保持连接，开启后，客户端在一定时间内始终访问相同服务器
  protocol TCP
  real_server 192.168.4.100 80 { #设置后端web服务器真实IP（实验需要修改）
    weight 1                     #设置权重为1
    TCP_CHECK {                  #对后台real_server做健康检查
    connect_timeout 3
    nb_get_retry 3
    delay_before_retry 3
    }
  }
 real_server 192.168.4.200 80 { #设置后端web服务器真实IP（实验需要修改）
    weight 2                    #设置权重为2
    TCP_CHECK {
    connect_timeout 3
    nb_get_retry 3
    delay_before_retry 3
    }
  }
}
[root@proxy2 ~]# systemctl start keepalived
[root@proxy2 ~]# ipvsadm -Ln  #查看LVS规则
[root@proxy2 ~]# ip a  s      #查看VIP配置

====================================================================================
配置HAProxy负载平衡集群

3.1 问题
  准备4台Linux服务器，两台做Web服务器，1台安装HAProxy，1台做客户端，实现如下功能：
    客户端访问HAProxy，HAProxy分发请求到后端Real Server
    开启HAProxy监控页面，及时查看调度器状态
    设置HAProxy为开机启动

3.2 方案
使用4台虚拟机，1台作为HAProxy调度器、2台作为Real Server、1台作为客户端，拓扑结构

3.3 步骤
实现此案例需要按照如下步骤进行。
注意事项：
将前面实验VIP、LVS等实验的内容清理干净！！！！！！
删除所有设备的VIP，清空所有LVS设置，关闭keepalived！！！
web1关闭多余的网卡与VIP，配置本地真实IP地址。
[root@web1 ~]# ifdown eth0
[root@web1 ~]# ifdown lo:0
[root@web1 ~]# nmcli connection modify eth1 ipv4.method manual ipv4.addresses 192.168.2.100/24 connection.autoconnect yes
[root@web1 ~]# nmcli connection up eth1

Web2关闭多余的网卡与VIP，配置本地真实IP地址。
[root@web2 ~]# ifdown eth0
[root@web2 ~]# ifdown lo:0
[root@web2 ~]# nmcli connection modify eth1 ipv4.method manual ipv4.addresses 192.168.2.200/24 connection.autoconnect yes
[root@web2 ~]# nmcli connection up eth1

proxy关闭keepalived服务，清理LVS规则。
[root@proxy ~]# systemctl stop keepalived
[root@proxy ~]# systemctl disable keepalived
[root@proxy ~]# ipvsadm -C
[root@proxy ~]# nmcli connection modify eth0 ipv4.method manual ipv4.addresses 192.168.4.5/24 connection.autoconnect yes
[root@proxy ~]# nmcli connection up eth0
[root@proxy ~]# nmcli connection modify eth1 ipv4.method manual ipv4.addresses 192.168.2.5/24 connection.autoconnect yes
[root@proxy ~]# nmcli connection up eth1

步骤一：配置后端Web服务器
设置两台后端Web服务（如果已经配置完成，可用忽略此步骤）
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# systemctl start httpd
[root@web1 ~]# echo "192.168.2.100" > /var/www/html/index.html
[root@web2 ~]# yum -y install httpd
[root@web2 ~]# systemctl start httpd
[root@web2 ~]# echo "192.168.2.200" > /var/www/html/index.html

步骤二：部署HAProxy服务器
1）配置网络，安装软件
[root@haproxy ~]# yum -y install haproxy

2）修改配置文件
[root@haproxy ~]# vim /etc/haproxy/haproxy.cfg
global
 log 127.0.0.1 local2   ###[err warning info debug]
 chroot /usr/local/haproxy
 pidfile /var/run/haproxy.pid ###haproxy的pid存放路径
 maxconn 4000     ###最大连接数，默认4000
 user haproxy
 group haproxy
 daemon       ###创建1个进程进入deamon模式运行
defaults
 mode http    ###默认的模式mode { tcp|http|health } log global   ###采用全局定义的日志
 option dontlognull  ###不记录健康检查的日志信息
 option httpclose  ###每次请求完毕后主动关闭http通道
 option httplog   ###日志类别http日志格式
 option forwardfor  ###后端服务器可以从Http Header中获得客户端ip
 option redispatch  ###serverid服务器挂掉后强制定向到其他健康服务器
 timeout connect 10000 #如果backend没有指定，默认为10s
 timeout client 300000 ###客户端连接超时
 timeout server 300000 ###服务器连接超时
 maxconn  60000  ###最大连接数
 retries  3   ###3次连接失败就认为服务不可用，也可以通过后面设置
listen stats 0.0.0.0:1080   #监听端口
    stats refresh 30s   #统计页面自动刷新时间
    stats uri /stats   #统计页面url
    stats realm Haproxy Manager #进入管理解面查看状态信息
    stats auth admin:admin  #统计页面用户名和密码设置
  #stats hide-version   #隐藏统计页面上HAProxy的版本信息
listen  websrv-rewrite 0.0.0.0:80
   balance roundrobin
   server  web1 192.168.2.100:80 check inter 2000 rise 2 fall 5
   server  web2 192.168.2.200:80 check inter 2000 rise 2 fall 5

3）启动服务器并设置开机启动
[root@haproxy ~]# systemctl start haproxy
[root@haproxy ~]# systemctl enable haproxy

步骤三：客户端验证
客户端配置与HAProxy相同网络的IP地址，并使用火狐浏览器访问http://192.168.4.5，测试调度器是否正常工作，客户端访问http://192.168.4.5:1080/stats测试状态监控页面是否正常

备注：
Queue队列数据的信息（当前队列数量，最大值，队列限制数量）；
Session rate每秒会话率（当前值，最大值，限制数量）；
Sessions总会话量（当前值，最大值，总量，Lbtot: total number of times a server was selected选中一台服务器所用的总时间）；
Bytes（入站、出站流量）；
Denied（拒绝请求、拒绝回应）；
Errors（错误请求、错误连接、错误回应）；
Warnings（重新尝试警告retry、重新连接redispatches）；
Server(状态、最后检查的时间（多久前执行的最后一次检查）、权重、备份服务器数量、down机服务器数量、down机时长)。

cluster_day03============================================================================================

实验环境

1.1 问题

准备四台KVM虚拟机，其三台作为存储集群节点，一台安装为客户端，实现如下功能：
    创建1台客户端虚拟机
    创建3台存储集群虚拟机
    配置主机名、IP地址、YUM源
    修改所有主机的主机名
    配置无密码SSH连接
    配置NTP时间同步
    创建虚拟机磁盘

1.2 方案
使用4台虚拟机，1台客户端、3台存储集群服务器

1.3 步骤
实现此案例需要按照如下步骤进行。
步骤一：安装前准备
1）物理机为所有节点配置yum源服务器。
提示：ceph10.iso在/linux-soft/02目录。
[root@room9pc01 ~]# mkdir  /var/ftp/ceph
[root@room9pc01 ~]# mount ceph10.iso /var/ftp/ceph/

2）配置无密码连接(包括自己远程自己也不需要密码)，在node1操作。
[root@node1 ~]# ssh-keygen   -f /root/.ssh/id_rsa    -N ''
[root@node1 ~]# for i in 10  11  12  13
do
      ssh-copy-id  192.168.4.$i
done

3）修改/etc/hosts并同步到所有主机。
警告：/etc/hosts解析的域名必须与本机主机名一致！！！！
 [root@node1 ~]# cat /etc/hosts
... ...
192.168.4.10   client
192.168.4.11   node1
192.168.4.12   node2
192.168.4.13   node3

警告：/etc/hosts解析的域名必须与本机主机名一致！！！！
[root@node1 ~]# for i in 10  11  12  13
do
scp  /etc/hosts  192.168.4.$i:/etc/
done

4）修改所有节点都需要配置YUM源，并同步到所有主机。
[root@node1 ~]# cat /etc/yum.repos.d/ceph.repo
[mon]
name=mon
baseurl=ftp://192.168.4.254/ceph/MON
gpgcheck=0
[osd]
name=osd
baseurl=ftp://192.168.4.254/ceph/OSD
gpgcheck=0
[tools]
name=tools
baseurl=ftp://192.168.4.254/ceph/Tools
gpgcheck=0
[root@node1 ~]# yum repolist   #验证YUM源软件数量
源标识            源名称                    状态
Dvd                redhat                    9,911
Mon                mon                        41
Osd                osd                        28
Tools            tools                    33
repolist: 10,013
[root@node1 ~]# for i in  10  11  12  13
do
scp  /etc/yum.repos.d/ceph.repo  192.168.4.$i:/etc/yum.repos.d/
done

5）所有节点主机与真实主机的NTP服务器同步时间。
提示：默认真实物理机已经配置为NTP服务器。
[root@node1 ~]# vim /etc/chrony.conf
… …
server 192.168.4.254   iburst
[root@node1 ~]# for i in 10 11 12 13
do
      scp /etc/chrony.conf 192.168.4.$i:/etc/
      ssh 192.168.4.$i "systemctl restart chronyd"
done

步骤三：准备存储磁盘
物理机上为每个虚拟机准备3块磁盘（可以使用命令，也可以使用图形直接添加）。
 [root@room9pc01 ~]# virt-manager

===============================================================
部署ceph集群

2.1 问题
沿用练习一，部署Ceph集群服务器，实现以下目标：
   安装部署工具ceph-deploy
   创建ceph集群
   准备日志磁盘分区
   创建OSD存储空间
   查看ceph状态，验证

2.2 步骤
实现此案例需要按照如下步骤进行。
步骤一：安装部署软件ceph-deploy
1）在node1安装部署工具，学习工具的语法格式。
[root@node1 ~]#  yum -y install ceph-deploy
[root@node1 ~]#  ceph-deploy  --help
[root@node1 ~]#  ceph-deploy mon --help

2）创建目录
[root@node1 ~]#  mkdir ceph-cluster
[root@node1 ~]#  cd ceph-cluster/

步骤二：部署Ceph集群
1）创建Ceph集群配置,在ceph-cluster目录下生成Ceph配置文件。
在ceph.conf配置文件中定义monitor主机是谁。
[root@node1 ceph-cluster]# ceph-deploy new node1 node2 node3

2）给所有节点安装ceph相关软件包。
[root@node1 ceph-cluster]# for i in node1 node2 node3
do
    ssh  $i "yum -y install ceph-mon ceph-osd ceph-mds ceph-radosgw"
done 

3）初始化所有节点的mon服务，也就是启动mon服务（主机名解析必须对）。
[root@node1 ceph-cluster]# ceph-deploy mon create-initial

常见错误及解决方法（非必要操作，有错误可以参考）：
如果提示如下错误信息：
[node1][ERROR ] admin_socket: exception getting command descriptions: [Error 2] No such file or directory

解决方案如下（在node1操作）：
先检查自己的命令是否是在ceph-cluster目录下执行的！！！！如果确认是在该目录下执行的create-initial命令，依然报错，可以使用如下方式修复。
[root@node1 ceph-cluster]# vim ceph.conf   #文件最后追加以下内容
public_network = 192.168.4.0/24

修改后重新推送配置文件:
[root@node1 ceph-cluster]# ceph-deploy --overwrite-conf config push node1 node2 node3

步骤三：创建OSD
备注：vdb1和vdb2这两个分区用来做存储服务器的journal缓存盘。
[root@node1 ceph-cluster]# for i in node1 node2 node3
do
     ssh $i "parted /dev/vdb mklabel gpt"
     ssh $i "parted /dev/vdb mkpart primary 1 50%"
     ssh $i "parted /dev/vdb mkpart primary 50% 100%"
 done

2）磁盘分区后的默认权限无法让ceph软件对其进行读写操作，需要修改权限。
node1、node2、node3都需要操作，这里以node1为例。
[root@node1 ceph-cluster]# chown  ceph.ceph  /dev/vdb1
[root@node1 ceph-cluster]# chown  ceph.ceph  /dev/vdb2
#上面的权限修改为临时操作，重启计算机后，权限会再次被重置。
#我们还需要将规则写到配置文件实现永久有效。
#规则：如果设备名称为/dev/vdb1则设备文件的所有者和所属组都设置为ceph。
#规则：如果设备名称为/dev/vdb2则设备文件的所有者和所属组都设置为ceph。
[root@node1 ceph-cluster]# vim /etc/udev/rules.d/70-vdb.rules
ENV{DEVNAME}=="/dev/vdb1",OWNER="ceph",GROUP="ceph"
ENV{DEVNAME}=="/dev/vdb2",OWNER="ceph",GROUP="ceph"

3）初始化清空磁盘数据（仅node1操作即可）。
[root@node1 ceph-cluster]# ceph-deploy disk  zap  node1:vdc   node1:vdd    
[root@node1 ceph-cluster]# ceph-deploy disk  zap  node2:vdc   node2:vdd
[root@node1 ceph-cluster]# ceph-deploy disk  zap  node3:vdc   node3:vdd   

4）创建OSD存储空间（仅node1操作即可）
重要：很多同学在这里会出错！将主机名、设备名称输入错误！！！
[root@node1 ceph-cluster]# ceph-deploy osd create  node1:vdc:/dev/vdb1 node1:vdd:/dev/vdb2  
#创建osd存储设备，vdc为集群提供存储空间，vdb1提供JOURNAL缓存，
#一个存储设备对应一个缓存设备，缓存需要SSD，不需要很大
[root@node1 ceph-cluster]# ceph-deploy osd create node2:vdc:/dev/vdb1 node2:vdd:/dev/vdb2
[root@node1 ceph-cluster]# ceph-deploy osd create  node3:vdc:/dev/vdb1 node3:vdd:/dev/vdb2 

常见错误及解决方法（非必须操作）。
使用osd create创建OSD存储空间时，如提示下面的错误提示：
[ceph_deploy][ERROR ] RuntimeError: bootstrap-osd keyring not found; run 'gatherkeys'
可以使用如下命令修复文件，重新配置ceph的密钥文件：
[root@node1 ceph-cluster]#  ceph-deploy gatherkeys node1 node2 node3 

步骤四：验证测试
1) 查看集群状态。
[root@node1 ~]#  ceph  -s

2）常见错误（非必须操作）。
如果查看状态包含如下信息：
health: HEALTH_WARN
        clock skew detected on  node2, node3…  

clock skew表示时间不同步，解决办法：请先将所有主机的时间都使用NTP时间同步！！！
Ceph要求所有主机时差不能超过0.05s，否则就会提示WARN，如果使用NTP还不能精确同步时间，可以手动修改所有主机的ceph.conf，在[MON]下面添加如下一行：
mon clock drift allowed = 1

如果状态还是失败，可以尝试执行如下命令，重启ceph服务：
[root@node1 ~]#  systemctl restart ceph\*.service ceph\*.target

=================================================================================
创建Ceph块存储

3.1 问题
  沿用练习一，使用Ceph集群的块存储功能，实现以下目标：
    创建块存储镜像
    客户端映射镜像
    创建镜像快照
    使用快照还原数据
    使用快照克隆镜像
    删除快照与镜像

3.2 步骤
实现此案例需要按照如下步骤进行。
步骤一：创建镜像

1）查看存储池。
[root@node1 ~]# ceph osd lspools
0 rbd,

2）创建镜像、查看镜像
[root@node1 ~]# rbd create demo-image --image-feature  layering --size 10G
[root@node1 ~]# rbd create rbd/image --image-feature  layering --size 10G

#这里的demo-image和image为创建的镜像名称，可以为任意字符。
#--image-feature参数指定我们创建的镜像有哪些功能，layering是开启COW功能。
#提示：ceph镜像支持很多功能，但很多是操作系统不支持的，我们只开启layering。

[root@node1 ~]# rbd list
[root@node1 ~]# rbd info demo-image
rbd image 'demo-image':
    size 10240 MB in 2560 objects
    order 22 (4096 kB objects)
    block_name_prefix: rbd_data.d3aa2ae8944a
    format: 2
    features: layering

步骤二：动态调整
1）缩小容量
[root@node1 ~]# rbd resize --size 7G image --allow-shrink
[root@node1 ~]# rbd info image

2）扩容容量
[root@node1 ~]# rbd resize --size 15G image
[root@node1 ~]# rbd info image


步骤三：通过KRBD访问
1）客户端通过KRBD访问
#客户端需要安装ceph-common软件包
#拷贝配置文件（否则不知道集群在哪）
#拷贝连接密钥（否则无连接权限）
[root@client ~]# yum -y  install ceph-common
[root@client ~]# scp 192.168.4.11:/etc/ceph/ceph.conf  /etc/ceph/
[root@client ~]# scp 192.168.4.11:/etc/ceph/ceph.client.admin.keyring \
/etc/ceph/
[root@client ~]# rbd map image
[root@client ~]#  lsblk
[root@client ~]# rbd showmapped
id pool image snap device    
0  rbd  image -    /dev/rbd0

2) 客户端格式化、挂载分区
[root@client ~]# mkfs.xfs /dev/rbd0
[root@client ~]# mount /dev/rbd0 /mnt/
[root@client ~]# echo "test" > /mnt/test.txt

步骤四：创建镜像快照
1) 查看镜像快照（默认所有镜像都没有快照）。
 [root@node1 ~]# rbd snap ls image

2) 给镜像创建快照。
[root@node1 ~]# rbd snap create image --snap image-snap1
#为image镜像创建快照，快照名称为image-snap1
[root@node1 ~]# rbd snap ls image
SNAPID NAME            SIZE 
     4 image-snap1 15360 MB

3) 删除客户端写入的测试文件
[root@client ~]# rm  -rf   /mnt/test.txt
[root@client ~]# umount  /mnt

4) 还原快照
[root@node1 ~]# rbd snap rollback image --snap image-snap1
#客户端重新挂载分区
[root@client ~]# mount /dev/rbd0 /mnt/
[root@client ~]# ls  /mnt

步骤四：创建快照克隆
1）克隆快照
[root@node1 ~]#  rbd snap protect image --snap image-snap1
[root@node1 ~]#  rbd snap rm image --snap image-snap1    //会失败
[root@node1 ~]# rbd clone \
image --snap image-snap1 image-clone --image-feature layering
#使用image的快照image-snap1克隆一个新的名称为image-clone镜像

2) 给镜像创建快照。
[root@node1 ~]# rbd snap create image --snap image-snap1
#为image镜像创建快照，快照名称为image-snap1
[root@node1 ~]# rbd snap ls image
SNAPID NAME            SIZE 
     4 image-snap1 15360 MB

3) 删除客户端写入的测试文件
[root@client ~]# rm  -rf   /mnt/test.txt
[root@client ~]# umount  /mnt

4) 还原快照
[root@node1 ~]# rbd snap rollback image --snap image-snap1
#客户端重新挂载分区
[root@client ~]# mount /dev/rbd0 /mnt/
[root@client ~]# ls  /mnt

步骤四：创建快照克隆
1）克隆快照
[root@node1 ~]#  rbd snap protect image --snap image-snap1
[root@node1 ~]#  rbd snap rm image --snap image-snap1    //会失败
[root@node1 ~]# rbd clone \
image --snap image-snap1 image-clone --image-feature layering
//使用image的快照image-snap1克隆一个新的名称为image-clone镜像

2）查看克隆镜像与父镜像快照的关系
[root@node1 ~]#  rbd info image-clone
rbd image 'image-clone':
    size 15360 MB in 3840 objects
    order 22 (4096 kB objects)
    block_name_prefix: rbd_data.d3f53d1b58ba
    format: 2
    features: layering
    flags: 
    parent: rbd/image@image-snap1
#克隆镜像很多数据都来自于快照链
#如果希望克隆镜像可以独立工作，就需要将父快照中的数据，全部拷贝一份，但比较耗时！！！
[root@node1 ~]#  rbd flatten image-clone
[root@node1 ~]#  rbd info image-clone
rbd image 'image-clone':
    size 15360 MB in 3840 objects
    order 22 (4096 kB objects)
    block_name_prefix: rbd_data.d3f53d1b58ba
    format: 2
    features: layering
    flags: 
#注意，父快照信息没了！
[root@node1 ~]#  rbd snap unprotect image --snap image-snap1  #取消快照保护
[root@node1 ~]#  rbd snap rm image --snap image-snap1         #可以删除快照

步骤四：其他操作
1） 客户端撤销磁盘映射
[root@client ~]# umount /mnt
[root@client ~]# rbd showmapped
id pool image        snap device    
0  rbd  image        -    /dev/rbd0
#语法格式:
[root@client ~]# rbd unmap /dev/rbd0

cluster_day04============================================================================================

块存储应用案例
1.1 问题

  延续Day03的实验内容，演示块存储在KVM虚拟化中的应用案例，实现以下功能：
    Ceph创建块存储镜像
    客户端安装部署ceph软件
    客户端部署虚拟机
    客户端创建secret
    设置虚拟机配置文件，调用ceph存储

1.2 方案
使用Ceph存储创建镜像。
KVM虚拟机调用Ceph镜像作为虚拟机的磁盘。

1.3 步骤
实现此案例需要按照如下步骤进行。
1）创建磁盘镜像。

[root@node1 ~]# rbd create vm1-image --image-feature  layering --size 10G
[root@node1 ~]# rbd  list
[root@node1 ~]# rbd  info  vm1-image
[root@node1 ~]# qemu-img  info  rbd:rbd/vm1-image
image: rbd:rbd/vm1-image
file format: raw
virtual size: 10G (10737418240 bytes)
disk size: unavailable

2）Ceph认证账户（仅查看即可）。
Ceph默认开启用户认证，客户端需要账户才可以访问，默认账户名称为client.admin，key是账户的密钥。
可以使用ceph auth添加新账户（案例我们使用默认账户）。
[root@node1 ~]# cat /etc/ceph/ceph.conf #配置文件 
[global]
mon_initial_members = node1, node2, node3
mon_host = 192.168.2.10,192.168.2.20,192.168.2.30
auth_cluster_required = cephx                            #开启认证
auth_service_required = cephx                            #开启认证
auth_client_required = cephx                             #开启认证
[root@node1 ~]# cat /etc/ceph/ceph.client.admin.keyring  #账户文件
[client.admin]
    key = AQBTsdRapUxBKRAANXtteNUyoEmQHveb75bISg==

3)创建KVM虚拟机（注意：这里使用真实机当客户端！！！）。
使用virt-manager创建2台普通的KVM虚拟机。

4）配置libvirt secret（注意：这里使用真实机当客户端！！！）。
编写账户信息文件，让KVM知道ceph的账户名称。
[root@room9pc01 ~]# vim secret.xml  #新建临时文件，内容如下 
<secret ephemeral='no' private='no'>
        <usage type='ceph'>
               <name>client.admin secret</name>
        </usage>
</secret>
#使用XML配置文件创建secret
[root@room9pc01 ~]# virsh secret-define secret.xml
733f0fd1-e3d6-4c25-a69f-6681fc19802b       
#随机的UUID，这个UUID对应的有账户信息

5)给secret绑定admin账户的密码，密码参考ceph.client.admin.keyring文件。
[root@room9pc01] virsh secret-set-value --secret 733f0fd1-e3d6-4c25-a69f-6681fc19802b --base64 AQBTsdRapUxBKRAANXtteNUyoEmQHveb75bISg
#这里secret后面是之前创建的secret的UUID
#base64后面是client.admin账户的密码
#现在secret中既有账户信息又有密钥信息

6）虚拟机的XML配置文件。
每个虚拟机都会有一个XML配置文件，包括：
虚拟机的名称、内存、CPU、磁盘、网卡等信息。
[root@room9pc01 ~]# vim /etc/libvirt/qemu/vm1.xml
//修改前内容如下
<disk type='file' device='disk'>
      <driver name='qemu' type='qcow2'/>
      <source file='/var/lib/libvirt/images/vm1.qcow2'/>
      <target dev='vda' bus='virtio'/>
      <address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x0'/>
    </disk>

不推荐直接使用vim修改配置文件，推荐使用virsh edit修改配置文件，效果如下：
[root@room9pc01] virsh edit vm1                //vm1为虚拟机名称
<disk type='network' device='disk'>
      <driver name='qemu' type='raw'/>
      <auth username='admin'> 
      <secret type='ceph' uuid='733f0fd1-e3d6-4c25-a69f-6681fc19802b'/>
      </auth>
      <source protocol='rbd' name='rbd/vm1-image'>          <host name='192.168.4.11' port='6789'/>    </source>
    <target dev='vda' bus='virtio'/>
      <address type='pci' domain='0x0000' bus='0x09' slot='0x08' function='0x0'/>
 </disk>
注意：如果有设备编号冲突的情况下，需要修改设备编号，任意修改一个数字即可。

===================================================================================================
Ceph文件系统

2.1 问题

  延续前面的实验，实现Ceph文件系统的功能。具体实现有以下功能：
    部署MDSs节点
    创建Ceph文件系统
    客户端挂载文件系统


2.2 方案
添加一台虚拟机，部署MDS节点。

2.3 步骤
实现此案例需要按照如下步骤进行。
1）添加一台新的虚拟机，要求如下：
IP地址:192.168.4.14
主机名:node4
配置yum源（包括rhel、ceph的源）
与Client主机同步时间
node1允许无密码远程node4

2）部署元数据服务器
登陆node4，安装ceph-mds软件包
[root@node4 ~]# yum -y install ceph-mds 

登陆node1部署节点操作
[root@node1 ~]# cd  /root/ceph-cluster
#该目录，是最早部署ceph集群时，创建的目录
[root@node1 ceph-cluster]# ceph-deploy mds create node4
#给nod4拷贝配置文件，启动mds服务

同步配置文件和key
[root@node1 ceph-cluster]# ceph-deploy admin node4

3）创建存储池
[root@node4 ~]# ceph osd pool create cephfs_data 128
#创建存储池，对应128个PG
[root@node4 ~]# ceph osd pool create cephfs_metadata 128
#创建存储池，对应128个PG

5）创建Ceph文件系统
[root@node4 ~]# ceph mds stat  #查看mds状态
e2:, 1 up:standby
[root@node4 ~]# ceph fs new myfs1 cephfs_metadata cephfs_data
new fs with metadata pool 2 and data pool 1
#注意，先写medadata池，再写data池
#默认，只能创建1个文件系统，多余的会报错
[root@node4 ~]# ceph fs ls
name: myfs1, metadata pool: cephfs_metadata, data pools: [cephfs_data ]
[root@node4 ~]# ceph mds stat
e4: 1/1/1 up {0=node4=up:creating}

6）客户端挂载
[root@client ~]# mount -t ceph 192.168.4.11:6789:/  /mnt/cephfs/ -o name=admin,secret=AQBTsdRapUxBKRAANXtteNUyoEmQHveb75bISg==
#注意:文件系统类型为ceph
#192.168.4.11为MON节点的IP（不是MDS节点）
#admin是用户名,secret是密钥
#密钥可以在/etc/ceph/ceph.client.admin.keyring中找到

=====================================================================================================
创建对象存储服务器

3.1 问题
  延续前面的实验，实现Ceph对象存储的功能。具体实现有以下功能：
    安装部署Rados Gateway
    启动RGW服务
    设置RGW的前端服务与端口
    客户端测试

3.2 步骤

步骤一：部署对象存储服务器
1）准备实验环境，要求如下：
IP地址:192.168.4.15
主机名:node5
配置yum源（包括rhel、ceph的源）
与Client主机同步时间
node1允许无密码远程node5
修改node1的/etc/hosts，并同步到所有node主机

2）部署RGW软件包
[root@node1 ~]# ceph-deploy install --rgw node5
同步配置文件与密钥到node5
[root@node1 ~]# cd /root/ceph-cluster
[root@node1 ~]# ceph-deploy admin node5

3）新建网关实例
启动一个rgw服务
[root@node1 ~]# ceph-deploy rgw create node5

登陆node5验证服务是否启动
[root@node5 ~]# ps aux |grep radosgw
ceph      4109  0.2  1.4 2289196 14972 ?       Ssl  22:53   0:00 /usr/bin/radosgw -f --cluster ceph --name client.rgw.node4 --setuser ceph --setgroup ceph
[root@node5 ~]# systemctl  status ceph-radosgw@\*

4）修改服务端口
登陆node5，RGW默认服务端口为7480，修改为8000或80更方便客户端记忆和使用
[root@node5 ~]#  vim  /etc/ceph/ceph.conf
[client.rgw.node5]
host = node5
rgw_frontends = "civetweb port=8000"
#node5为主机名
#civetweb是RGW内置的一个web服务

步骤二：客户端测试（扩展选做实验）
1）curl测试
[root@client ~]# curl  192.168.4.15:8000
<?xml version="1.0" encoding="UTF-8"?><ListAllMyBucketsResult xmlns="http://s3.amazonaws.com/doc/2006-03-01/"><Owner><ID>anonymous</ID><DisplayName></DisplayName></Owner><Buckets></Buckets></ListAllMyBucketsResult>

2）使用第三方软件访问
登陆node5（RGW）创建账户
[root@node5 ~]#  radosgw-admin user create \
--uid="testuser" --display-name="First User"
… …
"keys": [
        {
            "user": "testuser",
            "access_key": "5E42OEGB1M95Y49IBG7B",
            "secret_key": "i8YtM8cs7QDCK3rTRopb0TTPBFJVXdEryRbeLGK6"
        }
    ],
... ...
#
[root@node5 ~]# radosgw-admin user info --uid=testuser
#testuser为用户，key是账户访问密钥

3）客户端安装软件
[root@client ~]#  yum install s3cmd-2.0.1-1.el7.noarch.rpm
修改软件配置（注意，除了下面设置的内容，其他提示都默认回车）
[root@client ~]#  s3cmd --configure
Access Key: 5E42OEGB1M95Y49IBG7BSecret Key: i8YtM8cs7QDCK3rTRopb0TTPBFJVXdEryRbeLGK6
S3 Endpoint [s3.amazonaws.com]: 192.168.4.15:8000
[%(bucket)s.s3.amazonaws.com]: %(bucket)s.192.168.4.15:8000
Use HTTPS protocol [Yes]: No
Test access with supplied credentials? [Y/n] n
Save settings? [y/N] y
#注意，其他提示都默认回车

4）创建存储数据的bucket（类似于存储数据的目录）
[root@client ~]# s3cmd ls
[root@client ~]# s3cmd mb s3://my_bucket
Bucket 's3://my_bucket/' created
[root@client ~]# s3cmd ls
2018-05-09 08:14 s3://my_bucket
[root@client ~]# s3cmd put /var/log/messages s3://my_bucket/log/
[root@client ~]# s3cmd ls
2018-05-09 08:14 s3://my_bucket
[root@client ~]# s3cmd ls s3://my_bucket
DIR s3://my_bucket/log/
[root@client ~]# s3cmd ls s3://my_bucket/log/
2018-05-09 08:19 309034 s3://my_bucket/log/messages 

测试下载功能
[root@client ~]# s3cmd get s3://my_bucket/log/messages /tmp/

测试删除功能
[root@client ~]# s3cmd del s3://my_bucket/log/messages


8.project1==================================================================================================



project1_day01==============================================================================================


project1_day02==============================================================================================


project1_day03==============================================================================================


project1_day04==============================================================================================

9.rdbms1====================================================================================================

rdbms1_day01================================================================================================

搭建数据库服	

1.数据包括那些？
 图片 视频  音频  文字 数字

专业术语
DB(Data Base)
  数据库
  依照某种数据模型进行组织并存放到存储器的数据集合
DBMS(Data Base Management System
  数据库管理系统
  用来操纵和管理数据库的服务软件
DBS(Data Base System）
  数据库系统：即DB+DBMS
  指带有数据库并整合了数据库管理软件的计算机系统

2.什么是数据呢？
存储数据的仓库

3.为什么要架设数据库服务器呢？
网站： 购物  游戏  论坛
数据库里  LNMP  LAMP  PHP

===========================================================================
MySql介绍

起源与发展
 应用最广泛的开源数据库软件
   最早隶属于瑞典的 MySQL AB公司
   2008年1月， MySQL AB被Sun收购
   20Q9年4月，SUN被 Oracle收购
  崭新的开源分支 MariaDB
   为应付 MySQL可能会闭源的风险而诞生
   由 MySQL，原作者 Widenius主导开发
   与MySQ保持最大程度兼容

特点及应用
 主要特点
   适用于中小规模、关系型数据库系统 
   支持 Linux、Uniⅸx、 Windows等多种操作系统
   支持 Python、Java、Perl、PHP等编程语言
典型应用环境
  LAMP平台，与 Apache Http Server组合
  LNMP平台，与Ngnx组合

数据库服务软件有那些？
Oracle    SQL SERVER  MySQL  DB2    memcached  Redis MogoDB  
	RDBMS				     NoSQL

软件包从那来？ 
官网  系统安装光盘rhel7.4  2015
开源软件 商业软件 跨平台 LINUX unix  windows
 
使用那种软件搭建数据库服务器好呢？ 
mysql php python java 

==================================================================
构建MySql服务器

MySql安装

环境准备
基本需求
  1.创建 Centos系统虚拟机1台
  2.配置IP地址192.168.4.50
  3.关闭 firewall
  4.禁用 SELinux
  5.拷贝软件mysq-57.17tar
  6.配置yum源

数据库服务器
192.168.4.50  mysql-5.7.17.tar
     yum源 禁用 selinux  和 firewalld

1. 安装软件
1).从官网下载RPM包
http://dev.mysql.com/downloads/mysql #下载包路径
mysql-community-client            #客户端应用程序
mysq- community- common           #数据库和客户端库共享文件
mysql-community-devel             #客户端应用程序的库和头文件
mysql-community- embedded         #入式函数库
mysq- community- embedded- compat #嵌入式兼容函数库
mysq- community-embedded-deve     #文件和库文件作为Mysq的嵌入式库文件
mysql-community-ibs               #MySQL数据库客户端应用程序的共享库
mysql-community- ibs-compat       #客户端应用程序的共享兼容库

2).必须安装的软件包server和client
  yum安装,自动解决软件依赖
]# tar -xvf mysql-5.7.17.tar
]# yum -y  install  mysql-community-*.rpm
]# rpm -qa | grep -i mysql
例:
[root@mysql50 ~]# tar -xvf /mysql/mysql-5.7.17.tar     #解压tar包
[root@mysql50 ~]# yum -y install mysql-community-*.rpm #安装软件包
[root@mysql53 ~]# rpm -qa | grep -i mysql              #查看安装的mysql软件包

相关参数: 软件安装后自动创建相关目录与文件
文件 			   说明
/etc/my.cnf        主配置文件
/var/lib/mysql	数据库目录
默认端口号 		3306
进程名 	        mysqld
传输协议 		TCP
进程所有者 		mysql
进程所属组 		mysql

3).启动服务
首次启动服务,会执行数据初始化
[root@mysql50 ~]# systemctl restart mysqld     #启动服务
[root@mysql50 ~]# systemctl enable mysqld      #开机运行
[root@mysql53 ~]# systemctl status mysqld      #查看状态
[root@mysql53 ~]# netstat -utnlp | grep :3306  #查看服务信息
[root@mysql53 ~]# ps -C mysqld                 #查看进程

========================================================================
MySql初始配置

构建MySql服务器
  要求如下:
  在IP地址192.168.4.50主机上部署mysql服务
  设置数据管理root本机登录密码为123qq...A
 
1. 初始密码登录
 数据库管理员为root
   默认仅允许root本机连接
   首次登录密码在安装软件时随机生成
   随机密码存储在日志文件/var/log/mysqld.log里
  连接命令]#mysql -h数据库地址 -u用户 -p密码
例:
[root@mysql50 ~]# grep "password" /var/log/mysqld.log  #查看随机密码
2019-06-19T06:28:40.165585Z 1 [Note] A temporary password is generated for root@localhost: +:gF.vS1E*.k  #+:gF.vS1E*.k是随机密码
[root@mysql50 ~]# mysql -hlocalhost -uroot -p"+:gF.vS1E*.k"  #连接数据库服务


2. 修改root密码
 具体操作如下:
  使用alter user 命令修改登录密码
  新密必须满足密码策略
  管理员root使用新密码连接服务器
例:
mysql> alter user root@"localhost" identified by "123qq...A";  #修改登录密码
mysql> exit                                                    #退出
[root@mysql53 ~]# mysql -uroot -p123qq...A                     #连接数据库服务器


3. 修改密码策略
策略名称               验证
0 or LOW           长度
1 or MEDIUM(默认)   长度;数字,小写/大写,和特殊字符
2 or STRONG        长度 数字,小写/大写,和特殊字符;字典文件
例:
在数据库服务器操作
mysql> show variables like "%password%";       #查看变量
mysql> set global validate_password_policy=0;  #修改密码策略(当前有效)
mysql> set global validate_password_length=6;  #修改密码长度(当前有效)
[root@mysql50 ~]# vim /etc/my.cnf              #永久配置
[mysqld]
validate_password_policy=0
validate_password_length=6
[root@mysql50 ~]# systemctl restart mysqld  #重启服务

=====================================================================
数据库基本管理 

连接方式
 客户端连接MySql服务的方法
  (1)命令行
 (2)web页面 
  (3)安装图形软件
  (4)编写脚步(php java python .....)
使用mysql命令
mysql -h服务器IP -u用户名 -p密码 [数据库]
quit 或 exit 退出
例:
[root@mysql53 ~]# mysql -h192.168.4.50 -uzhai -p123qq...Z  #连接非本地服务器
mysql> exit
Bye
数据存储流程
 客户端把数据存储到数据服务器上的步骤
 (1)连接数据库服务器
 (2)建库       #类似于文件夹
 (3)建表       #类似于文件
 (4)插入记录   #类似于文件内容
 (5)断开连接

mysql管理环境
1).SQL命令使用规则
   SQL命令不区分字母大小写(密码 变量值除外)
    每条SQL命令以;结束
    默认命令不支持Tab键自动补齐
   \c命令终止命令
2)常用的SQL命令分类
 常用数据库使用SQL(结构化查询语音)
(1)DDL 数据定义语音 如: carete alter drop
(2)DML 数据操作语音 如: insert update delete
(3)DCL 数据控制语音 如: grant revoke
(4)DTL 数据事物语音 如: commit rollback savepoint

===================================================================
MySQL基本操作

1. 库管理命令
1).库类似于文件夹,用来存储在表
  可以创建多个库,通过库名区分
  show databases;        #显示当前所在的库
  select user();         #显示登陆的用户
  use 库名;              #切换库
  select database();     #显示当前所在的库
  create database 库名;  #创建新库
  show tables;           #显示已有的表
  drop database 库名;    #删除库
例:
mysql> show databases;        #显示当前所在的库
mysql> select user();         #显示登陆的用户
mysql> use sys;               #切换库
mysql> select database();     #显示当前所在的库
mysql> create database day01; #创建新库
mysql> show tables;           #显示已有的表
mysql> drop database day01;   #删除库

2).库名 命令规则
 仅可以使用数据 字母 下划线 不能纯数字
 区分字母大小写,具有唯一性
 不可使用指令关键字 特殊字符
例:
mysql> create database DAY01;
Query OK, 1 row affected (0.00 sec)
mysql> create database day01;
Query OK, 1 row affected (0.00 sec)


2. 表管理命令
 建表: 表存储数据的文件
mysql> create table 库名.表名(
         字段名1 类型(宽度),
         字段名2 类型(宽度),
         ......
)DEFAULT CHARSET=utf8; #指定中文字符集,可以给字段赋值中文(可写可不写)
desc 库名.表名;             #查看表结构
drop table 库名.表名;     #删除表
例:
mysql> create table day01.user(
    -> id int(20),
    -> name char(10)
    -> );
Query OK, 0 rows affected (0.29 sec)
mysql> desc day01.user;        #查看表结构
mysql> drop table day01.user;  #删除表
 

3. 记录管理命令
 记录 类似于文件里的行
   select * from 库名.表名;               #查看表记录
   insert into 库名.表名 values(值列表);  #插入表记录
   update 库名.表名 set 字段=值;          #修改表记录
   delete from 表;                        #删除表记录
例:
mysql> create table day01.user( #创建表
    -> id int(20),
    -> name char(10)
    -> );
mysql> insert into day01.user values(1,"zyq"); #插入表记录
mysql> select * from day01.user;               #查看表记录
mysql> update day01.user set id=10;            #修改表记录
mysql> drop table day01.user;                  #删除表记录

===================================================================
MYSQL数据类型 

1. 信息种类
• 数值型：体重、身高、成绩、工资
• 字符型：姓名、工作单位、通信住址
• 枚举型：兴趣爱好、性别
• 日期时间型：出生日期、注册时间

2. 字符类型
1).定长： char( 字符数 )
   最大长度 255 字符
   不够指定字符数时在右边用空格补齐
   字符数断超出时，无法写入数据。
例:
mysql> create table day01.user(
    -> name char(50),
    -> homedir char(50)
    -> );

2). 变长： varchar( 字符数 )
   按数据实际大小分配存储空间
   字符数断超出时，无法写入数据。
   大文本类型： text/blob
   字符数大于 65535 存储时使用
例:
mysql> create table day01.user2( 
    -> name char(5),
    -> email varchar(30)
    -> );
mysql> insert into day01.user2 values("zhai","zhaiyanquanA@163.com"); 
Query OK, 1 row affected (0.06 sec)

====================================================================
数值类型

1. 整数型
 只能存储整数
类型          名称                 有符号范围                 无符号范围
tinyint    微信整数              -128~127                   0~255
smallint   小整数              -32768~32767                0~65535
mediumint  中整数              -2的23次方~2的23次方减1     0~2的24次方减1 
int        大整数              -2的31次方~2的31次方减1      0~2的32次方减1 
bigint     极大整数            -2的63次方~2的63次方减1     0~2的64次方减1 
unsigned   使用无符号存心范围

2. 浮点型
 格式1: 字段名 类型;
 格式2: 字段名 类型(总宽度,小数位数)
类型       名称      有符号范围  无符号范围
float    单精度        0~2的32次方减1
double   双精度        0~2的64次方减1
例:
mysql> create table day01.user3(pay float,id double);            #创建库
mysql> create table day01.user4(pay float(5,2),id double(4,2));  #创建表
mysql> insert into day01.user4 values(55555,55555);              #插入数据
ERROR 1264 (22003): Out of range value for column 'pay' at row 1 #数字长度超过定义的长度报错
mysql> insert into day01.user4 values(555,55);  #插入正解的数字个数
Query OK, 1 row affected (0.03 sec)

============================================================================
日期时间类型

1. 类型
1).日期时间类型
  日期时间 datetime
  占用 8 个字节
  范围： 1000-01-01 00:00:00.000000 ~ 9999-12-31 23:59:59.999999
  格式: yyyymmddhhmmss
例:
mysql> create table day01.user5(name char(4),party datetime);  #创建表
mysql> insert into day01.user5 values("zyq",20190330083000);   #插入表记录
mysql> select * from day01.user5;                              #查看表记录
+------+---------------------+
| name | party               |
+------+---------------------+
| zyq  | 2019-03-30 08:30:00 |
+------+---------------------+

2).日期时间timestamp
  占用 4 个字节
  范围： 1970-01-01 00:00:00.000000 ~ 2038-01-19 03:14:07.999999
  格式: yyyymmddhhmmss
例:
mysql> create table day01.user6(name char(4),party timestamp);  #创建表
mysql> insert into day01.user6 values("zyq",20190330083000);    #插入表记录
mysql> select * from day01.user6;                               #查看表记录
+------+---------------------+
| name | party               |
+------+---------------------+
| zyq  | 2019-03-30 08:30:00 |
+------+---------------------+

3).日期 date
  占用 4 个字节 
  范围： 0001-01-01 ~ 9999-12-31
  格式: yyyymmdd
例:
mysql> create table day01.user7(name char(4),birthday date);  #创建表
mysql> insert into day01.user7 values("zyq",20190130);        #插入表记录
mysql> select * from day01.user7;
+------+------------+
| name | birthday   |
+------+------------+
| zyq  | 2019-01-30 |
+------+------------+

4).年份 year
   占用 1 个字节
   范围： 1901~2155
   格式: yyyy
例:
mysql> create table day01.user8(id int(10), your_start year);  #创建表
mysql> insert into day01.user8 values(1,2018);                 #插入表记录
或
mysql> insert into day01.user8 values(2,18);
mysql> select * from day01.user8; #插入表记录
+------+------------+
| id   | your_start |
+------+------------+
|    1 |       2018 |
|    2 |       2018 |
+------+------------+

5).时间 time
   占用 3 个字节
   格式： HH:MM:SS
例:
mysql> create table day01.user9(id int(4),up_time time);  #创建表
mysql> insert into day01.user9 values(1,1030);            #插入表记录
mysql> select * from day01.user9;                         #查看表记录
+------+----------+
| id   | up_time  |
+------+----------+
|    1 | 10:30:00 |
+------+----------+

6).关于日期时间字段
  当未给timesttamp字段值时,自动以当前系统时间赋值,而datetime值为NULL(空)

7).year类型
  要求使用4位数赋值
  当使用2位数赋值是:
  01~69视为2001~2069
  70~99视为1970~1999


2. 时间函数
MySql服务器内置命令
 可以使用时间函数给字段赋值
类型 			用途
now() 		获取系统当前日期和时间
year() 		执行时动态获得系统日期时间
sleep(N) 	休眠 N 秒
curdate() 	获取当前的系统日期
curtime() 	获取当前的系统时刻
month() 	获取指定时间中的月份
date() 		获取指定时间中的日期
time() 		获取指定时间中的时刻
例:
mysql> create table day01.user10( #创建表
    -> name char(15),
    -> your_s year,
    -> birthday date,
    -> up_class time,
    -> party datetime
    -> );
mysql> desc day01.user10; #查看表结构
+----------+----------+------+-----+---------+-------+
| Field    | Type     | Null | Key | Default | Extra |
+----------+----------+------+-----+---------+-------+
| name     | char(15) | YES  |     | NULL    |       |
| your_s   | year(4)  | YES  |     | NULL    |       |
| birthday | date     | YES  |     | NULL    |       |
| up_class | time     | YES  |     | NULL    |       |
| party    | datetime | YES  |     | NULL    |       |
+----------+----------+------+-----+---------+-------+
mysql> insert into day01.user10 values("zhaiyanquan",year(now()),time(now()),curdate(),now()); #插入表记录
mysql> select * from day01.user10;  #查看表记录
+-------------+--------+------------+----------+---------------------+---------------------+---------------------+
| name        | your_s | birthday   | up_class | party               |
+-------------+--------+------------+----------+---------------------+---------------------+---------------------+
| zhaiyanquan |   2019 | 2019-06-19 | 00:00:00 | 2019-06-19 21:17:34 |
+-------------+--------+------------+----------+---------------------+---------------------+---------------------+

=======================================================================================
枚举类型

1. enum 
1).enum 单选
  格式: 字段名 enum(值1,值2,值N)
  仅能选择一个值
  字段必须在列表里选择
例:
mysql> create table day01.user12(name char(20), age enum("boy","girl") );  #创建表
mysql> desc day01.user12; #查看表结构
+-------+--------------------+------+-----+---------+-------+
| Field | Type               | Null | Key | Default | Extra |
+-------+--------------------+------+-----+---------+-------+
| name  | char(20)           | YES  |     | NULL    |       |
| age   | enum('boy','girl') | YES  |     | NULL    |       |
+-------+--------------------+------+-----+---------+-------+
mysql> insert into day01.user12 values("zhaiyanquan","boy"); #插入表记录
mysql> select * from day01.user12; #查看表记录
+-------------+------+
| name        | age  |
+-------------+------+
| zhaiyanquan | boy  |
+-------------+------+

2).set
  set 多选
   格式: 字段名 set(值1,值2,值N)
   选择一个或多个值
   字段值必须在列表里选择
例:
mysql> create table day01.user13(name char(20), likes set("eat","game","music","money")); #创建表
mysql> desc day01.user13; #查看表结构
+-------+-----------------------------------+------+-----+---------+-------+
| Field | Type                              | Null | Key | Default | Extra |
+-------+-----------------------------------+------+-----+---------+-------+
| name  | char(20)                          | YES  |     | NULL    |       |
| likes | set('eat','game','music','money') | YES  |     | NULL    |       |
+-------+-----------------------------------+------+-----+---------+-------+
mysql> insert into day01.user13 values("zhaiyanquan","eat,game"); #插入表记录
mysql> select * from day01.user13; #查看表记录
+-------------+----------+---------------+
| name        | likes    |
+-------------+----------+---------------+
| zhaiyanquan | eat,game |
+-------------+----------+---------------+

rdbms1_day02================================================================================================

约束条件

1. 查看约束条件
mysql> desc day2.test2;
+-----------+----------+------+-----+---------+-------+
| Field     | Type     | Null | Key | Default | Extra |
+-----------+----------+------+-----+---------+-------+
| id        | int(11)  | YES  | MUL | NULL    |       |
| classroom | char(10) | YES  |     | NULL    |       |
| name      | char(4)  | YES  |     | NULL    |       |
| age       | int(11)  | YES  |     | NULL    |       |
+-----------+----------+------+-----+---------+-------+

2. 设置约束条件
  null      允许为空(默认设置)
  not null  不允许为null(空)
  key       键值类型
  default   设置默认键值,缺省为null
  extra     额外设置
例:
mysql> create table day2.test5( #创建表
    -> id int(20) not null,
    -> name char(4) not null,
    -> class char(12) default "nsd1903"
    -> );
mysql> desc day2.test5; #查看表结构
+-------+----------+------+-----+---------+-------+
| Field | Type     | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| id    | int(20)  | NO   |     | NULL    |       |
| name  | char(4)  | NO   |     | NULL    |       |
| class | char(12) | YES  |     | nsd1903 |       |
+-------+----------+------+-----+---------+-------+
#插入表记录
mysql> insert into day2.test5(id,name) values(10025,zyq);
mysql> insert into day2.test5(id,name) values(10026,"bob");
mysql> insert into day2.test5(id,name) values(10038,"tom");
mysql> select * from day2.test5; #查看表记录
+-------+------+---------+
| id    | name | class   |
+-------+------+---------+
| 10025 | zyq  | nsd1903 |
| 10026 | bob  | nsd1903 |
| 10038 | tom  | nsd1903 |
+-------+------+---------+

========================================================
修改表结构

语法结构
 用法: mysql> alter table 库名.表名 执行动作;
   add    添加字段
   modify 修改字段类型
   change 修改字段名
   drop   删除字段
   rename 修改表名   

1. 添加新字段
 用法: 新字段默认添加在字段末尾
 mysql> alter table 库名.表名
    add 字段名 类型(宽度) 约束条件
    [ after 字段名 | first ];
例:
mysql> desc day2.test5; #查看表结构(前)
+-------+----------+------+-----+---------+-------+
| Field | Type     | Null | Key | Default | Extra |
+-------+----------+------+-----+---------+-------+
| id    | int(20)  | NO   |     | NULL    |       |
| name  | char(4)  | NO   |     | NULL    |       |
| class | char(12) | YES  |     | nsd1903 |       |
+-------+----------+------+-----+---------+-------+
#添加新字段
mysql> alter table day2.test5 add email varchar(50);
mysql> alter table day2.test5 add email2 varchar(50) default "zhaiyanqunA@163.com";
mysql> desc day2.test5;#查看表结构(后)
+--------+-------------+------+-----+---------------------+-------+
| Field  | Type        | Null | Key | Default             | Extra |
+--------+-------------+------+-----+---------------------+-------+
| id     | int(20)     | NO   |     | NULL                |       |
| name   | char(4)     | NO   |     | NULL                |       |
| class  | char(12)    | YES  |     | nsd1903             |       |
| email  | varchar(50) | YES  |     | NULL                |       |
| email2 | varchar(50) | YES  |     | zhaiyanqunA@163.com |       |
+--------+-------------+------+-----+---------------------+-------+

mysql> alter table usertab add s_year year default "1990" after username;在username字段下方添加s_year字段,after是后的意思

2. 修改字段类型
基本用法: 修改的字段类型不能与已存储的数据冲突
 mysql> alter table 库名.表名
        modify 字段名 类型(宽度) 约束条件
        [ after 字段名 | first ];
例:
mysql> desc day2.test5; #查看表结构(修改前)
+--------+-------------+------+-----+---------------------+-------+
| Field  | Type        | Null | Key | Default             | Extra |
+--------+-------------+------+-----+---------------------+-------+
| id     | int(20)     | NO   |     | NULL                |       |
| name   | char(4)     | NO   |     | NULL                |       |
| class  | char(12)    | YES  |     | nsd1903             |       |
| email  | varchar(50) | YES  |     | NULL                |       |
| email2 | varchar(50) | YES  |     | zhaiyanqunA@163.com |       |
+--------+-------------+------+-----+---------------------+-------+
mysql> alter table day2.test5 modify name varchar(20) default "zyq"; #修改字段类型
mysql> desc day2.test5; #查看表结构(修改后)
+--------+-------------+------+-----+---------------------+-------+
| Field  | Type        | Null | Key | Default             | Extra |
+--------+-------------+------+-----+---------------------+-------+
| id     | int(20)     | NO   |     | NULL                |       |
| name   | varchar(20) | YES  |     | zyq                 |       |
| class  | char(12)    | YES  |     | nsd1903             |       |
| email  | varchar(50) | YES  |     | NULL                |       |
| email2 | varchar(50) | YES  |     | zhaiyanqunA@163.com |       |
+--------+-------------+------+-----+---------------------+-------+

3. 修改字段名
  基本用法: 也可以用修改字段类型
mysql> alter table 库名.表名
       change 源字段名 新子段名 类型(宽度)
         约束条件;
例:
mysql> desc day2.test5; #查看表结构(修改前)
+--------+-------------+------+-----+---------------------+-------+
| Field  | Type        | Null | Key | Default             | Extra |
+--------+-------------+------+-----+---------------------+-------+
| id     | int(20)     | NO   |     | NULL                |       |
| name   | varchar(20) | YES  |     | zyq                 |       |
| class  | char(12)    | YES  |     | nsd1903             |       |
| email  | varchar(50) | YES  |     | NULL                |       |
| email2 | varchar(50) | YES  |     | zhaiyanqunA@163.com |       |
+--------+-------------+------+-----+---------------------+-------+
mysql> alter table day2.test5 change email qq varchar(50); #修改字段名
mysql> desc day2.test5; #查看表结构(修改后)
+--------+-------------+------+-----+---------------------+-------+
| Field  | Type        | Null | Key | Default             | Extra |
+--------+-------------+------+-----+---------------------+-------+
| id     | int(20)     | NO   |     | NULL                |       |
| name   | varchar(20) | YES  |     | zyq                 |       |
| class  | char(12)    | YES  |     | nsd1903             |       |
| qq     | varchar(50) | YES  |     | NULL                |       |
| email2 | varchar(50) | YES  |     | zhaiyanqunA@163.com |       |
+--------+-------------+------+-----+---------------------+-------+

4. 删除字段
 基本用法
    表中有多条记录时,所有列的此字段的值都会被删除
mysql> alter table 库名.表名 drop 字段名;
例:
mysql> desc day2.test5; #查看表结构(修改前)
+--------+-------------+------+-----+---------------------+-------+
| Field  | Type        | Null | Key | Default             | Extra |
+--------+-------------+------+-----+---------------------+-------+
| id     | int(20)     | NO   |     | NULL                |       |
| name   | varchar(20) | YES  |     | zyq                 |       |
| class  | char(12)    | YES  |     | nsd1903             |       |
| qq     | varchar(50) | YES  |     | NULL                |       |
| email2 | varchar(50) | YES  |     | zhaiyanqunA@163.com |       |
+--------+-------------+------+-----+---------------------+-------+
mysql> alter table day2.test5 drop qq; #删除字段qq
mysql> desc day2.test5;#查看表结构(修改后)
+--------+-------------+------+-----+---------------------+-------+
| Field  | Type        | Null | Key | Default             | Extra |
+--------+-------------+------+-----+---------------------+-------+
| id     | int(20)     | NO   |     | NULL                |       |
| name   | varchar(20) | YES  |     | zyq                 |       |
| class  | char(12)    | YES  |     | nsd1903             |       |
| email2 | varchar(50) | YES  |     | zhaiyanqunA@163.com |       |
+--------+-------------+------+-----+---------------------+-------+

5. 修改表名
基本用法:
   表对应的文件名,也被改变
   表记录不受影响
例;
mysql> desc day2.test5; #查看表结构(表名修改前)
+--------+-------------+------+-----+---------------------+-------+
| Field  | Type        | Null | Key | Default             | Extra |
+--------+-------------+------+-----+---------------------+-------+
| id     | int(20)     | NO   |     | NULL                |       |
| name   | varchar(20) | YES  |     | zyq                 |       |
| class  | char(12)    | YES  |     | nsd1903             |       |
| email2 | varchar(50) | YES  |     | zhaiyanqunA@163.com |       |
+--------+-------------+------+-----+---------------------+-------+
mysql> alter table day2.test5 rename day2.test55; #修改表名
mysql> desc day2.test55; #查看表结构(表名修改后)
+--------+-------------+------+-----+---------------------+-------+
| Field  | Type        | Null | Key | Default             | Extra |
+--------+-------------+------+-----+---------------------+-------+
| id     | int(20)     | NO   |     | NULL                |       |
| name   | varchar(20) | YES  |     | zyq                 |       |
| class  | char(12)    | YES  |     | nsd1903             |       |
| email2 | varchar(50) | YES  |     | zhaiyanqunA@163.com |       |
+--------+-------------+------+-----+---------------------+-------+

========================================================
MySql键值使用

键值类型
   根据数据存储要求,选择键值
   (1) index  普通索引
   (2)unique   唯一索引
   (3)fulltext 全文索引
   (4)primary key  主键
   (5)foreign key  外键

索引介绍
   索引是什么
      类似于书的目录
      对表中字段值进行排序
      索引类型包括: Btree B+tree hash

索引优点
   通过创建唯一性索引,可以保证数据库中每个行数据的唯一性
   可以加快数据的查询速度
索引缺点
   当对表中的数据进行增加 删除和修改的时候,索引也要动态的调整,降低了数据的维护速度
   索引需要占物理空间

index 普通索引
 使用规则
   一个表可以有多个index字段
   字段的值允许重复,且可以赋值NULL值
   通常把做为查询条件的字段设置index字段
  index字段标志是MUL

1. 建表时创建索引
index(字段名),index(字段名)
例:
mysql> create table day2.test2(
    -> id int,
    -> classroom char(10),
    -> name char(4),
    -> age int,
    -> index(id),index(name)
    -> );
mysql> desc day2.test2; #查看表结构,带MUL是索引(前)
+-----------+----------+------+-----+---------+-------+
| Field     | Type     | Null | Key | Default | Extra |
+-----------+----------+------+-----+---------+-------+
| id        | int(11)  | YES  | MUL | NULL    |       |
| classroom | char(10) | YES  |     | NULL    |       |
| name      | char(4)  | YES  | MUL | NULL    |       |
| age       | int(11)  | YES  |     | NULL    |       |
+-----------+----------+------+-----+---------+-------+
mysql> show index from day2.test2\G; #查看索引信息

2. 在已有的表里创建索引
create index 索引名 on 表名(字段名)
mysql> create index xixi on day2.test2(name); 
mysql> show index from day2.test2\G; #查看索引信息,这时会多出一个索引

3.删除索引
drop index 索引名 on 表名;
mysql> drop index name on day2.test2; #删除索引
mysql> desc day2.test2; 查看表结构(后)
+-----------+----------+------+-----+---------+-------+
| Field     | Type     | Null | Key | Default | Extra |
+-----------+----------+------+-----+---------+-------+
| id        | int(11)  | YES  | MUL | NULL    |       |
| classroom | char(10) | YES  |     | NULL    |       |
| name      | char(4)  | YES  |     | NULL    |       |
| age       | int(11)  | YES  |     | NULL    |       |
+-----------+----------+------+-----+---------+-------+

========================================================
primary key主键

1. 建表时创建主键
primary key(字段名)
例:
mysql> create table day2.t6(
    -> name char(3) primary key,
    -> id int
    -> );

mysql> desc day2.t6; #查看表结构
+-------+---------+------+-----+---------+-------+
| Field | Type    | Null | Key | Default | Extra |
+-------+---------+------+-----+---------+-------+
| name  | char(3) | NO   | PRI | NULL    |       |
| id    | int(11) | YES  |     | NULL    |       |
+-------+---------+------+-----+---------+-------+

2. 在已有表里添加主键
alter table 表名 add primary key(字段名列表);
mysql> desc day2.t1; #查看表结构(前)
+-------+------------+------+-----+---------+-------+
| Field | Type       | Null | Key | Default | Extra |
+-------+------------+------+-----+---------+-------+
| name  | char(4)    | YES  |     | NULL    |       |
| age   | int(11)    | YES  |     | NULL    |       |
| par   | float(7,2) | YES  |     | NULL    |       |
+-------+------------+------+-----+---------+-------+

mysql> alter table day2.t1 add primary key(name); #添加主键

mysql> desc day2.t1; #查看表结构(后)
+-------+------------+------+-----+---------+-------+
| Field | Type       | Null | Key | Default | Extra |
+-------+------------+------+-----+---------+-------+
| name  | char(4)    | NO   | PRI | NULL    |       |
| age   | int(11)    | YES  |     | NULL    |       |
| par   | float(7,2) | YES  |     | NULL    |       |
+-------+------------+------+-----+---------+-------+

3. 删除主键
alter table 表名 drop primary key;
mysql> desc day2.t1; #查看表结构(前)
+-------+------------+------+-----+---------+-------+
| Field | Type       | Null | Key | Default | Extra |
+-------+------------+------+-----+---------+-------+
| name  | char(4)    | NO   | PRI | NULL    |       |
| age   | int(11)    | YES  |     | NULL    |       |
| par   | float(7,2) | YES  |     | NULL    |       |
+-------+------------+------+-----+---------+-------+
mysql> alter table day2.t1 drop primary key; #删除主键

mysql> desc day2.t1; #查看表结构(后)
+-------+------------+------+-----+---------+-------+
| Field | Type       | Null | Key | Default | Extra |
+-------+------------+------+-----+---------+-------+
| name  | char(4)    | NO   |     | NULL    |       |
| age   | int(11)    | YES  |     | NULL    |       |
| par   | float(7,2) | YES  |     | NULL    |       |
+-------+------------+------+-----+---------+-------+

4. 创建复合主键
alter table 表名 add primary key(字段名列表)
例:
mysql> create table day2.t4(
    -> name char(10),
    -> class char(7),
    -> status enum("yes","no"),
    -> primary key(name .class)
    -> );

#插入表记录
mysql> insert into day2.t4 values( "zhai",123,"yes");
mysql> insert into day2.t4 values( "zhai",124,"yes");
mysql> select * from day2.t4; #查看表记录
+------+-------+--------+
| name | class | status |
+------+-------+--------+
| zhai | 123   | yes    |
| zhai | 124   | yes    |
+------+-------+--------+
2 rows in set (0.01 sec)

5. 与auto_increment连用 #自增长,赋值时,字段的值字段加 1
mysql> create table day2.t5( id int primary key auto_increment,
    -> name char(10),
    -> sex enum("man","woman")
    -> );

mysql> desc day2.t5; #查看表结构
+-------+---------------------+------+-----+---------+----------------+
| Field | Type                | Null | Key | Default | Extra          |
+-------+---------------------+------+-----+---------+----------------+
| id    | int(11)             | NO   | PRI | NULL    | auto_increment |
| name  | char(10)            | YES  |     | NULL    |                |
| sex   | enum('man','woman') | YES  |     | NULL    |                |
+-------+---------------------+------+-----+---------+----------------+
#插入表记录 
mysql> insert into day2.t5(name,sex) values("bob","man"); (id没给值时,会自动赋值,自增)
mysql> insert into day2.t5(name,sex) values("zhai","man");
mysql> insert into day2.t5(name,sex) values("zyq","woman");
mysql> insert into day2.t5 values(8,"zyq","woman"); #可以手动给id值
mysql> select * from day2.t5; #查看表记录
+----+------+-------+
| id | name | sex   |
+----+------+-------+
|  1 | bob  | man   |
|  2 | bob  | man   |
|  3 | zhai | man   |
|  4 | zyq  | woman |
|  8 | zyq  | woman |
+----+------+-------+

mysql> delete from day2.t5; #删除表记录
mysql> insert into day2.t5(name,sex) values("bob","man"); #插入表记录
以上次的表id最大的为自增加1
mysql> select * from day2.t5; #查看表记录(前)
+----+------+------+
| id | name | sex  |
+----+------+------+
|  9 | bob  | man  |
+----+------+------+
#可以手动给id值
mysql> insert into day2.t5 values(1,"bobb","man"); #插入表记录
mysql> select * from day2.t5; #查看表记录(后)
+----+------+------+
| id | name | sex  |
+----+------+------+
|  1 | bobb | man  |
|  9 | bob  | man  |
+----+------+------+

先删除自增,在删除主键
mysql> desc day2.t5; #查看表结构(前)
+-------+---------------------+------+-----+---------+----------------+
| Field | Type                | Null | Key | Default | Extra          |
+-------+---------------------+------+-----+---------+----------------+
| id    | int(11)             | NO   | PRI | NULL    | auto_increment |
| name  | char(10)            | YES  |     | NULL    |                |
| sex   | enum('man','woman') | YES  |     | NULL    |                |
+-------+---------------------+------+-----+---------+----------------+
mysql> alter table day2.t5 modify id int; #删除自增
mysql> desc day2.t5;#查看表结构
+-------+---------------------+------+-----+---------+-------+
| Field | Type                | Null | Key | Default | Extra |
+-------+---------------------+------+-----+---------+-------+
| id    | int(11)             | NO   | PRI | NULL    |       |
| name  | char(10)            | YES  |     | NULL    |       |
| sex   | enum('man','woman') | YES  |     | NULL    |       |
+-------+---------------------+------+-----+---------+-------+
mysql> alter table day2.t5 drop primary key; #删除主键
mysql> desc day2.t5;#查看表结构(后)
+-------+---------------------+------+-----+---------+-------+
| Field | Type                | Null | Key | Default | Extra |
+-------+---------------------+------+-----+---------+-------+
| id    | int(11)             | NO   |     | NULL    |       |
| name  | char(10)            | YES  |     | NULL    |       |
| sex   | enum('man','woman') | YES  |     | NULL    |       |
+-------+---------------------+------+-----+---------+-------+

========================================================
foreign key外键

外键功能(作用)
  限制给字段赋值,插入记录时,字段之在另一个表字段值范围内选择.

使用规则
  表存储引擎必须是innodb
  字段类型要一致
  被参照字段必须要是索引类型的一种(primary key)

1. 创建外键
create table 表名(
 字段名列表,
 foreign key(字段名) references 表名(字段名) #指定外键
  on update cascade #同步更新
  on delete cascade #同步删除
) engine=innodb;    #指定存储引擎
例:
#创建员工表
mysql> create table day2.yg(
    -> yg_id int primary key auto_increment, 
    -> name char(10))engine=innodb;
#插入表记录
mysql> insert into day2.yg(name) values("zhai");
mysql> insert into day2.yg(name) values("yan");
mysql> insert into day2.yg(name) values("quan");
mysql> select * from day2.yg; #查看表记录
+-------+------+
| yg_id | name |
+-------+------+
|     1 | zhai |
|     2 | yan  |
|     3 | quan |
+-------+------+
#创建外键
mysql> create table day2.gz(
    -> gz_id int,
    -> pay float(7,2),
    -> foreign key(gz_id) references day2.yg(yg_id)
    -> on update cascade 
    -> on delete cascade
    -> );
mysql> desc day2.gz; #查看表结构
+-------+------------+------+-----+---------+-------+
| Field | Type       | Null | Key | Default | Extra |
+-------+------------+------+-----+---------+-------+
| gz_id | int(11)    | YES  | MUL | NULL    |       |
| pay   | float(7,2) | YES  |     | NULL    |       |
+-------+------------+------+-----+---------+-------+
mysql> show create table day2.gz\G; #查看创建表的命令,\G竖着显示
mysql> insert into day2.gz values(4,35000); #会报错,没有id号为4
#插入表记录
mysql> insert into day2.gz values(1,35000);
mysql> insert into day2.gz values(2,50000);
mysql> insert into day2.gz values(3,50000);
mysql> select * from day2.gz; #查看表记录
+-------+----------+
| gz_id | pay|
+-------+----------+
|     1 | 35000.00 |
|     2 | 50000.00 |
|     3 | 50000.00 |

2. 同步更新
mysql> select * from day2.yg;  #查看表记录(前)
+-------+------+
| yg_id | name |
+-------+------+
|     1 | zhai |
|     2 | yan  |
|     3 | quan |

mysql> select * from day2.gz; #查看表记录(前)
+-------+----------+
| gz_id | pay|
+-------+----------+
|     1 | 35000.00 |  
|     2 | 50000.00 |
|     3 | 50000.00 |
+-------+----------+
mysql> update day2.yg set yg_id=4 where yg_id=3; #修改同步更新
mysql> select * from day2.yg; #查看表记录(后)
+-------+------+
| yg_id | name |
+-------+------+
|     1 | zhai |
|     2 | yan  |
|     4 | quan |
+-------+------+
mysql> select * from day2.gz; #查看表记录(后)
+-------+----------+
| gz_id | pay  |
+-------+----------+
|     1 | 35000.00 |
|     2 | 50000.00 |
|     4 | 50000.00 |
+-------+----------+

3. 删除同步
mysql> select * from day2.yg; #查看表记录(前)                                              
+-------+------+
| yg_id | name |
+-------+------+
|     1 | zhai |
|     2 | yan  |
|     4 | quan |
+-------+------+
mysql> select * from day2.gz; #查看表记录(前)
+-------+----------+
| gz_id | pay  |
+-------+----------+
|     1 | 35000.00 |
|     2 | 50000.00 |
|     4 | 50000.00 |
+-------+----------+
mysql> delete from day2.yg where yg_id=1; #同步删除
mysql> select * from day2.yg; #查看表记录(后)
+-------+------+
| yg_id | name |
+-------+------+
|     2 | yan  |
|     4 | quan |
+-------+------+
mysql> select * from day2.gz; #查看表记录(后)
+-------+----------+
| gz_id | pay  |
+-------+----------+
|     2 | 45000.00 |
|     4 | 50000.00 |
+-------+----------+

4. 删除外键
alter table 表名 drop foreign key 外键名;
mysql> show create table day2.gz\G; #查看创建表的命令,\G竖着显示
  CONSTRAINT `gz_ibfk_1` FOREIGN KEY (`gz_id`) REFERENCES `yg` (`yg_id`) ON DELETE CASCADE ON UPDATE CASCADE
mysql> alter table day2.gz drop foreign key gz_ibfk_1; #删除外键


rdbms1_day03================================================================================================

搜索路径

查看搜索路径
  安装服务时已自动创建
mysql> show variables like "secure_file_priv"; #查看
+------------------+-----------------------+
| Variable_name    | Value                 |
+------------------+-----------------------+
| secure_file_priv | /var/lib/mysql-files/ |
+------------------+-----------------------+

1. 修改搜索路径
  操作步骤
    创建目录并修改所有者
    修改主配置文件
    重启服务 
[root@centos ~]# mkdir /myfile
[root@centos ~]# chown mysql /myfile
[root@centos ~]# vim /etc/my.cnf
[mysqld]
secure_file_priv="/myfile"
#重启动服务
[root@centos ~]# systemctl restart mysqld
[root@centos ~]# systemctl enable mysqld

mysql> show variables like "secure_file_priv"; #查看
+------------------+----------+
| Variable_name    | Value    |
+------------------+----------+
| secure_file_priv | /myfile/ |
+------------------+----------+

mysql> show variables like "%file%"; #查看所有

================================================================
数据导入

命令格式
  数据导入步骤
     默认只有root用户有数据导入权限
     建表
     导入数据

命令格式
  mysql> load data infile "目录名/文件名"
  into table 库名.表名
  fields terminated by "分隔符"
  lines terminated by "\n"

注意事项
  具体如下:
    字段分隔符要与文件一致
    表字段类型和字段个数要与文件匹配
    导入数据时指定文件的绝对路径

mysql> create database day3; #建库day3
mysql> create table day3.user( #建表user
    -> name char(50),
    -> password char(1),
    -> uid int,
    -> gid int,
    -> comment char(150),
    -> homedir char(50),
    -> shell char(50)
    -> );

mysql> desc day3.user; #查看表结构
+----------+-----------+------+-----+---------+-------+
| Field    | Type      | Null | Key | Default | Extra |
+----------+-----------+------+-----+---------+-------+
| name     | char(50)  | YES  |     | NULL    |       |
| password | char(1)   | YES  |     | NULL    |       |
| uid      | int(11)   | YES  |     | NULL    |       |
| gid      | int(11)   | YES  |     | NULL    |       |
| comment  | char(150) | YES  |     | NULL    |       |
| homedir  | char(50)  | YES  |     | NULL    |       |
| shell    | char(50)  | YES  |     | NULL    |       |
+----------+-----------+------+-----+---------+-------+

1. 命令格式
  mysql> load data infile "目录名/文件名"
  into table 库名.表名
  fields terminated by "分隔符"
   lines terminated by "\n"
例:
[root@centos ~]# cp  /etc/passwd /myfile
mysql> load data infile "/myfile/passwd" #导入数据
    -> into table day3.user
    -> fields terminated by ":"
    -> lines terminated by "\n";

mysql> select * from day3.user; #查看表记录
mysql> alter table day3.user add id int primary key auto_increment first; #添加新字段

================================================================
数据导出

注意事项
  具体如下:
    导出数据行数由SQL查询决定
    导出的是表记录,不包括字段名
    自动创建存储数据的文件.
    存储数据文件,具有唯一性.

命令格式
 格式1
    mysql> select命令 into outfile "目录名/文件名"
例:
mysql> select * from day3.user into outfile "/myfile/user1.txt";

 格式2
    mysql> select命令 into outfile "目录名/文件名"
    fields terminated by "分隔符";
例:
mysql> select * from day3.user where id<=5 into outfile "/myfile/user2.txt"
    -> fields terminated by "%%%%%%";

 格式3
    mysql> select命令 into outfile "目录名/文件名"
    fields terminated by "分隔符"
    lines terminated by "\n";
例:
mysql> select name,uid,gid from day3.user where id<=8 into outfile "/myfile/user3.txt"
    -> fields terminated by "@@@@"
    -> lines terminated by "\n";

#查看导出内容
[root@centos ~]# cat /myfile/user1.txt 
1	root	x	0	0	root	/root	/bin/bash
2	bin	x	1	1	bin	/bin	/sbin/nologin
3	daemon	x	2	2	daemon	/sbin	/sbin/nologin
[root@centos ~]# cat /myfile/user2.txt
1%%%%%%root%%%%%%x%%%%%%0%%%%%%0%%%%%%root%%%%%%/root%%%%%%/bin/bash
2%%%%%%bin%%%%%%x%%%%%%1%%%%%%1%%%%%%bin%%%%%%/bin%%%%%%/sbin/nologin
3%%%%%%daemon%%%%%%x%%%%%%2%%%%%%2%%%%%%daemon%%%%%%/sbin%%%%%%/sbin/nologin
4%%%%%%adm%%%%%%x%%%%%%3%%%%%%4%%%%%%adm%%%%%%/var/adm%%%%%%/sbin/nologin
5%%%%%%lp%%%%%%x%%%%%%4%%%%%%7%%%%%%lp%%%%%%/var/spool/lpd%%%%%%/sbin/nologin
[root@centos ~]# cat /myfile/user3.txt 
root@@@@0@@@@0
bin@@@@1@@@@1
daemon@@@@2@@@@2
adm@@@@3@@@@4
lp@@@@4@@@@7
sync@@@@5@@@@0
shutdown@@@@6@@@@0
halt@@@@7@@@@0

================================================================
增加表记录

注意事项
  具体如下
    字段值要与字段类型相匹配。
    字符类型的字段，要用""号括起来.
    依次给所有字段赋值时，字段名可以省略
    只给部分字段赋值时，必须明确写出对应的字段名称。
    没有赋值的字段使用默认值或自增长赋值。

语法格式
  格式1: 添加1条记录,给所有字段赋值
  insert into 表名 values (字段值列表)
例:
mysql> insert into day3.user values(22,"zhai","x",2002,2030,"fasfl","yyef","fdsaa");

  格式2: 添加N条记录,给所有字段赋值
  insert into 表名
  values
  (字段值列表),(字段值列表),(字段值列表);
例:
mysql> insert into day3.user
    -> values
    -> (24,"bob","x",2004,2050,"halt","/root","/sbin/nologin"),
    -> (25,"tom","x",2005,2051,"halt","/root","/sbin/nologin"),
    -> (26,"xixi","x",2006,2052,"halt","/root","/sbin/nologin");
   
   格式3: 添加1条记录,给指定字段赋值
   insert into 表名(字段值列表) values(字段值列表) 
    values
     (字段值列表), #第1条记录
     (字段值列表), #第3条记录
     (字段值列表);  #第3条记录
例:
mysql> insert into day3.user(id,name,uid)
    -> values
    -> (27,"zyq",110),
    -> (28,"used",120),
    -> (29,"student01",130);

================================================================
查询表记录

注意事项
 要求如下
   *表示所有字段
   查看当前库表记录是库名可以省
   字段列表决定显示列个数
   条件决定显示行的个数

格式1 查看所有记录
  select 字段1, .. ..,字段N from 库名.表名;
例:
mysql> select * from day3.user;
mysql> select id,name,uid,gid  from day3.user;

格式2 条件查询
 select 字段1, .. ..,字段N from 库名.表名
 where 条件表达式;
例:
mysql> select id,name,uid,gid from day3.user where id<=5;
+----+--------+------+------+
| id | name   | uid  | gid  |
+----+--------+------+------+
|  1 | root   |    0 |    0 |
|  2 | bin    |    1 |    1 |
|  3 | daemon |    2 |    2 |
|  4 | adm    |    3 |    4 |
|  5 | lp     |    4 |    7 |
+----+--------+------+------+

================================================================
更新表记录

注意事项
 具体如下: 
   字段值要与字段类型相匹配
   对于字符类型的字段,值要用双引号括起来
   若不使用where限定条件,会更新有所有记录字段值
   限定条件时,只更新匹配条件的记录的字段值

语法格式
  格式1,批量更新
  update 库名.表名
  set 字段名=值,字段名=值,字段名=值,....;
例:
mysql> update day3.user 
    -> set password="A",comment="student user"; #更新password字段值和comment字段值所有记录

   格式2,条件匹配更新
   update 库名.表名
   set 字段名=值,字段名=值,字段名=值,....
   where 条件表达式;
例:
mysql> update day3.user set password="x" where name="root"; #只更新root用户的password值

================================================================
删除表记录

注意事项: 不加条件删除表中的所有行

格式1，条件匹配删除
 delete from 库名.表名 where 条件表达式;
例:
mysql> delete from day3.user where id=29; #删除id=29的行			
	
格式2，删除所有记录
 delete from 库名.表名;
例:
mysql> delete from day3.user;

================================================================
基本匹配条件

1. 数值比较
字段必须是数值类型
类型      比较           例子
=        相等           id=3
>        大于           uid>3
>=      大于或等于     uid>=3
<        小于           uid<3
<=      小于或等于     uid<=3
!=      不相等          uid!=3
例:
mysql> select * from day3.user where id=3;     #查询id=3的行
mysql> select * from day3.user where uid>80;   #查询uid>80的行
mysql> select * from day3.user where uid>=100;  
mysql> select * from day3.user where uid<100;
mysql> select * from day3.user where uid<=100;
mysql> select * from day3.user where uid!=3;

2. 字符比较/匹配空/非空
字段必须是字符类型
类型            比较      例子
=              相等       name="root"
!=             不相等     name!="root"
is null      空        shell is null
is not null  非空      shel is not null
例:
mysql> select * from day3.user where name="root"; 
mysql> select * from day3.user where name!="root";
mysql> select * from day3.user where shell is null;
mysql> select * from day3.user where shell is not null;

3. 逻辑匹配
多个判断条件时使用
类型      用途        格式
or      逻辑或      条件1 and 条件2 and 条件3
and     逻辑与      条件1 or 条件2 or 条件3
!或not  逻辑非
()        提高优先级   (uid+gid)/2
例:
mysql> select name,id,uid,gid from day3.user where
    -> name="root" and shell="/bin/bash" and id=1; #3个条件都有满足
mysql> select id,name,uid,gid,age from day3.user where #匹配的条件显示
    -> name="root" or shell="/sbin/nologin" or id=8; 

4. 范围内匹配/去重显示
匹配范围内的任意一个值即可
类型                        比较
in(值列表)             在...里...
not in(值列表)         不在...里...
between 数字 and 数字   在...之间...
distinct 字段名          去重显示
例:
mysql> select name from day3.user where name in ("bob","zhai","yan"); #查找括号里的用户
mysql> select id,name,uid from day3.user where id in(3,8,9,2,6,4);    #查找id号为括号里的用户
mysql> select name from day3.user where name not in ("bob","zhai","yan"); #查找不在括号里的用户
mysql> select id,name,uid from day3.user where id between 10 and 20;      #查找id号10到20的用户
mysql> select distinct shell from day3.user;  
mysql> select distinct shell from day3.user where uid>=100; #查找id号大于等于100的用户

================================================================
高级匹配条件
  
1. 模糊匹配
用法
where 字段名 like ' 通配字串 '
_表示1个字符
%表示0~n个字符
实例
 列出name值"4个字符"的记录
例:
mysql> select name from day3.user where name like "___"; #4个_表示显示name字段为4个字母的名称
mysql> select name from day3.user where name like "_%_"; #显示所有
mysql> select name from day3.user where name like "%a%"; #查找包含a的名字
mysql> select name from day3.user where name like "a%";  #查找以a开头的名字

2. 正则匹配
用法
where 字段名 regexp ' 正则表达式‘
正则元字符 ^ $ . [ ] * |
示例
列出 name 值“以 J 开头或以 Y 结尾”的记录
例:
mysql> select name from day3.user where name regexp '^r|y$'; #匹配以r开头或以用结尾
mysql> select * from day3.user where name regexp "^r.*t"; #匹配以r开头以用结尾的行
mysql> select name,uid from day3.user where name regexp '[0-9]'; #匹配为数字name
mysql> select name,uid from day3.user where uid regexp  '^...$'; #匹配uid为3位的记录

3. 四则运算
运算操作
字段必须是数值类型
类 型   用 途          例子
+      加法            uid+gid
-       减法            uid-gid
*       乘法            uid*gid
/       除法            uid/gid
%       取余数(求模)    uid%gid
()      提高优先级      (uig+gid)/2
例:
mysql> select name,id,uid+gid zh from day3.user where name="bin"; #计算用户bin
mysql> select name,id,uid+gid zh from day3.user; #计算所有用户
mysql> select name,uid,gid,(uid+gid)/2 pjz from day3.user; #计算所有用户平均值
mysql> update day3.user set gid=gid+1; #gid字段记录加1

================================================================
操作查询结果

1. 聚集函数（对字段的值做统计，字段的类型要求是数值类型）
count(字段名）  #统计字段值的个数
sum(字段名）    #求和
max(字段名）    #输出字段值的最大值
min(字段名）    #输出字段值的最小值
avg(字段名）    #输出字段值的平均值
例:
mysql> select avg(uid) from day3.user; #输出字段值的平均值
mysql> select sum(uid) from day3.user; #求和
mysql> select min(uid) from day3.user; #输出字段值的最小值
mysql> select max(uid) from day3.user; #输出字段值的最大值
mysql> select count(*) from day3.user; #统计字段值的个数

2. 查询结果排序
用法
sql查询  order  by  字段名  [asc|desc];
asc   升序排序
desc  降序排序
例:
mysql> select name,uid from day3.user where uid>=10 and uid <=500 order by uid;      #没指定默认升序排序
mysql> select name,uid from day3.user where uid>=10 and uid <=500 order by uid desc; #降序排序

3. 查询结果分组
 用法
  sql查询  group by 字段名;
例;
mysql> select shell from day3.user group by shell; #shell分组
mysql> select gid from day3.user group by gid;     #gid分组

4. 查询结果过滤
having用法
sql查询  having 条件表达式;
例:
mysql> select name from day3.user having name="root";              #在所有行查询root用户
mysql> select name from day3.user where id<=20 having name="root"; #在前20行查询root用户

5. 限制查询显示行数(默认显示所有查询的记录)
sql查询  limit  数字；          #显示查询结果的前几行
sql查询  limit  数字1，数字2； #显示查询结果指定范围的行
数字1 起始行(0表示第1行)
数字2 综行数
例:
mysql> select name,id,uid,gid from day3.user limit 3;   #显示查询结果的前3行
mysql> select name,id,uid,gid from day3.user limit 3,3; #显示第4行到第6行,右3表示3行 
+------+----+------+------+
| name | id | uid  | gid|
+------+----+------+------+
| adm  |  4 |    3 |  4 |
| lp   |  5 |    4 |  7 |
| sync |  6 |    5 |  0 |
+------+----+------+------+

================================================================
MySql管理工具

将phpMyAdmin-2.11.11-all-languages.tar.gz包拷贝到虚拟机192.168.4.50
在192.168.4.50 上安装图形软件phpMyAdmin
	# yum  -y  install  httpd  php  php-mysql
	# systemctl start httpd 
	# systemctl  enabled  httpd 

	# tar  -zxvf  phpMyAdmin-2.11.11-all-languages.tar.gz
	# mv  phpMyAdmin-2.11.11-all-languages  /var/www/html/phpmyadmin

	# cd /var/www/html/phpmyadmin/
	# cp  config.sample.inc.php   config.inc.php  //创建主配置文件

	# vim  config.inc.php
	17   $cfg[‘blowfish_secret’] = ‘plj123’;  //cookies参数
	31   $cfg[‘Servers’][$i][‘host’] = ‘localhost’; //数据库服务器IP地址
	
	访问软件管理数据库服务
	http://192.168.4.50/phpmyadmin
	用户名 root
	密  码  

rdbms1_day04================================================================================================

用户授权

用户授权：在数据库服务器上添加新的连接用户并设置访问权限

1. grant 授权
 授权: 添加用户并设置权限

权限列表
  all   #所有权限
  usage #无权限
  select,update,inset          #个别权限
  select,update(字段1,...,字段N) #指定字段
库名
  *.*       #所有库所有表
  库名.*    #一个库
  库名.表名 #一张表

用户名
  授权时自定义,要有标识性
  存储在mysql库user表里
客户端地址
 %              #所有主机
 192.1668.4.%  #网段内的所有主机
 192.168.4.1    #1台主机
 localhost   #数据库服务器本机

命格式
   grant  权限列表 on 数据库名 to  用户名@“客户端地址”
   identified by  "密码"  #授权用户密码
   with grant option; #有授权权限,可选项
例:
mysql> grant all on day3.* to zhai@"%" identified by "123qq...a"; #all是给所有权限,%是能ping通的主机可以连,
mysql> grant all on day3.* to bob@"%"
    -> identified by "123qq...a3"
    -> with grant option;       #有授权权限,可以给其他用户授权
mysql> show grants for zhai@"%" #查看授权用户的授权信息
测试: 用客户机登录
[root@cenos01 ~]# mysql -h192.168.4.50 -uzhai -p123qq...a


2. 授权库: mysql库 记录授权信息,主要表如下:
 user表            记录已有授权用户的名及访问权限
 db表               记录已有授权用户对库的访问权限
 tables_priv表   记录已有授权用户对表的访问权限
 columns_priv表  记录已有授权用户对字段的访问权限
例:
mysql> select host,user from mysql.user;  #用管理员查看已有授权的用户
mysql> select host,user,db from mysql.db; #用管理员查看已有授权的用户和库
mysql> select host,db from mysql.db;      #用管理员查看已有授权的库
mysql> select * from mysql.tables_priv
    ->where Table_name="user" and db="day3"\G;

mysql> flush privileges; #更新时,要刷新表

相关命令
 登录用户使用
   命令                                                                      作用
select user();                                        显示连接用户名及客户端地址
show grants;                                          用户显示自身的访问权限
show grants for 用户名@“客户端地址";                          管理员查看已有授权用户的访问权限
set password=password("密码");                         授权用户链接后修改链接密码
set password for 用户名@“客户端地址"=password("密码");  管理员重置授权用户链接密码
drop user 用户名@“客户端地址";                                  删除授权用户(必须有管理员权限)
例:
mysql> select user(); #显示当前数据库登录的用户权限
mysql> show grants;   #查看授权信息
mysql> set password=password("123qq...z");              #普通用户登录后,修改密码
mysql> set password for zhai@"%"=password("123qq...a"); #管理员root修改授权用户密码,zhai@"%"是授权时设置的
mysql> drop user zhai@"%";                              #管理员root删除授权用户,zhai@"%"是授权时设置的
mysql> select password("123qq...z");                    #查询密码加密文
+-------------------------------------------+--------------------------------
| password("123qq...z")                     |
+-------------------------------------------+--------------------------------
| *3EE6C83652F1496FB24A99D60AD053BD048944FC |
+-------------------------------------------+--------------------------------


3. 撤销权限
  命令格式
mysql> revoke 权限列表 on 库名.表 from 用户名@"客户端地址";
例:
mysql> select host,user from mysql.user;         #先用管理员查看已有那些授权的用户
mysql> show grants for bob@"%";                  #再查看该用户有那些授权
mysql> revoke grant option on *.*  from bob@"%"; #撤销用户授权权限
mysql> drop user zyq@"%";                        #删除掉授权的用户

=========================================================================================
root密码

1. 恢复root密码

主要操作过程
1)停止mysql服务器程序
[root@centos ~]# systemctl stop mysqld

2)跳过授权表启动mysql服务程序
[root@centos ~]# vim /etc/my.cnf
[mysqld]
skip-grant-tables #跳过授权表启动mysql服务程序
#validate_password_policy=0
#validate_password_length=6

4)以正常方式重启
[root@centos ~]# systemctl restart mysqld

5)修改数据库root密码mysql服务程序
mysql> select user,host,authentication_string from mysql.user; #查看身份验证信息
mysql> update mysql.user set authentication_string=password("123qqq...A") #修改密码
    -> where user="root" and host="localhost";
mysql> flush privileges; #更新表,需要刷新

6)恢复主配置文件到修改前
[root@centos ~]# vim /etc/my.cnf
[mysqld]
#skip-grant-tables #注释掉跳过授权启动mysql服务程序
validate_password_policy=0 
validate_password_length=6

7)以正常方式重启
[root@centos ~]# systemctl restart mysqld #重启服务
[root@centos ~]# systemctl enable mysqld  #设置开机自启


2. 重置数据库root密码
在Shell命令行修改数据库登录密码 
 需要验证旧密码
[root@centos ~]# mysqladmin -uroot -p password "新密码"
Enter password:  #输入旧密码
例:
[root@centos ~]# mysqladmin -uroot -p password "123qq...A"
Enter password: 

=========================================================================================
完全备份

数据备份方式
物理备份
   冷备: cp tar .. ..
逻辑备份
  mysqldump #备份命令
  mysql     #恢复命令

物理备份及恢复
 备份操作
  cp -r /var/lib/mysql 备份目录/mysql.bak

1. 物理备份及恢复
备份操作
[root@centos ~]# cp -r /var/lib/mysql /root/mysql.bak #mysql.bak是目录
[root@centos ~]# tar -zcvf /root/mysql.bak.tar.gz /var/lib/mysql

恢复操作
[root@cenos01 ~]# systemctl stop mysqld                       #停止mysql服务程序
[root@cenos01 ~]# scp -r /root/mysql.bak root@192.168.4.51:/  #将备份的数据拷贝远程主机
[root@cenos01 ~]# rm -rf /var/lib/mysql                       #清空本机数据的内容
[root@cenos01 ~]# cp -r /mysql.bak/ /var/lib/mysql            #将备份的数据拷贝到数据库目录里
[root@cenos01 ~]# chown -R mysql:mysql /var/lib/mysql　       ＃恢复所有者所属组
[root@cenos01 ~]# systemctl  restart mysqld                   #重启服务
[root@cenos01 ~]# systemctl enable mysqld                     #设置为开机自启

============================================================================
逻辑备份

数据备份策略
 完全备份: 备份所有数据
 增量备份: 备份上次备份后,所有新产生的数据
 差异备份: 备份完全备份后,所有新产生的数据

备份时库名表示方式
 --all-databases 或 -A  #备份所有库
 数据库名                    #单个库
 数据库名.表名               #单张表
-B 数据库1 数据库2          #多个库
注意事项: 无论备份还是恢复,都要验证用户权限

1. 完全备份及恢复
完全备份
]# mysqldump -uroot -p密码　库名　> 目录/xxx.sql
例：
[root@centos ~]# mysqldump -uroot -p123qq...A day3 > /day3.sql　          #备份一个库
[root@centos ~]# mysqldump -uroot -p123qq...A -B day1 day2 day3 >  mys.sq #备份多个库
[root@cenos01 ~]# mysqldump -uroot -p123qq...A -A > /mysql.sql            #备份所有库

完全恢复
]#mysql -uroot -p密码 库名 <　目录/xxx.sql
例：
mysql> create database day3; #创建day3库
[root@centos ~]# mysql -uroot -p123qq...A day3 < /day3.sql #恢复day3库数据

=========================================================================================
增量备份

binlogr日志
什么是binlog
1)也称做二进制日志
2)MySql服务日志文件的一种
3)记录除查询之外的所有SQL命令
4)可用于数据备份和恢复
5)配置mysql主从同步必要条件


1. 启用日志
  配置项                                        用途 
server_id=数字                        指定id值(1-255)
log-bin或log-bin=目录名/文件名      启用binlog日志
max_binlog_size=数值m            指定日志文件容量,默认1G
例:
[root@cenos50 ~]# vim /etc/my.cnf
[mysqld]
log-bin       #启用binlog日志
server_id=50  #指定id值
[root@cenos50 ~]# systemctl restart mysqld #重启服务

binlog相关文件
 主机名-bin.index    索引文件
 主机名-bin.000001   第1个二进制日志
 主机名-bin.000002   第2个二进制日志

手动生成新的日志文件:
1)[root@cenos50 ~]# systemctl restart mysqld
2)mysql> flush logs;
或
[root@cenos50 ~]# mysql -uroot -p123qq...A -e  "flush logs"
3)[root@cenos50 ~]# mysqldump -uroot -p123qq...A  --flush-logs day3  > /day3.logs


2. 清理日志
删除指定编号之前的binlog日志文件
mysql>purge master logs to "binlog文件名";
例:
mysql> purge master logs to "cenos50-bin.000006";
删除所有binlog日志,重建新日志
mysql> reset master;
mysql> show master status; #显示当前用户最新日志

============================================================================
恢复数据

1. 分析日志

三种记录方式:
statement 报表模式
row       行模式
mixed     混合模式

1)查看日志当前记录格式
mysql> show variables like "binlog_format";
+---------------+-------+
| Variable_name | Value |
+---------------+-------+
| binlog_format | MIXED |
+---------------+-------+

2)修改日志记录格式
[root@cenos50 ~]# vim /etc/my.cnf
[mysqld]
binlog_format="mixed" #修改日志记录格式
[root@cenos50 ~]# systemctl restart mysqld #重启服务

分析日志
查看日志内容
 mysqlbinlog [选项] binlog日志文件名
            选项                                     用途
--start-detaime="yyy-mm-dd hh:mm:ss"    起始时间
--stop-datetime="yyyy-mm-dd hh:mm:ss"   结束时间
--start-postition=数字                        起始偏移量
--stop-postition=数字                         结束偏移量
例:
[root@cenos50 ~]# mysqlbinlog --start-datetime="2019-06-19 15:30" /var/lib/mysql/mysql-bin.000002

恢复数据
基本思路
 使用mysqlbinlog提取历史sql操作
 通过管道交给 mysql 命令执行
命令格式
  mysqlbinlog 日志文件 | mysql -uroot -p密码
例:
[root@cenos50 mysql]# mysqlbinlog cenos50-bin.000001 | mysql -uroot -p123qq...A

[root@centos ~]# ls /var/lib/mysql/*bin.*

rdbms1_day05================================================================================================

MySQL备份工具(percona软件)

常用的 MySQL备份工具

物理备份缺点
   跨平台性差
   备份时间长、冗余备份、浪费存储空间
mysqldump备份缺点
   效率较低、备份和还原速度慢、锁表
   备份过程中，数据插入和更新操作被阻塞

XtraBackup工具?
   款强大的在线热备份工具
   备份过程中不锁库表，适合生产环境
   由专业组织 Percona提供(改进MySQ分支)
主要含两个组件
  xtrabackup：C程序，支持 InnoDB/XtraDB
  innobackupex：以Per脚本封装xtrabackup,还支持 MyISAM

======================================================
安装percona

1. 安装软件包
yum安装自动解决依赖
percona-xtrabackup-24-2.4.7-1.el7X86_64. rpm
[root@cenos50 mysql]# rpm -ivh libev-4.15-1.el6.rf.x86_64.rpm
[root@cenos50 mysql]# yum -y install percona-xtrabackup-24-2.4.7-1.el7.x86_64.rpm

2. 查看安装信息
查看安装列表
[root@host62-]# rpm -ql percona-xtrabackup-24
/usr/bin/innobackupex  #备份inob、xtra、myisam引擎的表
/usr/bin/xbcloud
/usr/bin/xbcloud_osen
/usr/ bin/xbcrypt
/usr/bin/ xbstream
/sr/ bin/xtrabackup  #备份innodb、xtra引擎的表
查看命令帮助
[root@host62 ]# rpm -ql percona-xtrabackup-24
root@host62~]# innobackupex-help #常用选项
root@host62~]# man innobackupex  #备份佯洋细帮助

========================================================
innobackupex命令

常用选项              含义
--host           主机名
--user           用户名
--port           端口号
--password       密码
--databases      数据库名
--no-timestamp   不用日期命名备份文件存储的子目录名

--databases="库名    #1个库
--databases="库1库2  #多个库
--databases=“库1表   #1张表

  常用选项                              含义
--redo-only                   日志合并
--apply-log                   准备恢复数据
--copy-back                   拷贝数据
--incrementa 目录名               增量备份
--incremental-basedir=目录名    增量备份时，指定上一次备份数据
--ncremental-dir=目录名          准备恢复数据时，指定增量备份数据存储的目录名
--export                      导出表信息
--import                      导入表空间

===================================================================
innobackupex备份与恢复

mysql> show create table day3.user\G; #显示创建表的命令
mysql> show engines;                  #显示当前数据库支持的搜索引擎

完全备份与恢复

命令格式
1. 完全备份
]# innobackupex --user用户名 --password 密码  备份目录名
]# innobackupex --user用户名 --password 密码  备份目录名 --no-timestamp
例:
应用示例：备份所有数据到/allbak目录
[root@cenos50 ~]# innobackupex --user root --password 123qq...A /allbak                #以系统日期命名备份文件存储的子目录名
[root@cenos50 ~]# innobackupex --user root --password 123qq...A /allbak --no-timestamp #不以系统日期命名备份文件存储的子目录名

2. 完全恢复
使用备份文件恢复数据
]# innobackupex --appy-log 目录名  #准备恢复数据
]# innobackupex --opy-back 目录名  #恢复数据
例:
[root@cenos50 ~]# scp -r /allbak/ root@192.168.4.51:/root/
[root@cenos51 ~]# systemctl stop mysqld #
[root@cenos51 ~]# rm -rf /var/lib/mysql/*                #恢复时要求目录为空
[root@cenos51 ~]# innobackupex --apply-log /root/allbak  #准备恢复数据
[root@cenos51 ~]# innobackupex --copy-back /root/allbak  #恢复数据
[root@cenos51 ~]# chown -R mysql:mysql /var/lib/mysql    #设置所有者所属组
[root@cenos51 ~]# systemctl restart mysqld               #重启服务

===================================================================================================
增量备份与恢复

1. 增量备份

命令格式
增量备份时，必须先有一次备份通常是完全备份
周一完全备份，周二~周日增量备份
]# innobackupex --user root --password 密码 /fullbak --no-timestamp  #完全备份
]# innobackupex --user用户名 password 密码 --incremental 增量目录 --incremental-basedin=目录名 --no-timestamp
]# innobackupex --user root --password 密码 incremental /new1dir --incremental-basedi=/fullbak 
   --no-timestamp #增量备份
]# innobackupex- user root- password 密码 --incremental /new2dir --incremental-basedir=/new1dir 
   --no-timestamp  #增量备份
例:
[root@cenos50 ~]# innobackupex --user root --password 123qq...A /fullall --no-timestamp #选备份出所有数据,用来比较
[root@cenos50 ~]# ls /fullall #列出刚备份的所有内容
[root@cenos50 ~]# cat /fullall/xtrabackup_checkpoints
backup_type = full-backuped
from_lsn = 0
to_lsn = 3688033
last_lsn = 3688042
compact = 0
recover_binlog_info = 0
mysql> insert into day3.user(name) values("aaaaaa"); #插入数据
[root@cenos50 ~]# innobackupex --user root --password 123qq...A --incremental /new1dir --incremental-basedir=/fullall --no-timestamp #增量备份
[root@cenos50 ~]# ls /new1dir  #列出刚备份的所有内容
[root@cenos50 ~]# cat  /new1dir/xtrabackup_checkpoints
backup_type = incremental
from_lsn = 3688033
to_lsn = 3689699
last_lsn = 3689708
compact = 0
recover_binlog_info = 0
mysql> insert into day3.user(name) values("zhaiyanqun"); #插入数据
[root@cenos50 ~]# innobackupex --user root --password 123qq...A --incremental /new2dir --incremental-basedir=/new1dir --no-timestamp #插入数据
[root@cenos50 ~]# ls /new2dir  #列出刚备份的所有内容
[root@cenos50 ~]# cat /new2dir/xtrabackup_checkpoints
backup_type = incremental
from_lsn = 3689699
to_lsn = 3691743
last_lsn = 3691752
compact = 0
recover_binlog_info = 0


2. 增量恢复

]# systemctl stop mysqld 
]# rm -rf /var/lib/mysql/*
]# innobackupex --apply-log --redo-only 完全备份目录  #完全恢复
]# innobackupex --apply-log --redo-only 完全备份目录 --incremental-dir=增量备份目录 #准备恢复数据
]# innobackupex --copy-back 完全备份目录   #拷贝文件,恢复数据
]# chown -R mysql:mysql /var/lib/mysql #设置所有者所属组
例:
[root@cenos50 ~]# innobackupex --user root --password 123qq...A /fullall --no-timestamp #完全备份,如果有完全备份文件可以不做此步
[root@cenos50 ~]# scp -r /fullall/ /new1dir/ root@192.168.4.51:/ #拷贝完全备份文件和增量备份到51主机
[root@cenos51 ~]# systemctl stop mysqld
[root@cenos51 ~]# rm -rf /var/lib/mysql/*
[root@cenos51 ~]# innobackupex --apply-log --redo-only /fullall  #完全恢复,/fullall是完全备份文件
[root@cenos51 ~]# innobackupex --apply-log --redo-only /fullall --incremental-dir=/new1dir #恢复增量
[root@cenos51 ~]# innobackupex --copy-back /fullall   #拷贝文件
[root@cenos51 ~]# chown -R mysql:mysql /var/lib/mysql #设置所有者所属组
[root@cenos51 ~]# systemctl restart mysqld            #重启服务

==============================================================================================
恢复单张表

1. 操作步骤
具体操作如下:
  删除表空间
  导出表信息
  拷贝表信息文件到数据库目录下
  修改表信息文件的所有者及组用户为mysq
  导入表空间
  删除数据库目录下的表信息文件
  查看表记录

2. 相关命令
mysql> alter table 库名.表名 discard tablespace；     #删除表空间
]# innobackupex --apply-log --export 数据完全备份目录  #导出表信息
]# cp 数据完全备份目录/据库名目录/表名.{ibd,cfg,exp} 数据库目录/库名目录/  #拷贝表信息文件
]# chown mysql:mysql 数据库目录/库名                 #修改所有者/组
mysql> alter table 库名.表名 import tablespace； #导入表空间
mysql> select * from 库名.表名；                      #查看表记录
]# rm -rf 数据库目录/库名/表名.{cfg,exp}              #删除表信息文件
例:
mysql> delete from day3.user;                                #误删除数据操作
mysql> alter table day3.user discard tablespace;             #删除表空间
[root@cenos50 ~]# innobackupex --apply-log --export /fullall #导出表信息
[root@cenos50 ~]# cp /fullall/day3/user.{ibd,cfg,exp} /var/lib/mysql/day3 #拷贝表信息文件
[root@cenos50 ~]# chown -R mysql:mysql /var/lib/mysql/      #修改所有者/组
mysql> alter table day3.user import tablespace;             #导入表空间
mysql> select * from day3.user;                             #查看表记录
[root@cenos50 ~]# rm -rf /var/lib/mysql/day3/user.{cfg,exp} #删除表信息文件


10.rdbms2=========================================================================================

rdbms2_day01======================================================================================

MySQL主从同步

主从同步介绍
  实现数据自动同步的服务结构
  主服务器：接受客户端访问连接
  从服务器：自动同步主服务器数据

拓扑结构
  主服务器: 192.168.4.51
  从服务器: 192.168.4.52
  客户端 :  192.168.4.50

主从同步原理

Master
  启用binlog日志
Slave
  Slave_IO：复制master主机 binlog日志文件里的SQL命令到本机的relay-log文件里
  Slave_SQL: 执行本机relay-log文件里的SQL语句,实现与Master数据一致.

构建主从同步
构建思路
配置主库
   启用 binlog日志、授权用户、查看 binlog日志信息
配置从服务器
   确保与主服务器数据一致。
   设置server_id、指定主库信息、启动 slave程序

===========================================================
构建主从同步

1. 配置主服务器

1)修改主配置文件
  启用binlog日志并重启服务
[root@mysq 51 mysq]# vim /etc/my.cnf
[mysqld]
log_bin=日志名   #启用 binlog日志
server_id=id值  #指定服务器ID号
例:
[root@cenos51 ~]# vim /etc/my.cnf
[mysqld]
log-bin=day3
server_id=51
[root@cenos51 ~]# systemctl restart mysqld #重启动服务

2)授权用户
   用户权限 replication slave
   用户名自定义
   客户端地址允许从库连接
   密码自定义
mysql> grant replication slave on *.* to 用户名@"%" identified by "密码";
例: 
mysql> grant replication slave on *.* to repluser@"%" identified by “123qq...a";

3)查看日志信息
mysql> show master status\G,
File: mysq 51-bin. 000001
Position:334
Binlog_ Do_DB:
Binlog_ Ignore_DB
Executed gtid set.

4)确保与主库数据一致
   在主库上备份数据，备份文件拷贝给从库
#主库备份数据 -- master-data记录当前备份数据对应的日志信息
]# mysqldump -uroot -p密码 --master-data 数据库名 > /allbak.sql
例:
[root@cenos51 ~]# mysqldump -uroot -p123qq...A --master-data day3 > day3.sql #完全备份
[root@cenos51 ~]# scp  /day3.sql root@192.168.4.52:/                         #将完全备份文件拷贝到从服务器


2. 配置从服务器
1)修改主配置文件my.cnf
指定server_id 不允许与主库 server_id值相同
[root@cenos52 ~]# vim /etc/my.cnf
[mysqld]
server_id=52                               #指定服务器ID
[root@cenos52 ~]# systemctl restart mysqld #重启动服务

2)确保与主库数据一致
   在主库上备份数据，备份文件拷贝给从库
   从库使用备份文件恢复数据
   从库查看备份数据对应的binlog日志信息
#从库恢复数据
]# mysql -uroot -p密码 数据库名 <  /day3.sql
]#vim /day3.sql #查看binlog日志名及偏移量
例:
mysql> create database day3;
[root@cenos52 ~]# mysql -uroot -p123qq...A2  day3 < /day3.sql #从库恢复数据,一个库
[root@cenos51 ~]# vim /day3.sql #查看binlog日志名及偏移量
或
mysql> show master status\G;

3)指定主库信息
mysql> change master to
    -> master_host="192.168.4.51",    #主库p地址
    -> master_user="repluser",        #主库授权用户(主的用户)
    -> master_password="123qq...a",   #授权用户密码
    -> master_log_file="day3.000003", #主库日志文件(主的)
    -> master_log_pos=154;            #日志偏移量(主的)
mysql> start slave                    #启动slave进程
(1)Master信息会自动保存到/var/lib/mysql/master.info文件
(2)若更改主库信息时,应先执行stop slave；修改后再执行 start slave；

4)查看 Slave状态
确认IO线程、SQ线程都是Yes状态
mysql> show slave status\G;
Master host:192.168.4.51 #主库ip地址
Master_User: repluse
Slave_Io_Running: Yes  #IO线程已运行
Slave_sQL_Running Yes  #SQL线程已运行

相关文件
存放在数据库目录下
  文件名                        说明
master info             主库信息
relay-log.info          中继日志信息
主机名-relay-bin.XXXXXX   中继日志
主机名-relay-bin.index    索引文件


主从同步结构
结构类型
基本应用
    单向复制：一主 <--  --从
扩展应用
    主多从：从<--主 -->从
                   |
                  从
链式复制：主 <-- 从 <-- 从
互为主从：主<-->主

=================================================================
配置主从从结构
  具体要求如下:
    配置主机192.168.4.53为主库服务器
    配置主机192.168.4.54为53主机的从库库服务器
    配置主机192.168.4.54为55主机的从库库服务器
    客户端测试配置


1. 配置主服务器
配置步骤
启用binlog日志
重启服务数据库服务
用户授权
]# vim /etc/my.cnf
[mysqld]
log-bin=日志名
server_id=id号
mysql> grant replication slave on *.* to 用户名@"从库iP地址" identified by“密码";
]# systemctl restart mysqld
例:
[root@cenos53 ~]# vim /etc/my.cnf
[mysqld]
log-bin=day3
server_id=53
[root@cenos53 ~]# systemctl restart mysqld #重启动服务
mysql> grant replication slave on *.* to repluser@"%" identified by "123qq...a";


2. 配置从服务器
1).配置从服务器54(第一台从)
   修改配置文件
   用户授权
   指定主库信息
   启动slave进程
]#ⅶm/etc/my.cnf
[mysqld]
server_id=id号
log-bin=日志名
log_slave_updates #允许级联复制
]# systemctI restart mysqld
mysql> grant replication slave on *.* to 用户名@“% identified by "密码";
mysql> change master to master_host=192.168.4.5
  -> master user=“用户名
  -> master_ password=“密码”",
  -> master_log_ file="binlog日志文件名";
  -> master_log_pos=偏移量；
mysql> start slave;          #启动save进程
mysql> show slave status\G;  #检查状态
例:
mysql> grant replication slave on *.* to repluser54@"%" identified by "123qq...A54"; 
mysql> show master status; #查看日志信息(此步在主服务器操作)
+-------------+----------+--------------+------------------+-------------------+
| File        | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+-------------+----------+--------------+------------------+-------------------+
| db53.000002 |      602 |              |                  |                   |
+-------------+----------+--------------+------------------+-------------------+
[root@cenos54 ~]# vim /etc/my.cnf #修改配置文件
[mysqld]
server_id=54
log-bin=db54 
log_slave_updates  #允许级联复制
[root@cenos54 ~]# systemctl restart mysqld 
mysql> change master to
    -> master_host="192.168.4.53",     #主库ip地址
    -> master_user="repluser53",       #主库授权用户
    -> master_password="123qq...A53",  #授权用户密码(主的用户)
    -> master_log_file="db53.000002",  #主库日志文件(主的)
    -> master_log_pos=602;             #日志偏移量(主的)
mysql> start slave;                    #启动save进程
mysql> show slave status\G;            #确认IO线程、SQ线程都是Yes状态

2)配置从服务器55(第二台从)
  修改配置文件
  指定主库信息
  启动slave进程
]# vim /etc/my.cnf
[mysqld]
server_id=id号
]#systemctl restart mysqld
mysql> change master to 
    -> master_host=192.168.4.54          #主库ip地址
    -> master user=“用户名",                   #主库授权用户(主的用户)
    -> master_password=“密码",                #授权用户密码(主的)
    -> master_log_file="binlog日志文件名",  #主库日志文件(主的)
    -> master_log_pos=偏移量；                 #日志偏移量(主的)
mysql> start slave;                       #启动slave进程
mysql> show slave status\G;               #检查状态
例:
mysql> show master status;  #查看日志信息(此步在第一台从服务器操作)
+-------------+----------+--------------+------------------+-------------------+
| File        | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set|
+-------------+----------+--------------+------------------+-------------------+
| db54.000002 |      761 |              |                  |                  |
+-------------+----------+--------------+------------------+-------------------+
[root@cenos55 ~]# vim /etc/my.cnf #修改配置文件
[mysqld]
server_id=55
log-bin=db55
[root@cenos54 ~]# systemctl restart mysqld 
mysql> change master to
    -> master_host="192.168.4.54",     #第一台从库ip地址
    -> master_user="repluser54",       #第一台从库授权用户
    ->  master_password="123qq...A54", #授权用户密码(第一台从的用户)
    -> master_log_file="db54.000002",  #主库日志文件(第一台从的)
    -> master_log_pos=761;             #日志偏移量(第一台从的)
mysql> start slave;                    #启动slave进程
mysql> show slave status\G;            #确认IO线程、SQ线程都是Yes状态

测试配置
测试步骤
   在主库授权访问数据的连接用户
   客户端连接主库，执行与权限匹配的sq操作
   授权用户连接第1台从库，可以看到主库的数据
   授权用户连接第2台从库，可以看到主库的数据
mysql> grant all on 库.* to 用户@"客户端地址" identified by "密码";
]#mysq -h 数据库P地址 -u用户名 -p 密码 
mysql> select * from 库.表;

=======================================================================
复制模式

配置半同步复制模式
具体要求如下
   开启案例2主库192.168.4.53半同步复制模式
   开启案例2从库192.168.4.54半同步复制模式
   开启案例2从库192.168.4.55半同步复制模式
   查看半同步复制模式是否开启

复制模式介绍
异步复制( Asynchronous replication)
   主库执行完一次事务后，立即将结果返给客户端，并不关心从库是否已经接收并处理
全同步复制( Fully synchronous replication)
   当主库执行完一次事务，且所有从库都执行了该事务后才将结果返回给客户端。
半同步复制( Semisynchronous replication)
   介于异步复制和全同步复制之间
   主库在执行完一次事务后，等待至少—个从库接收到并写到relay log中才将结果返回给客户端


模式配置
1. 查看是否允许动态加载模块
  默认允许
mysql> show variables like 'have_dynamic_loading';
+----------------------+-------+
| Variable_name        | Value |
+----------------------+-------+
| have_dynamic_loading | YES   |
+----------------------+-------+


2. 命令行加载插件
使用数据库管理员root用户访问服务
mysql> install plugin rpl_semi_sync_master soname "semisync_master.so"; #主服务器上执行
mysql> install plugin rpl_semi_sync_slave soname "semisync_slave.so";   #从服务器上执行
mysql> select plugin_name,plugin_status from information_schema.plugins where plugin_name like "%semi%"; #查看(主/从)
+----------------------+---------------+--------------------------+
| plugin_name          | plugin_status |
+----------------------+---------------+--------------------------+
| rpl_semi_sync_master | ACTIVE        |
| rpl_semi_sync_slave  | ACTIVE        |
+----------------------+---------------+--------------------------+

3. 启用半同步复制
   半同步复制，默认是关闭的
mysql> show variables like "rpl_semi_sync_%_enabled"; #查看(设置前)
+------------------------------+-------+---------------------------+
| Variable_name                | Value |
+------------------------------+-------+---------------------------+
| rpl_semi_sync_master_enabled | OFF   |
| rpl_semi_sync_slave_enabled  | OFF   |
+------------------------------+-------+---------------------------+
mysql> set global rpl_semi_sync_master_enabled=1;     #主服务器执行
mysq> set global rpl_semi_sync_slave_enabled=1;       #从服务器执行
mysql> show variables like "rpl_semi_sync_%_enabled"; #查看(设置后)
+------------------------------+-------+--------------------------+
| Variable_name                | Value |
+------------------------------+-------+--------------------------+
| rpl_semi_sync_master_enabled | ON    |
| rpl_semi_sync_slave_enabled  | ON    |
+------------------------------+-------+--------------------------+


4. 永久启用半同步复制
修改主配置文件/etc/my.cnf
在[ mysqld]下方添加
#主服务器
[root@cenos53 ~]# vim /etc/my.cnf
plugin-load=rpl_semi_sync_master=semisync_master.so rpl_semisync_master_enabled=1
[root@cenos53 ~]# systemctl restart mysqld

#从服务器
[root@cenos54 ~]# vim /etc/my.cnf
[mysqld]
plugin-load=rpl_semi_sync_slave=semisync_slave.so rpl_semi_sync_slave_enabled=1
[root@cenos54 ~]# systemctl restart mysqld


5. 是maste和slave两种角色时
 需同时启用
]# vim /etc/my.cnf
plugin-load="rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"
rpl_semi_sync_master_enabled=1
rpl_semi_sync_slave_enabled=1
mysql> show variables iike "rpi_semi_sync_%_enabled";
例:
[root@cenos53 ~]# vim /etc/my.cnf

rdbms2_day02======================================================================================

MySql读写分离

MySQL读写分离
主从复制的应用局限性?
   把客户端访问时的查询求和写请求分别的数据库服务处理
如何分离MySQ读、写流量?
   减轻主服务器工作压力,提高从服务器硬件利用率
   在客户端区分，还是在服务器端区分?
   程序实现       程序员写代码实现
   部署服务实现   在服务器部署数据读写分离服务

读写分离的原理
由MySQ代理面向客户端提供服务
   收到SQL写请求时，交给 master服务器处理
   收到SQL读请求时，交给 slave服务器处理

====================================================
构建读写分离

实现MySql读写分离
1.搭建一主一从结构
2.配置maxscale代理服务器
3.测试配置

1.构建思路
1)部署 MySQL一主一从结构
   主服务器192168451
   从服务器192168452
2)部署MySQ代理服务器
   装包、修改配置文件、启动服务
3)测试配置
   客户端连接代理服务访问数据

部署 maxscale服务
MaxScale代理软件
由MySQL的兄弟公司MariadB开发
下载地址
https://downloads.mariadb.com/files/Maxscale
[root@pxysvr -l# rpm -ivh maxscale-212-1.hel.7.x86_64.rpm
[root@cenos57 /]# rpm -ql maxscale #查看安装路径


2. 部署 maxscale服务
修改配置/etc/maxscale.cnf
[root@cenos57 /]# vim /etc/maxscale.cnf
[maxscale]
threads=auto #进程数,auto是根据cpu核数开启进程数
[serverl]    #定义数据库服务器主机名
type=server
address=192.168.4.51 #master主机ip地址
port=3306
protocol=My SQLBackend

[servere2]           #定义数据库服务器
type=server
address=192168.4.52  #lave主机jp地址
port=3306
protocol=My SQLBackend

[MySQL Monitor] #定义要监视的数据库节点
type=monitor
module=mysqlmon
servers=server1,server2 #主、从数据库的主机名,监视server1和server2谁是主,谁是从
user=maxscalemon        #链接数据库用户名
passwd=123qq...a57      #链接数据库密码
monitor_interval=10000

#[Read-Only Service]
#type=service
#router=readconnroute
#servers=server1
#user=myuser
#passwd=mypwd
#router_options=slave

[Read-Write Service]    #定义读写分离的数据库节点
type=service
router=readwritesplit
servers=server1,server2 #主、从数据库的主机名
user=maxscalemysql
passwd=123qq...a57
max_slave_connections=100%

#[Read-Only Listener]
#type=listener
#service=Read-Only Service
#protocol=MySQLClient
#port=4008

[Read-Write Listener]
type=listener
service=Read-Write Service
protocol=MySQLClient
port=4006  #写端口

[MaxAdmin Listener] 
type=listener
service=MaxAdmin Service
protocol=maxscaled
socket=default
port=4016  #读端口


3. 在主、从数据库服务器创建授权用户
mysql> grant replication slave,replication client on *.* to scalemon@"%" identified by "123qqq…A"; #创建监控用户
mysql> grant select on mysql.* to maxscale@"%" identified by "123qq...A";                          #创建路由用户
例:
51主服务
mysql> grant replication slave,replication client on *.* to maxscalemon@"%" identified by "123qq...a57";
mysql> grant select on mysql.* to maxscalemysql@"%" identified by "123qq...a57";
在52从服务查看
mysql> select host,user from mysql.user;

4. 启动服务
主要操作:
   启动服务、查看端口、停止服务
[# maxscale -f /etc/maxscale.cnf  
[root@cenos57 ~]# ps -C maxscale #查看进程
  PID TTY          TIME CMD
23201 ?        00:00:08 maxscale
[root@cenos57 ~]# killall -9 maxscale #杀死进程
[root@cenos57 ~]# maxscale -f /etc/maxscale.cnf  #再重启服务
[root@cenos57 ~]# netstat -utnlp | grep maxcale #查看端口是否开启存在
tcp6       0      0 :::4006                 :::*                    LISTEN      23518/maxscale      
tcp6       0      0 :::4016                 :::*                    LISTEN      23518/maxscale 

5. 测试配置
1)在代理服务器本机访问管理
]# maxadmin -uadmin -pmariadb -P端口
例:
[root@cenos57 ~]# maxadmin -uadmin -pmariadb -P4016
MaxScale> list servers
Servers.
-------------------+-----------------+-------+-------------+--------------------+--------------------+--------------------
Server             | Address         | Port  | Connections | Status              
-------------------+-----------------+-------+-------------+--------------------+--------------------+--------------------
server1            | 192.168.4.51    |  3306 |           0 | Master, Running
server2            | 192.168.4.52    |  3306 |           0 | Slave, Running
-------------------+-----------------+-------+-------------+--------------------+--------------------+--------------------

2)客户端连接代理访问数据
]#mysq -h服务器地址 -P端口 -u用户名 -p密码
例:
在51主服务器
mysql> grant select,insert on day3.* to zhangsan@"%" identified by "123qq...zs"; #授权用户shangsan
在52从服务器查看zhangsan用户
mysql> select host,user from mysql.user;
+-----------+---------------+-----------------+
| host      | user          |
+-----------+---------------+-----------------+
| %         | maxscalemon   |
| %         | maxscalemysql |
| %         | repluse       |
| %         | repluser      |
| %         | zhangsan      |
| %         | zyq           |
| localhost | mysql.sys     |
| localhost | root          |
+-----------+---------------+-----------------+
在客户端50进入测试
[root@cenos50 ~]# mysql -h192.168.4.57 -P4006 -uzhangsan -p123qq...zs #P(大写)表示端口,p(小写)表示密码 
mysql> select * from day3.user;

======================================================================
MySql多实例

什么是多实例
    在一台物理主机上运行多个数据库服务
为什么要使用多实例
   节约运维成本
   提高硬件利用率

配置MySQL多实例
1.在主机192.168.4.56上，配置第1个MySQL实例
   实例名称 mysqld1、端口3307
   数据库目录/data3307、pd文件 mysql1。pid
   错误日志mysq1.err
2在主机192.168.4.56上，配置第2个MSQ实例
   实例名称 mysqld2、端口3308
   数据库目录/data3308、pid文件mysq2pid
   错误日志mysq2.err


1. 配置多实例
具体操作
  解压软件
  修改目录名
]#tar -zxvf mysql-5.7.20-linux-glibc212-86_64.tar.gz
]#mv mysql-5.7.20-linux-glibc2.12-86_64 /usr/local/mysql
例:
[root@cen056 ~]# tar -zxvf /mysql-5.7.20-linux-glibc2.12-x86_64.tar.gz
[root@cen056 ~]# mv mysql-5.7.20-linux-glibc2.12-x86_64 /usr/local/mysql

配置文件
主配置文件/etc/my.cnf
   每个实例要有独立的数据库目录和监听端口号
   每个实例要有独立的实例名称和独立的Ock文件
]#/etc/my.cnf
[mysqld_multi]  #启用多实例
mysqld=/usr/local/mysql/bin/mysqld_safe    #指定进程文件路径
mysqladmin=/usr/local/mysql/bin/mysqladmin  #指定管理命令路径
user=root  #指定进程用户
[mysqldX]  #实例进程名称X表示实例编号,如[mysql2]
port=3307  #端口号
datadir=/data3307 #数据库目录,要手动创建
socket=/data3307/mysql.sock   #指定sock文件的路径和名称
pid-file=/data3307/mysqld.pid #进程pid号文件位置
log-error=/data3307/mysqlderr #错误日志位置
例:
[root@cen056 ~]# vim /etc/my.cnf
[mysqld_multi]  #启用多实例
mysqld=/usr/local/mysql/bin/mysqld_safe     #指定进程文件路径
mysqladmin=/usr/local/mysql/bin/mysqladmin #指定管理命令路径
user=root  #指定进程用户
[mysqld1]  #实例进程名称X表示实例编号
port=3307  #端口号
datadir=/dir1                 #数据库目录,要手动创建
log-error=/dir1/mysql1.error  #错误日志位置
pid-file=/dir1/mysqld1.pid     #进程pid号文件位置
socket=/dir1/mysqld1.socket    #指定sock文件的路径和名称
[mysqld2]  #实例进程名称X表示实例编号
port=3308  #端口号
datadir=/dir2                  #数据库目录,要手动创建
log-error=/dir2/mysqld2.error  #错误日志位置
pid-file=/dir2/mysqld2.pid     #进程pid号文件位置
socket=/dir1/mysqld2.socket    #指定sock文件的路径和名称
[root@cen056 ~]# mkdir -p /dir1 /dir2 #创建指定的文件夹


2. 管理多实例
启动服务
停止服务
]# /usr/local/mysq/bin/mysqld_multi start  实例编号  #动服务
]# /usr/local/mysql/bin/mysqld_multi --user=root --password=密码 stop 实例编号  #停止服务
例:
[root@cen056 ~]# /usr/local/mysql/bin/mysqld_multi start 1 #1表示server1,如果是2表示server2
-bash: /usr/local/mysq/bin/mysqld_multi: 没有那个文件或目录
[root@cen056 ~]# echo $PATH 
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/root/bin
[root@cen056 ~]# PATH=/usr/local/mysql/bin:$PATH #当前有效
[root@cen056 ~]# echo "export PATH=/usr/local/mysql/bin:$PATH" >> /etc/bashrc #永久生效
[root@cen056 ~]# yum list | grep libaio #显示要安装的包
[root@cen056 ~]# yum -y install libaio* 
[root@cen056 ~]# mysqld_multi start 1
........
2019-06-17T12:35:28.455917Z 1 [Note] A temporary password is generated for root@localhost: 2/k-0a-O+ucR #2/k-0a-O+ucR是登录密码
[root@cen056 ~]# mysqld_multi start 2
.......
2019-06-17T12:36:31.998375Z 1 [Note] A temporary password is generated for root@localhost: yUNl9+*y!.Ka  #yUNl9+*y!.Ka是初开始登录密码
[root@cen056 ~]# ls /dir1 #查看生成文件
[root@cen056 ~]# ls /dir1 #查看生成文件
[root@cen056 ~]# mysqld_multi --user=root --password="123qq...A56" stop 1  #停止服务1
[root@cen056 ~]# netstat -utnpla | grep mysqld
tcp6       0      0 :::3308                 :::*                    LISTEN      24468/mysqld 


3. 客户端访问
本机连接
   使用初始密码连接
   修改本机登陆密码
   连接实例
]#/c/local/mysql/bin/mysql -uroot -p切始密码 -S sock文件
mysql> alter user root@"localhost" identified by "新密码";
例:
[root@cen056 ~]# mysql -uroot -p"t>bkep.kU7ou"
mysql: [Warning] Using a password on the command line interface can be insecure.
ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock' (2) #报错
[root@cen056 ~]# mysql -uroot -p'2/k-0a-O+ucR' -S /dir1/mysqld1.socket #使用初始密码连接(dir1)
mysql> alter user root@"localhost" identified by "123qq...A56";        #修改本机登陆密码(dir1)
[root@cen056 ~]# mysql -uroot -p'yUNl9+*y!.Ka' -S /dir2/mysqld2.socket #使用初始密码连接(dir2)
mysql> alter user root@"localhost" identified by "123qq...562";        #使用初始密码连接(dir2)
[root@cen056 ~]# netstat -utnlp  | grep  mysqld #查看端口
tcp6       0      0 :::3307                 :::*                    LISTEN      24276/mysqld        
tcp6       0      0 :::3308                 :::*                    LISTEN      24468/mysqld 

rdbms2_day03======================================================================================

分库分表

什么是分库分表
   将存放在一台数据库服务器中的数据，按照特定方式进行拆分，
   分散存放到多台数据库服务器中,以达到分散单台服务器负载的效果

垂直分割
纵向切分
   将单个数据库的多个表按业务类型分类，分散存储到不同的数据库
Application: 客户 存款 贷款 支付

水平分割
横向切分
   按照表中指定字段的分片规则，将表记录按行切分,分散存储到多个数据库中。

MyCAT介绍
软件介绍
mycat是基于Java的分布式数据库系统中间件，为高并发环境的分布式存储提供解决方案
   适合数据大量写入的存储需求
   支持 MySQL、 Oracle、 Sqlserver、 Mongodb等
   提供数据读写分离服务
   提供数据分片服务
   基于阿里巴巴Cobar进行研发的开源软件

分片规则
mycat支持提供10种分片规则
  1.枚举法去sharding-by-intfile
  2.固定分片rule1
  3.范围约定 auto-sharding-long
  4.求模法mod-long
  5.日期列分区法 sharding-by-date
  6.通配取模sharding-by-pattern
 7.ASCI码求模通配 sharding-by-prefixpattern
  8.编程指定sharding-by-substring
  9.字符串拆分hash解析 sharding-by-stringhash
  10.一致性 hash sharding-by-murmur

工作过程

当mycat收到一个SQL命令时
  ①解析SQL命令涉及到的表
  ②然后看对表的配置，如果有分片规则，则获取SQL命令里分片字段的值，并匹配分片函数，获得分片列表
  ③然后将SQ命令发往对应的分片服务器去执行
  ④最后收集和处理所有分片结果数据，并返回到客户端

部署 MyCAT服务
具体要求如下
  1)数据库主机192.168.4.53使用db1库存储数据
  2)数据库主机192.168.4.54使用db2库存储数据
  3)数据库主机1921684.55使用db3库存储数据
  4)主机192.168456运行myat服务，逻辑库名称为
  TESTDB，连接用户名为admin，密码123456
  5)在主机192.168.4.50访问测试配置

IP规划
主机名        角色         数据库       IP地址
client50   客户端         无        192.1684.50/24
mycat56    分片服务器     无        192.1684.56/24
mysq53     数据库服务器   db1     192.168.4.53/24
mysq|54    数据库服务器   db2     192.1684.54/24
mysq55     数据库服务器   db3     192.1684.55/24


1. 部署 MyCAT服务
安装软件
安装JDK
系统自带的即可
[root@Mycat56-]# rpm -qa | grep -i jdk
java-18.0-openjdk-1.8.0.65-3.b17.e7x8664
例:
[root@cen056 ~]# rpm -qa | grep -i jdk  #查看安装的包
[root@cen056 ~]# rpm -e  --nodeps java-1.8.0-openjdk-headless-1.8.0.161-2.b14.el7.i686 #忽略依赖关系
[root@cen056 ~]# yum list | grep -i jdk
[root@cen056 conf]# yum -y install java-1.8.0-openjdk.x86_64
[root@cen056 conf]# ps -C java #查看Java进程
  PID TTY          TIME CMD
 1689 ?        00:00:02 java

2. 安装 mycat服务软件包
[root@cenos50 mysql]# scp Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz root@192.168.4.56:/
[root@Mycat56 ]tar -zxvf /Mycat-server-1.6-RELEASE-20161028204710-inux.tar.gz  #兔安装，解压即可使用
[root@Mycat]# mv mycat/ /usr/local/
[root@Mycat56 -]# ls /usr/local/mycat/
bin catlet conf lib logs version. txt
例:
[root@cen056 ~]# tar -zxvf /Mycat-server-1.6-RELEASE-20161028204710-linux.tar.gz  #解压包
[root@cen056 ~]# mv mycat /usr/local/  #解压后文件移动到/usr/local/目录下
[root@cen056 ~]# ls /usr/local/mycat   
bin  catlet  conf  lib  logs  version.txt

目录结构
ls /usr/local/mycat/
bin          #mycat命令
catlet       #扩展功能
conf         #配置文件
lib          #mycat使用的jar包
logs         #mycat启动日志和运行日志
wrappel.log  #mycat服务启动日志
mycat.log    #记录SQL脚本执行后的报错内容

重要配置文件说明
server.xml  #设置连接账号及逻辑
schema.xml  #配置数据分片
rule.xml    #分片规则
*.txt       #函数调月文件

创建连接用户
/usr/local/mycat/conf/server.xml
定义客户端连接mycat服务的用户
<user name="用户名>  #连mycat服务用户名
   < property name=" password">密码</ property> #用户密码
   < property name="schemas">库名</property>     #逻辑库
</user>
例:
[root@cen056 conf]# vim /usr/local/mycat/conf/server.xml
<user name="admin" ">
   <property name="password">123456</property>
   <property name="schemas">TESTDB</property>
   <property name=“readonly">true</property> #只读权限
</user>
[root@cen056 conf]# sed -i '56,77d' /usr/local/mycat/conf/schema.xml
[root@cen056 conf]# sed -i '39,42d' /usr/local/mycat/conf/schema.xml
[root@cen056 conf]# sed -i '16,18d' /usr/local/mycat/conf/schema.xml

2. 定义分片的表
<schema>...</schema>  #定义分片信息
name  #逻辑表
dataNode #指定数据节点名
rule  #指定使用的分片规则
type=global #数据不分片存储
<schema name="TESTDB ......>
   <table name="hotnews"primarykey=ID" dataNode=dn1,dn2,dn3" rule="mod-long" />
   <table name="company" primarykey="ID" type="global" dataNode="dn1,dn2,dn3" />
</schema>


3. 定义数据节点
<dataNode选项=值,……/>定义数据节点
name    #数据节点名
datahost #数据库服务器主机名
database #数据库名
<dataNode name="dn1" dataHost="mysql53" database="db1"/>
<dataNode name="dn2" dataHost="mysql54" database="db2"/>
<dataNode name="dn3" dataHost="mysql55" database="db3"/>
例:
[root@cen056 ~]# vim /usr/local/mycat/conf/schema.xml
<mycat:schema xmlns:mycat="http://io.mycat/">
.........
     <dataNode name="dn1" dataHost="localhost53" database="db1" />
     <dataNode name="dn2" dataHost="localhost54" database="db2" />
     <dataNode name="dn3" dataHost="localhost55" database="db3" />
........
</mycat:schema>


4. 定义数据库服务器地址及端口
<datahost 选项=值,...>......</datahost>  #服务器主机名
name      #主机名(与datahost对应的主机名)
host      #主机名(与IP地址对应的主机名)
url       #数据库服务器p地址及端口号
user      #数据库授权用户
password  #授权用户密码
<dataHost name=“localhost53"......>
   <heartbeat>select user()</heartbeat>
     <writeHost host="hostM1" url="192.168.4.53:3306"user=“用户名” password=“密码">
   </writeHost>
</dataHost>
例:
[root@cen056 ~]# vim /usr/local/mycat/conf/schema.xml
<mycat:schema xmlns:mycat="http://io.mycat/">
..........
        <dataNode name="dn1" dataHost="localhost53" database="db1" />
        <dataNode name="dn2" dataHost="localhost54" database="db2" />
        <dataNode name="dn3" dataHost="localhost55" database="db3" />

          #主机53
        <dataHost name="localhost53" maxCon="1000" minCon="10" balance="0"
                          writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
                <heartbeat>select user()</heartbeat>
                <writeHost host="hostM53" url="192.168.4.53:3306" user="adminplj"  password="123qq...A">
                </writeHost>
        </dataHost>
           #主机54
        <dataHost name="localhost54" maxCon="1000" minCon="10" balance="0"
                          writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
                <heartbeat>select user()</heartbeat>
                <writeHost host="hostM54" url="192.168.4.54:3306" user="adminplj"  password="123qq...A">
                </writeHost>
        </dataHost>
          #主机55
        <dataHost name="localhost55" maxCon="1000" minCon="10" balance="0"
                          writeType="0" dbType="mysql" dbDriver="native" switchType="1"  slaveThreshold="100">
                <heartbeat>select user()</heartbeat>
                <writeHost host="hostM55" url="192.168.4.55:3306" user="amdinplj"  password="123qq...A">
                </writeHost>
        </dataHost>
</mycat:schema>


5. 配置数据库服务器
根据分片配置做相应的设置
  添加授权用户
  刨建存储数据数据库db1、db2、db3
mysql> create database 数据库名;
mysql> grant all on *.* to 用户名@"%" identified by “密码"；  #添加授权用户
例:
[root@cenos53 ~]# mysql -u root -p123qq...A3 -e "create database db1"  #在命令行创建库
[root@cenos54 ~]# mysql -u root -p123qq...A4 -e "create database db2"
[root@cenos55 ~]# mysql -u root -p123qq...A5 -e "create database db3"
mysql> grant all on *.* to adminplj@"%" identified by "123qq...A";  #在53主机操作
mysql> grant all on *.* to adminplj@"%" identified by "123qq...A";  #在54主机操作
mysql> grant all on *.* to adminplj@"%" identified by "123qq...A";  #在55主机操作


6. 启动服务
1#cd /usr/local/mycat/bin/
1#./mycat --help
Usage: ./mycat { console | start | stop | restart | status | dump }
[root@host56 -]#/usr/local/mycat/bin/mycat start
Starting Mycat-server
Removed stale pid file: /usr/local/mycat/logs/mycat pid
[root @host56-]# netstat -utnlp | grep :8066
tcp600∷8066  LISTEN 8906/java
例:
[root@cen056 ~]# /usr/local/mycat/bin/mycat start  #启动服务
[root@cen056 ~]# netstat  -upntl | grep :8066      #查看端口
tcp6       0      0 :::8066  

=======================================================================================
分片规则

连接分片服务器存储数据
 具体要求如下
  1)连接分片服务器
  2)建表
  3)存储数据
  4)查看数据是否分片存储

1. sharding-by-intfile
枚举法: 字段值必须在列举范围内选择

<table name="employee" primaryKey="ID" dataNode=dnl,dn2,dn3" rule="sharding-by-intfile" />
<tableRule name="sharding-by-intfile>
    <rule>
        <columns>sharding_id</columns>
        <agorithm>hash-int</algorithm>
    </rule>
</tableRule>
例:
[root@cen056 ~]# vim /usr/local/mycat/conf/schema.xml
<schema name="TESTDB" checkSQLschema="false" sqlMaxLimit="100">
.......
<table name="employee" primaryKey="ID" dataNode="dn1,dn2,dn3" rule="sharding-by-intfile" />
.......
 </schema>
[root@cen056 ~]# vim /usr/local/mycat/conf/rule.xml
<tableRule name="sharding-by-intfile>
    <rule>
        <columns>sharding_id</columns>
        <agorithm>hash-int</algorithm>
    </rule>
</tableRule>

2)sharding-by-intfile
枚举法: 字段值必须在列举范围内选柽
<function name="hash-int" class="io.mycat.route.function.PartitionByFileMap">
   <property name="mapFile">partition-hash-int.txt </property>
</function>
]#vim /usr/local/mycat/conf/partition-hash-int.txt
10000=0  #数据存储到dn库里
10010=1   #数据存储到dn2库里
10020=2  #数据存储到dn3库里
例:
[root@cen056 ~]# vim /usr/local/mycat/conf/partition-hash-int.txt 
10000=0  #数据存储到dn库里
10010=1  #数据存储到dn2库里
10020=2  #数据存储到dn3库里

3).客户端连接
客户端连接分片服务器存取数据。
  连接
  选择库
  建表
  插入记录
]#myql -h 192.168.4.56 -P8066 uroot -p123456
mysql> show databases;
mysql> use TESTDB;
mysql> show tables;
mysql> desc employee;
ERROR 1146 (42502): Table 'db3 employee doesn't exist
mysql> exit
例:
[root@cenos50 ~]# mysql -h192.168.4.56 -P8066 -uroot -p123456
mysql> show databases;
+----------+
| DATABASE |
+----------+
| TESTDB   |
+----------+
mysql> use TESTDB; #切换到TESTDB库
mysql> create table  employee( ID int primary key , sharding_id int, name char(15) , age  int ); #创建employee表
mysql> desc TESTDB.employee; #在50主机查询
mysql> use TESTDB;  #在50主机切换
mysql> insert into employee(ID,sharding_id,name,age) values(2,10000,"zhai",18),(3,10010,"yan",19),(4,10020,"quan",20); #在50主机插入
mysql> select * from db1.employee;  #在53主机查询测试
mysql> select * from db2.employee;  #在54主机查询测试
mysql> select * from db3.employee;  #在55主机查询测试


2. mod-long
求模法: 根据字段值与设定的数字求模结果存储数据
]# vim /usr/local/mycat/conf/schema.xml
<table name="hotnews" primarykey="ID" autoIncrement="true dataNode="dn1,dn2,dn3" rule="mod-long" />

]# vim /usr/local/mycat/conf/rule.xml
<tableRule name="mod-long">
   <rule>
       <columns>id</columns>
       <algorithm>mod-long</algorithm>
   </rule>
</tableRule>

<function name="mod-long" class="io.mycat.route.function.PartitionByMod">
<!-- how many data nodes->
<property name="count">3</property>
</function>
例:
[root@cen056 ~]# vim /usr/local/mycat/conf/schema.xml
<mycat:schema xmlns:mycat="http://io.mycat/">
<schema name="TESTDB" checkSQLschema="false" sqlMaxLimit="100">
...
    <table name="hotnews"  dataNode="dn1,dn2,dn3" rule="mod-long" />
</schema>
...
</mycat:schema>

[root@cen056 ~]# vim /usr/local/mycat/conf/rule.xml
<mycat:rule xmlns:mycat="http://io.mycat/">
...
     <tableRule name="mod-long">
                <rule>
                        <columns>num</columns>
                        <algorithm>mod-long</algorithm>
                </rule>
        </tableRule>

        <function name="mod-long" class="io.mycat.route.function.PartitionByMod">
                <!-- how many data nodes -->
                <property name="count">3</property>
        </function>
...
</mycat:rule>
客户端测试
[root@cenos50 ~]# mysql -h192.168.4.56 -P8066 -uroot -p123456
mysql> use TESTDB;                                                       #切换到TESTDB库
mysql> create table hotnews(num int,title char(50),comment char(20));    #创建表hotnews
mysql> desc TESTDB.hotnews;                                              #查看表结构
mysql> insert into hotnews(num,title,comment) values(1,"fdsfds","eewr"); #插入数据


存储数据
建表: 根据分片规则和对应算法创建表结构
[root@cenos50 ~]# mysql -h192.168.4.56 -P8066 -uroot -p123456
mysal> use TESTDB;
mysql> create table employee(
    -> ID int primary key auto_increment,
    -> sharding_id int,
    -> name char(15)
    -> sex enum("boy"," girl"),
    -> pay float(7, 2));

mysql> create table hotnews(
    -> ID int primary key auto_increment,
    -> id int,
    -> title char(50),
    -> comment varchar(200));

存储数据
存储数据时必须指定字段名列表
[root@cenos50 ~]# mysql -h192.168.4.56 -P8066 -uroot -p123456
mysql> insert into employee(sharding_id, name, sex, pay) values(10000,"bob""boy",28000);
mysql> insert into employee(sharding_id, name, sex, pay) values(10010.jm","boy",28000);
mysql> insert into employee(sharding_ld, name, sex, pay) values(10020,"ucy"boy",28000);
mysql> insert into hotnews(id, title, comment) values(10, " linux","create web site");
mysql> insert into hotnews(id, title, comment values(7," php", "web page");
mysql> insert into hotnews(id, title, comment values(100, java","game script");

====================================================================================
添加新库新表

服务器配置
1).添加新库
   修改 server.xml文件
<user name="root">
   <property name="password">123456</property>
   <property name="schemas">TESTDB,BBSDB</property
</user>
例:
[root@cen056 ~]# vim /usr/local/mycat/conf/server.xml
<mycat:server xmlns:mycat="http://io.mycat/">
  <user name="root">
        <property name="password">123456</property>
        <property name="schemas">TESTDB,BBSDB</property>
  </user>
</mycat:server>

2).添加新表
修改schema.xml
<schema name="BBSDB" checkSQLschema"false"sqlMaxLimit="100">﻿
   <table name="student" primarykey="ID" dataNode="dnl,dn2,dn3" rule="sharding-by-intfile"/>
   <table name="company" primaryKey="ID" type="globl" dataNode="dn1,dn2, dn3" />
</schema>
例:
[root@cen056 ~]# vim /usr/local/mycat/conf/schema.xml
<mycat:schema xmlns:mycat="http://io.mycat/">
        <schema name="BBSDB" checkSQLschema="false" sqlMaxLimit="100">
                  <table name="company" primaryKey="ID" type="global" dataNode="dn1,dn2,dn3" />
                  <table name="employee" primaryKey="ID" dataNode="dn1,dn2,dn3" rule="sharding-by-intfile" />
        </schema>
</mycat:schema>

3).客户端访问
[root@cen056 ~]# mysql -h192.168.4.56 -P8066 -uroot -p123456  #root用户名和密码在server.xml设置(56主机)
mysql> use BBSDB;  #切换到BBSDB库
mysql> create table comany(ID int primary key,name char(50),addr char(50)); #创建comany表
mysql> show tables; 
mysql> insert into BBSDB.company(ID,name,addr) values(1,"zhai","gz"); #插入company表记录
mysql> insert into company(ID,name,addr) values(2,"zhai2","zj");      #插入company表记录
mysql> desc hotnews                                                   #查看表结构

rdbms2_day04======================================================================================

MHA集群

MHA简介

MHA(Master High Availability)
   由日本DeNA公司 youshimaton开发
   是一套优秀的实现 MySQLI高可用的解决方案
   数据库的自动故障切换操作能做到在0~30秒之内完成
  MHA能确保在故障切换过程中最大限度保证数据的一致性，以达到真正意义上的高可用。

MHA组成
MHA Manager(管理节点)
  管理所有数据库服务器
  可以单独部署在一台独立的机器上
  也可以部署在某台数据库服务器上
MHA Node(数据节点)
  存储数据的 MySQL服务器
  运行在每台MySQ服务器上

MHA工作过程
具体如下
  由Manager定时探测集群中的 master节点
  当master故障时， Manager自动将拥有最新数据的save提升为新的master

拓扑结构
IP规划
具体规划如下
P地址              主从同步角色      集群角色        主机名
192.168.4.50       客户端            无               client
192.168.4.51        主库             当前主库          Mysq51
192.168.4.52        从库             备用主库          Mysa52
192.168.4.53        从库             备用主库          Mysa53
192.168.4.57        无               管理主机           Mgm56
192.1684.100        无               ⅥP地址             无

拓扑图
主机总台数5台，角色如下
  客户端:1台
   数据库服务器:3台
   管理主机:1台
lient 50
IP:192.1684.100 主从从

=================================================================================
准备集群环境

准备MHA集群环境
   具体要求如下:
     根据拓扑要求创建虚拟主机
     配置SSH免空登录
     安装依赖包
     配置一主多从结构

1. 安装依赖包
在所有主机上安装系统自带的per软件包
]# yum -y install perl-*
例:
[root@cenos51 ~]# yum -y install perl-*
[root@cenos52 ~]# yum -y install perl-*
[root@cenos53 ~]# yum -y install perl-*
[root@cenos57 ~]# yum -y install perl-*
所有主机上安装共亨的per软件包
]# cd mha-soft-student
]# yum -y install perl-*
例:
[root@cenos50 ~]# for i in 51 52 53 57 ; do scp -r /03/mysql/mha-soft-student root@192.168.4.$i:/; done #将包上传到目标主机
[root@cenos51 ~]# cd /mha-soft-student                  #进入mha-soft-student目录(52,53,57相同步操作)
[root@cenos51 mha-soft-student]# yum -y install perl-*  #在mha-soft-student目录下安装包含perl包
[root@cenos52 mha-soft-student]# yum -y install perl-*  #在mha-soft-student目录下安装包含perl包
[root@cenos53 mha-soft-student]# yum -y install perl-*  #在mha-soft-student目录下安装包含perl包
[root@cenos54 mha-soft-student]# yum -y install perl-*  #在mha-soft-student目录下安装包含perl包
[root@cenos51 ~]# rpm -qa | grep -i perl | wc -l        #查看安装perl包的数量(在52,53,57主机相同操作)
382


2. 配置ssh密钥对认证登陆
  配置所有数据库服务器之间彼此ssh免密登录
  配置管理主机ssh免密登录所有数据库服务器
]#ssh-key-gen  #创建秘钥对
]#ssh- copy-id root@192.1684.X #拷贝公钥给目标主机
例:
[root@cenos51 ~]# ssh-keygen #创建秘钥对(此步骤在51,52,53相同操作)
[root@cenos51 ~]# for i in 51 52 53; do ssh-copy-id root@192.1684.$i; done  #拷贝公钥给51,52,53主机(此步骤在51,52,53相同操作)
[root@cenos57 ~]# ssh-keygen #创建秘钥对 
[root@cenos57 ~]# for i in 51 52 53; do ssh-copy-id root@192.1684.$i; done  #拷贝公钥给51,52,53主机


3. 配置一主多从同步结构
1).配置从库51(主服务器)
]# vim /etc/my.cnf
[mysqld]
server_id=51
log-bin=master51
]# systemctl restart mysqld
mysql> grant replication slave on *.* to 用户名@"%" identified by "密码";  #授权用户
mysql> grant all on *.* to 用户名@"%" identified by "密码";                    #监控同步用户
例: 
[root@cenos51 ~]# mysql -uroot -p123qq...A  #连接数据库服务器
mysql> grant replication slave on *.* to repluser@"%" identified by "123qq...a"; #授权用户(给两从服务器使用)
mysql> grant replication slave on *.* to mhauser@"%" identified by "123qq...a";  #数据同步用户
mysql> grant all on *.* to root@"%" identified by "123qq...a";                   #监控同步用户
[root@cenos51 ~]# vim /etc/my.cnf  #修改配置文件
[mysqld]
server_id=51
log-bin=master51
[root@cenos51 ~]# systemctl restart mysqld  #重启服务 
[root@cenos51 ~]# mysql -uroot -p123qq...A  #连接本地数据库
mysql> show master status;                  #显示当前用户最新日志
+-------------+----------+--------------+------------------+-------------------+------------------+---------------------------------+
| File        | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |
+-------------+----------+--------------+------------------+-------------------+------------------+---------------------------------+
| db51.000008 |      154 |              |                  |                   |
+-------------+----------+--------------+------------------+-------------------+------------------+---------------------------------+

2).配置从库52(第一台从库)
]# vim /etc/my.cnf
[mysqld]
server_id=52
]# systemctl restart mysqld
mysql> grant all on *.* to 用户名@"%" identified by "密码";                    #监控同步用户
mysql> grant replication slave on *.* to 用户名@"%" identified by "密码";  #授权用户
例:
[root@cenos52 ~]# vim /etc/my.cnf  #修改配置文件
[mysqld]
server_id=52
[root@cenos52 ~]# systemctl restart mysqld  #重启服务 
[root@cenos52 ~]# mysql -uroot -p123qq...A  #连接数据库服务器
mysql> grant all on *.* to root@"%" identified by "123qq...a";                   #监控同步用户
mysql> grant replication slave on *.* to mhauser@"%" identified by "123qq...a";  #数据同步用户
mysql> change master to
    -> master_host="192.168.4.51",     #主库ip地址
    -> master_user="repluser",         #主库授权用户
    -> master_password="123qq...a",    #授权用户密码(主的用户)
    -> master_log_file="db51.000008",  #主库日志文件(主的)
    -> master_log_pos=154;             #日志偏移量(主的)
mysql> start slave;                    #启动save进程
mysql> show slave status\G;            #确认IO线程、SQ线程都是Yes状态
或
[root@cenos52 ~]# mysql -uroot -p123qq...A -e "show slave status\G" | grep -i yes #确认IO线程、SQ线程都是Yes状态(可以在命令行查看)

2).配置从库53(第二台从库)
]# vim /etc/my.cnf
[mysqld]
server_id=53
]# systemctl restart mysqld  #重启服务 
mysql> grant all on *.* to 用户名@"%" identified by "密码";                    #监控同步用户
mysql> grant replication slave on *.* to 用户名@"%" identified by "密码";  #授权用户
例:
[root@cenos53 ~]# vim /etc/my.cnf
[mysqld]
server_id=53
[root@cenos53 ~]# systemctl restart mysqld  #重启服务
[root@cenos53 ~]# mysql -uroot -p123qq...A  #连接数据库服务器
mysql> grant all on *.* to root@"%" identified by "123qq...a";                   #监控同步用户
mysql> grant replication slave on *.* to mhauser@"%" identified by "123qq...a";  #数据同步用户
mysql> change master to
    -> master_host="192.168.4.51",     #主库ip地址
    -> master_user="repluser",         #主库授权用户
    -> master_password="123qq...a",    #授权用户密码(主的用户)
    -> master_log_file="db51.000008",  #主库日志文件(主的)
    -> master_log_pos=154;             #日志偏移量(主的)
mysql> start slave;                    #启动save进程
mysql> show slave status\G;            #确认IO线程、SQ线程都是Yes状态
或
[root@cenos53 ~]# mysql -uroot -p123qq...A -e "show slave status\G" | grep -i yes #确认IO线程、SQ线程都是Yes状态(可以在命令行查看)

===============================================================================================
配置管理节点

配置管理节点
   1.具体要求如下
   2.安装软件包
   3.创建主配置文件
   4.创建故障切换脚本
   5.主库部署vip地址

1. 安装软件包
   安装提供MHA程序的软件包
]# rpm -ivh mha4mysql-node-0.56-0.el6.noarch.rpm
]# tar -zxf mha4mysql-manager-056tar.gz
]# cd mha4 mysql-manager-056
]# perl Makefile.p
]# make
]# make install
例:
[root@cenos51 ~]# cd /mha-soft-student  #进入mha-soft-student目录(此步骤在52,53,57主机相同操作)   
[root@cenos51 mha-soft-student]# rpm -ivh mha4mysql-node-0.56-0.el6.noarch.rpm  #安装mha4mysql(此步骤在52,53,57主机相同操作)
或[root@cenos57 mha-soft-student]# yum -y install mha4mysql-node-0.56-0.el6.noarch.rpm
[root@cenos57 mha-soft-student]# tar -zxf mha4mysql-manager-0.56.tar.gz  #将mha4mysql-manager包解压在当前目录下(只在57管理主机操作)
[root@cenos57 mha-soft-student]# cd mha4mysql-manager-0.56 #进入mha4mysql-manager程序目录
[root@cenos57 mha4mysql-manager-0.56]# perl Makefile.PL  
[root@cenos57 mha4mysql-manager-0.56]# make && make install #源码编译安装

相关命令
管理集群命令
]# ls /usr/local/bin/masterha_*
[root@cenos57 ~]# ls /usr/local/bin/masterha_*
命令                                   作用
masterha_check_ssh      检查MHA的SH配置状况
masterha_check_repl     检查 MySQL复制状况
masterha_manager        启动MHA
masterha_check_status   检测MHA运行状态
masterha_stop           停止MHA


2. 编写主配置文件(在57管理主机操作)
·模板文件
mha4mysql-manager-0.56/samples/conf/appl.cnf
]# mkdir /etc/mha
]# vim /etc/mha/appl.cnf
[server default] #管理服务默认配置
   manager_workin=/etc/mha          #作目录
   manager_log=/etc/mha/manager.log #日志文件
   master_ipfailover_script=/etc/mha/master_ip_failover #故障切换脚本
   ssh_user=root            #访问ssh服务用
   ssh_port=22              #ssh服务端口
   repl_user=repluse        #同步数据授权用户
   repl_password=123qq...a  #密码
   user=root                #监控用户
   password=123qq...a       #密码

[server1]             #指定第1台数据库服务器
hostname=192.168.4.51 #服务器p地址
port=3306             #服务端口
candidate_master=1    #竞选主库

[server2]             #指定第2台数据库服务器
hostname=192.168.4.52 #服务器p地址
port=3306             #服务端口
candidate_master=1    #竞选主库

[server3]             #指定第3台数据库服务器
hostname=192.168.4.53 #服务器p地址
port=3306             #服务端口
candidate_master=1    #竞选主库
例:
[root@cenos57 conf]# mkdir /etc/mha
[root@cenos57 conf]# cp -r /mha-soft-student/mha4mysql-manager-0.56/samples/conf/app1.cnf /etc/mha/ 
[root@cenos57 ~]# vim /etc/mha/app1.cnp
[server default] #管理服务默认配置
   manager_workin=/etc/mha          #作目录
   manager_log=/etc/mha/manager.log #日志文件
   master_ipfailover_script=/etc/mha/master_ip_failover #故障切换脚本
   ssh_user=root            #访问ssh服务用
   ssh_port=22              #ssh服务端口
   repl_user=repluse        #同步数据授权用户(在51主机授权的用户)
   repl_password=123qq...a  #密码(在51主授权用户的密码)
   user=root                #监控用户(在51,52,53主机授权的用户)
   password=123qq...a       #密码(在51,52,53主授权用户的密码)

[server1]              #指定第1台数据库服务器
hostname=192.168.4.51  #服务器p地址
port=3306              #服务端口
candidate_master=1     #竞选主库

[server2]              #指定第2台数据库服务器
hostname=192.168.4.52  #服务器p地址
port=3306              #服务端口
candidate_master=1     #竞选主库

[server3]              #指定第3台数据库服务器
hostname=192.168.4.53  #服务器p地址
port=3306              #服务端口
candidate_master=1     #竞选主库


3. 创建故障切换脚本(在57管理主机操作)
修改master_ip_failover脚本,设置如下内容
   需手动添加如下代码
   添加执行权限
]# vim /etc/mha/master_ip_failover
   my $vip=“1921684.100/24”： #定义vip地址
   ny $key="1";               #定义地址编号
   my $ssh_start_vip="/sbin/ifconfig eth0:$key $vip"； #绑定vip地址
   my $ssh_stop-vip="/sbin/ifconfig eth0:$key down"；  #释放vip地址
]# chmod +x /etc/mha/master_ip_failover
例:
[root@cenos57 ~]# vim +35 /etc/mha/master_ip_failover #光标直接指到第35行
my $vip = '192.168.4.100/24';  #定义vip地址
my $key = "1";                 #定义地址编号
my $ssh_start_vip = "/sbin/ifconfig eth0:$key $vip";   #绑定vip地址
my $ssh_stop_vip = "/sbin/ifconfig eth0:$key down"     #释放vip地址
[root@cenos57 ~]# chmod +x /etc/mha/master_ip_failover #设置执行(x)权限


4. 部署VP地址(在51主库主机操作)
在主库部署VIP地址
]# ifconfig eth0:1 192.168.4.100
查看VP地址
]# ifconfig eth0:1
例:
[root@cenos51 ~]# ifconfig eth0:1 192.168.4.100  #部署VIP地址
[root@cenos51 ~]# ifconfig eth0:1                #查看VP地址

=========================================================================
配置数据节点

测试MHA集群
 具体要求如下:
   1.配置数据库服务器
   2.启动管理服务
   3.测试配置

1. 根据角色做相应配置
1).配置主库(在51主库数据服务器操作)
[root@cenos51 ~]# vim /etc/my.cnf
[mysqld]
plugin-load="rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so"  #加载模块
rpl_semi_sync_master_enabled=1 #启用maste模块
rpl_semi_sync_slave_enabled=1  #启用slave模块
relay_log_purge=0              #禁止自动删除中继日志文件
[root@cenos51 ~]# systemctl restart mysqld  #重启服务

2).配置备用主库52和53(在52和53从数据库服务器操作)
[root@cenos52 ~]# vim /etc/my.cnf  #修改配置文件(在52从数据库服务器操作)
[mysqld]
server_id=52
plugin-load="rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so" #加载模块
rpl_semi_sync_master_enabled=1  #启用maste模块
rpl_semi_sync_slave_enabled=1   #启用slave模块
relay_log_purge=0               #禁止自动删除中继日志文件
log-bin=master52
[root@cenos52 ~]# systemctl restart mysqld  #重启服务
[root@cenos53 ~]# vim /etc/my.cnf  #修改配置文件(在53从数据库服务器操作)
[mysqld]
server_id=53
plugin-load="rpl_semi_sync_master=semisync_master.so;rpl_semi_sync_slave=semisync_slave.so" #加载模块
rpl_semi_sync_master_enabled=1  #启用maste模块
rpl_semi_sync_slave_enabled=1   #启用slave模块
relay_log_purge=0               #禁止自动删除中继日志文件
log-bin=master53
[root@cenos53 ~]# systemctl restart mysqld  #重启服务


2. 测试配置
测试配置文件
1).在管理节点上测试ssh配置(在57管理节点主机操作)
]# masterha_check_ssh --conf=/etc/mha/app1.cnf
[info] All SSH connection tests passed successfully
例:
[root@cenos57 ~]# masterha_check_ssh --conf=/etc/mha/app1.cnp
All SSH connection tests passed successfully.

2).在管理节点上测试主从同步配置(在57管理节点主机操作)
]# masterha_check_repl --conf=/etc/mha/appl.cnf
MySQL Replication Health is OK.
例:
[root@cenos57 ~]# masterha_check_repl --conf=/etc/mha/app1.cnp
MySQL Replication Health is OK.


3. 启动 MHA_Manager
1).使用masterha_manager工具(在57管理节点主机操作)
--remove_dead_master_conf  #删除宕机主库的配置
--ignore_last_failover     #忽略xxx.health文件
]# masterha_manager --conf=/etc/mha/app1cnf --remove_dead_master_conf --ignore_last_failover
例:
[root@cenos57 ~]# masterha_manager --conf=/etc/mha/app1.cnp --remove_dead_master_conf --ignore_last_failover

2).查看状态： masterha_check_status (在57管理节点主机操作)
]# masterha_check_status --conf=/etc/mha/appl.cnf
appl(pid: 19513)is running(o: PING OK), master: 192. 168.4.51
例:
[root@cenos57 ~]# masterha_check_status --conf=/etc/mha/app1.cnp
app1 (pid:2743) is running(0:PING_OK), master:192.168.4.51

3).停止服务： masterha_stop (在57管理节点主机操作)
]# masterha_stop --conf=/etc/mha/appl.cnf
Stopped appl successfully.
[root@host56 bin]#
例:
[root@cenos57 ~]# masterha_stop --conf=/etc/mha/app1.cnp
Stopped app1 successfully.


4. 测试高可用
测试步骤
  停止主库51的数据库服务
  客户端仍然可以连接vip地址访问数据库服务
例:
在50主机客户端测试
[root@cenos50 ~]# mysql -h192.168.4.100 -uzyq -p123qq...zyq  #连接远程服务器
mysql> insert into day09.user values(1,"zhangsan");          #插入表记录
mysql> select * from day09.user;                             #查看表记录
+------+----------+
| id   | name     |
+------+----------+
|    1 | zhangsan |
+------+----------+

测试高可用
[root@cenos51 ~]# systemctl stop mysqld #停止主库数据服务器


添加51数据服务器配置成从库
[root@cenos51 ~]# systemctl restart mysqld
[root@cenos52 ~]# mysqldump -uroot -p123qq...A --master-data day09 >  day09.sql #将当前52主库数据库服务器day09库完全备份
[root@cenos52 ~]# scp -r day09.sql root@192.168.4.51:/ #将备份好的day09.sql拷贝到52数据库服务器
[root@cenos51 ~]# mysql -uroot -p123qq...A day09 < /day09.sql  #恢复51day09数据库的数据
[root@cenos51 ~]# mysql -uroot -p123qq...A  #连接51数据库服务器
mysql> change master to
    -> master_host="192.168.4.52",     #主库ip地址
    -> master_user="mhaluser",         #主库授权用户
    -> master_password="123qq...a",    #授权用户密码(主的用户)
    -> master_log_file="db52.000006",  #主库日志文件(主的)
    -> master_log_pos=154;             #日志偏移量(主的)
mysql> start slave;                    #启动save进程
mysql> show slave status\G;            #确认IO线程、SQ线程都是Yes状态
或
[root@cenos51 ~]# mysql -uroot -p123qq...A -e "show slave status\G" | grep -i yes #确认IO线程、SQ线程都是Yes状态(可以在命令行查看)
在57管理节点主机操作
[root@cenos57 ~]# masterha_stop --conf=/etc/mha/app1.cnp #首先停止服务
[root@cenos57 ~]# vim /etc/mha/app1.cnp                  #添加配置
[server1]
candidate_master=1
hostname=192.168.4.51
port=3306
[root@cenos57 ~]# masterha_check_ssh --conf=/etc/mha/app1.cnp   #测试ssh配置
[root@cenos57 ~]# masterha_check_repl --conf=/etc/mha/app1.cnp  #测试主从同步配置
[root@cenos57 ~]# masterha_manager --conf=/etc/mha/app1.cnp --remove_dead_master_conf --ignore_last_failover #启动服务
[root@cenos57 ~]# masterha_check_status --conf=/etc/mha/app1.cnp  #开另窗口查看状态


配置步骤总结
  1.配置SSh密钥认证登陆
  2.配置 MySQL一主多从
  3.安装软件包
  4.配置管理节点
  5.启动管理服务
  6.测试配置
  7.测试故障转移


rdbms2_day05======================================================================================

测试配置

注意: 不需要安装mysql有关的包

PXC介绍
Percona XtraDB Cluster(简称PXC)
  是基于Galera的mysq高可用集群解决方案
  Galera Cluster是Codership公司开发的一套免费开源的高可用方案
  PXC集群主要由两部分组成： Percona Server with XtraDB和Write Set Replication patches(同步、多主复制插件)
  官网http://galeracluster.com


PXC特点
具体如下:
  数据强致性、无同步延迟
  没有主从切换操作，无需使用虚IP
  支持 InnoDB存储引擎
  多线程复制
  部害使用简单
  支持节点自动加入，无需手动拷贝数据


相应端口
服务端口
端口        说明
3306        数据库服务端口
4444      SST端口
4567        集群成员通信端口
4568      IST端口
SST       State Snapshot Transfer全量同步
IST       In cremental state transfer增量同步

主机角色
三台服务器
主机名                IP地址                  角色
pxcnode71      192.168.4.71        数据库服务器
pxcnode72      192.168.4.72        数据库服务器
pxcnode73      192.168.4.73        数据库服务器
]# vim /etc/hosts
192.168.4.71  pxcnode71
192.168.4.72  pxcnode72
192.168.4.73  pxcnode73
例:
[root@pxcnode71 ~]# vim /etc/hosts #在72和73主机相同操作
192.168.4.71  pxcnode71
192.168.4.72  pxcnode72
192.168.4.73  pxcnode73

=====================================================================================
部署PXC

安装软件
  具体配置如下:
    1)环境准备
    2)安装软件包

安装软件
软件介绍
     软件                                                                           作用
percona-xtrabackup-24-2.4.13-1.el7.x86_64.rpm                  在线热备程序
qpress-1.1-14.11.X86_64.rpm                                    递归压缩程序
Percona-XtraDB-Cluster-server-57-5.7.25-31.35.1.el7.x8664.rpm  集群服务程序
[root@pxcnode71 PXC]# yum -y install percona-xtrabackup-24-2.4.13-1.el7.x86_64.rpm


安装软件
  3台服务器分别安装
]# rpm -ivh libel4.15-1.el6.rfx86_64.rpm  #安装依赖
]# yum - y install percona-xtrabackup-24-2413-1.el7x86_64.rpm
]# rpm -ivh apress-1.1-14.11.×86_64.rpm   #安装依赖
1# tar -xvf Percona-XtraDB-Cluster-5725-31.35-r463-el7-x86 64-bundle.tar
]# yum -y install Percona-XtraDB-Cluster-*.rpm
例:
[root@cenos50 ~]# for i in 71 72 73 ; do scp -r /03/PXC/ root@192.168.4.$i:/; done  #将PXC里安装包分别上传到71,72和73主机上
72主机和73主机相同操作
[root@pxcnode71 ~]# cd /PXC
[root@pxcnode71 PXC]# rpm -ivh libev-4.15-1.el6.rf.x86_64.rpm  #安装依赖
[root@pxcnode71 PXC]# yum -y install percona-xtrabackup-24-2.4.13-1.el7.x86_64.rpm
[root@pxcnode71 PXC]# rpm -ivh qpress-1.1-14.11.x86_64.rpm     #安装依赖
[root@pxcnode71 PXC]# tar -xvf Percona-XtraDB-Cluster-5.7.25-31.35-r463-el7-x86_64-bundle.tar
[root@pxcnode71 PXC]# yum -y install Percona-XtraDB-Cluster-*.rpm

=====================================================================================================
配置服务

配置服务
  具体配置如下:
  1.修改 mysqld cnf。文件
  2.修改 mysqld_safe。cn件
  3.修改 sRap cnf文件
  4.启动服务


1. 相关配置文件
/etc/percona-xtradb-cluster.conf.d/  #所在目录
1).配置文件说明
mysqld.cnf       #数据库服务运行参数配置文件
mysqld_safe.cnf  #Percona server5.7配置文件
wsrep.cnf        #PXC集群配置文件

2).修改数据库服务运行参数配置文件
mysqld.cnf
重要配置项说明
[Mysqld]
server-id=1                           #server-id不允许重复
datadir=/var/lib/mysql                #数据库目录
socket=/var/ib/mysql/mysql.sock       #socket文件
log-error=/var/log/mysqld.log         #日志文件
pid-file=/var/run/ mysqld/mysqld.pid  #pid文件
log-bin                               #启用binlog日志
log_slave_updates                     #启用链式复制
expire_logs_days=7                    #日志文件保留天
例:
72主机和73主机相同操作
[root@pxcnode71 ~]# vim /etc/percona-xtradb-cluster.conf.d/mysqld.cnf 
[mysqld]
server-id=71                         #server-id不允许重复(71或72或73)
datadir=/var/lib/mysql               #数据库目录
socket=/var/lib/mysql/mysql.sock     #socket文件
log-error=/var/log/mysqld.log        #日志文件
pid-file=/var/run/mysqld/mysqld.pid  #pid文件
log-bin                              #启用binlog日志
log_slave_updates                    #启用链式复制
expire_logs_days=7                   #日志文件保留天

3).修改 Percona server5.7配置文件
mysqld_sate.cnf
重要配置项说明
使用默认配置即可
72主机和73主机相同操作(查看即可)
[root@pxcnode71 ~]# vim /etc/percona-xtradb-cluster.conf.d/mysqld_safe.cnf
[mysqld_safe]
pid-file = /var/run/mysqld/mysqld.pid  #文件位置及名称
socket   = /var/lib/mysql/mysql.sock   #文件位置及名称
nice     = 0

4).修改PXC集群配置文件
  wsrep.cnf
  重要配置项说明
]# wsrep_cluster_address=gcomm://192.168.4.71,192.168.4.72,192.168.4.73  #集群成员列表
wsrep_node_address=192.168.4.71  #体本机ip地址
wsrep_cluster_name=pxc-cluster   #集群名称3台必须相同
wsrep_node_name=pxcnode71        #本机主机名
wsrep sst auth=sstuser:"123456"  #数据同步授权用户
例:
在72主机和73主机相同操作
[root@pxcnode71 ~]# vim /etc/percona-xtradb-cluster.conf.d/wsrep.cnf
wsrep_cluster_address=gcomm://192.168.4.71,192.168.4.72,192.168.4.73  #集群成员列表(71主机和72主机和73配置相同)
wsrep_node_address=192.168.4.71  #体本机ip地址
wsrep_cluster_name=pxc-cluster   #集群名称3台必须相同
wsrep_node_name=pxcnode71        #本机主机名
wsrep_sst_auth="sstuser:123456"  #数据同步授权用户

5).启动服务
在1台服务器上执行即可(192.168.4.71)
  启动集群服务
  添加授权用户
]# systemctl start mysql@ bootstrapservice  #启动集群服务
]# grep pass /var/log/mysqld.log            #看数据库管理员初始登录密码
]# mysql -uroot -p'A3+= HiEggK>B′           #使用初始密码登录
mysql> alter user root@"localhost" identified by "123456"  #修改登录密码
mysql> grant reload,lock tables,replication client,process on *.* to sstuser@"localhost" identified by “123456″;  #添加授权用户
例:
[root@pxcnode71 ~]# systemctl start mysql@bootstrap.service    #启动集群服务(在1台服务器上执行即可,如:192.168.4.71)
[root@pxcnode71 ~]# grep pass /var/log/mysqld.log              #看数据库管理员初始登录密码
[root@pxcnode71 ~]# mysql -uroot -p"&tx1-rg!dJoV"              #使用初始密码登录(在71主机操作即可)
mysql> alter user root@"localhost" identified by "123qq...A";  #修改登录密码(在71主机操作即可)

6).在其他2台服务器上执行
启动数据库服务
会自动同步71主机的授权用户及管理员roo密码
]# systemctl start mysql  #启动数据库服务
在所有服务器上查看
]# netstat -utnlp | grep :3306
]# netstat -utnlp | grep :4567
例:
[root@pxcnode72 ~]# systemctl start mysql  #启动服务
[root@pxcnode73 ~]# systemctl start mysql  #启动服务
在所有服务器上查看
[root@pxcnode71 ~]# netstat -utnlp | grep :3306
[root@pxcnode71 ~]# netstat -utnlp | grep :4567

7).测试配置
查看集群信息
执行SQL命令 show status like"%wstep%;
相关参数
wsrep_incoming_addresses
192.168.4.71:3306,192.168.4.73:3306,192.168.4.72:3306  #成员列表
wsrep_cluster_size    3        #集群服务器台数
wsrep_cluster_status  Primary  #服务器状态
wsrep connected       ON       #连接状态
wsrep read            ON       #集群状态
例:
[root@pxcnode71 ~]# mysql -uroot -p123qq...A  #登录数据库(在71主机查看即可)
mysql> show status like "%wsrep%";

8).测试集群功能
  在任意一台服务器上添加访问数据的授权用户
  在客户端使用授权用户连接任意数据库服务器都可以
  存储数据，且可以查看到同样的数据
  建表时，必须有主键字段
mysq> grant all on 库名.* to 用户@"%"  identified by "密码";
]# mysq -h数据服务器ip地址 -u用户名 -p密码  #访问集群
例:
[root@pxcnode71 ~]# mysql -uroot -p123qq...A  #登录数据库
mysql> grant all on day09.* to pxc@"%" identified by "123qq...pxc";    #授权用户(在71主机操作即可)
[root@cenos50 ~]# mysql -h192.168.4.72 -upxc -p123qq...pxc             #客户端连接数据库访问集群(连接ip可71和73)
mysql> create table day09.user3(id int(4) primary key,name char(10));  #建表时，必须有主键字段
mysql> insert into day09.user3(id,name) values(1,"zhai");              #插入字段
mysql> insert into day09.user3 values(2,"zyq");

9).测试故障自动恢复
  任何1台数据库服务器宕机都不影响用户存取数据
  服务器运行后自动同步宕机期间的数据

测试配置
 具体配置如下:
 1)查看服务信息
 2)测试集群功能
 3)测试故障自动恢复

==============================================================================================
MySQL存储引擎

MySQL存储引擎
  具体要求如下:
  1.查看服务支持的存储引擎
  2.修改服务使用的存储引擎
  3.查看表使用的存储引擎
  4.修改表存储引擎

1. 存储引擎概述
1).作为可插拔式的组件提供
  MySQL服务软件自带的功能程序，处理表的处理器
  不同的存储引擎有不同的功能和数据存储方式
  MySQL 5.075.1  ---> MyISAM
  MYSQL 5.5/5.6  ---> InnoDB

2).列出可用的存储引擎类型
show engines;
mysql> show engines; #列出可用的存储引擎类型
| InnoDB             | DEFAULT | Percona-XtraDB,

3).修改表存储引擎
建表时手动指定
  未指定时使用默认存储引擎
 show create table 表名\G;
mysql> create table day09.user(id int(5) primary key,name char(20))engine=myisam;  #建表时指定存储引擎
mysql> show create table day09.user\G;  #查询使用的存储引擎
 ENGINE=MyISAM DEFAULT CHARSET=latin1
mysql> alter table day09.user engine=innodb; #修改表的存储引擎
mysql> show create table day09.user\G;       #查询使用的存储引擎
) ENGINE=InnoDB DEFAULT CHARSET=latin1

4).修改服务存储引擎
设置数据库服务使用的存储引擎
  修改/etc/my.cnf配置文件
[root@dbsvr1]# vim /etc/my.cnf
[mysqld]
....
default-storage-engine=存储引擎
[root@dbsvr1]# systemctl restart mysqld
Shutting down MySQL...
Starting MysQl...
例:
[root@cenos50 ~]# vim /etc/my.cnf #修改数据库服务使用的存储引擎(永久配置)
[mysqld]
default-storage-engine=myisam               #修改服务存储引擎
[root@cenos50 ~]# systemctl restart mysqld  #重启服务

=============================================================================================
存储引擎特点

具体操作如下:
  创建innodb存储引擎的表
  关闭服务的自动提交功能
  对表执行插入 更新 删除记录的操作
  测试事务特性

myisam存储引擎
主要特点:
   支持表级锁
   不支持事务、事务回滚、外键
表文件:
   表名frm   #表结构
   表名.MYI  #索引
   表名.MYD  #数据

innodb存储引擎
主要特点: 
    支持行级锁定
    支持事务、事务回滚、外键
表文件:
   表名.frm 
   表名.ibd
事务日志文件:
  bdata1
  b_logfile0
  b_logfile1

MySQL锁机制
锁粒度:
   表级锁：对整张表加锁
   行级锁：仅对被访问的行分别加锁

锁类型:
  读锁(共享锁)：支持并发读
  写锁(互斥锁、排它锁)：是独占锁，上锁期间其他
  线程不能读表或写表
查看当前锁状态
  show status like "%table_lock%";
mysql> show status like "%table_lock%";

事务特性(ACID)
Atomic：原子性
   事务的整个操作是一个整体,不可分割，要么全部成功，要么全部失败
Consistency: 一致性
   事务操作的前后，表中的记录没有变化
Isolation：隔离性
   事务操作是相互隔离不受影响的，
Durability：持久性
   数据旦提交，不可改变，永久改变表数据

相关命令
mysql> show variables like "autocommit";  #查看提交状态
mysql> set autocommit=off  #关闭自动提交
mysql> rollback            #数据回滚
mysal> commit              #提交数据

11.nosql==============================================================================
nosql_day01===========================================================================

数据库类型

RDBMS
关系数据库管理系统
Relational Database Management system
  按照预先设置的组织结构，将数据存储在物理介质上
  数据之间可以做关联操作
RDBMS软件
主流的 RDBMS软件
  Oracle
  DB2
  MS SOL Server
  MySQL、MariaDB

NoSQL(NosQL NOSQL Not Only SQL)
  意思是“不仅仅是SQL"
  泛指非关系型数据库
  不需要预先定义数据存储结构
  每条记录可以有不同的数据类型和字段个数

NoSQL软件
 主流软件:
   Redis
   MongoDB
   Memcached
   CouchDB
   Neo4j
   FlockDB


部署 Redis服务
Redis介绍
Redis
  Remote Dictionary Server(远程字典服务器)
  是一款高性能的(Key/ Values)分布式内存数据库
  支持数据持久化；定期把内存里数据存储到硬盘
  支持多种数据类型 string、ist、hash
  支持 master- salve模式数据备份
  中文网站www.redis.cn


搭建Redis服务器
具体要求如下:
   在主机192.168.4.50和192.168.4.51 上安装并启动redis服务
   设置变量 school，值为tarana
   查看变量 schoo值


1. 安装软件
源码编译安装
]# rpm -q gcc || yum -y install gcc
]# tar -zxvf redis-4.0.8.tar.gz
]# cd redis-4.0.8
]# make
]# make install
例:
在192.168.4.51主机上相同操作
[root@cenos50 ~]# rpm -q gcc || yum -y install gcc  #安装gcc包
[root@room9pc01 ~]#  scp -r /redis-4.0.8.tar.gz root@192.168.4.50:/  #将redis-4.0.8.tar.gz上传到主机50和51
[root@cenos50 ~]# mkdir /redis  #创建目录redis
[root@cenos50 ~]# tar -zxvf /redis-4.0.8.tar.gz -C /redis
[root@cenos50 redis]# cd redis-4.0.8
[root@cenos50 redis-4.0.8]# make && make install #编译安装


2. 初始配置
1).配置服务运行参数
]# ./utils/install_server.sh  #初始化
端口            6379
主配置文件     /etc/reds/6379.cnf
日志文件       /var/og/reds6379.log
数据库目录     /ar/ib/ redis/6379
服务启动程序   /usr/loca/bin/redis-server
命令行连接命令 /uSr/local/bin/redis-cli
例:
在192.168.4.51主机上相同操作
[root@cenos50 redis-4.0.8]# ./utils/install_server.sh #初始化(一路回车,端口路径可以自定义)
[root@cenos50 ~]# netstat -nutlp | grep :6379

2).管理服务
]# /etc/init.d/redis_6379  stop  #停止服务
]# /etc/init.d/redis_6379 start  #动服务
]# ps -C redis-server            #查看进程
]# netstat -utnlp | grep :6379   #看端口
例:
在192.168.4.51主机上相同操作
[root@cenos50 ~]# /etc/init.d/redis_6379 stop   #停止服务
[root@cenos50 ~]# /etc/init.d/redis_6379 start  #动服务
[root@cenos50 ~]# ps -C redis-server            #查看进程
[root@cenos50 ~]# netstat -utnlp | grep :6379   #看端口

3).连接服务
访问redis服务
  redis-cli 默认连接本机的Redis服务
[root@ahost50 redis-4.0.8]# redis-cli
27.0.0.1:6379>ping
PONG
127001: 6379> set name bob  #存数据
OK
127.0.0.1:6379> get name    #取数据
"bob"
1270.0.1:6379>ext           #断开连接
例:
在192.168.4.51主机上相同操作
[root@cenos50 ~]# redis-cli  #连接本机的Redis服务
127.0.0.1:6379> ping
PONG
127.0.0.1:6379> set name bob  #存数据
OK
127.0.0.1:6379> get name      #取数据
"bob"
127.0.0.1:6379> exit          #断开连接


常用命令
set keyname keyvalue #存储1个key值
mset                 #储多个key值
get keyname          #获取key值
mget                 #获取多个key值
select 数据库编号0-15   #切换库
keys *               #显示所有key名
keys a?              #显示指定key名
exists keyname       #测试key名是否存在
ttl keyname          #查看key生存时间
type keyname         #查看key类型
move keyname dbname  #移动key到指定库
expire keyname 10    #设置key有效时间
del keyname          #删除指定的key
flushall             #删除内存里所有key
flushdb              #删除所在库的所有key
save                 #保存所有key到硬盘
shutdown             #停止服务
例:
[root@cenos50 ~]# redis-cli            #连接本机的Redis服务
127.0.0.1:6379> set zhai 100           #存储1个key值
127.0.0.1:6379> mset yan 200 quan 300  #储多个key值
127.0.0.1:6379> get zhai               #获取key值(获取一个)
"100"
127.0.0.1:6379> mget zhai yan  #获取多个key值
1) "100"
2) "200"
127.0.0.1:6379> select 1     #切换库(默认是0库)
127.0.0.1:6379[1]> select 0  #切换库
127.0.0.1:6379> keys *       #显示所有key名
1) "zhai"
2) "quan"
3) "yan"
4) "name"
127.0.0.1:6379> exists yan   #测试key名是否存在
(integer) 1                  #1表示存在
127.0.0.1:6379> exists ya    #测试key名是否存在
(integer) 0                  #0表示不存在
127.0.0.1:6379> ttl yan      #查看key生存时间
(integer) -1                 #-1表示永久在内存里(关服务或重启失效)
127.0.0.1:6379> type zhai    #查看key类型
string                       #字符串类型
127.0.0.1:6379> move quan 1  #移动key到指定库
127.0.0.1:6379> keys *       #查看当前库所有key值
1) "zhai"
2) "yan"
3) "name"
127.0.0.1:6379> select 1   #切换到1库
127.0.0.1:6379[1]> keys *  #显示所有key名
1) "quan"
127.0.0.1:6379[1]> select 0    #切换到0库
127.0.0.1:6379> expire yan 30  #设置key有效时间(yan30秒后失效)
127.0.0.1:6379> ttl yan        #查看key生存时间
(integer) 14  #14表示生存时间还有14秒
127.0.0.1:6379> ttl yan  #查看key生存时间
(integer) -2             #-2表示y已消失
127.0.0.1:6379> keys *   #显示所有key名
1) "zhai"
2) "name"
127.0.0.1:6379> keys *  #查看当前库所有key值
1) "zhai"
2) "name"
3) "bob"
4) "twet"
5) "tim"
127.0.0.1:6379> del bob twet  #删除指定的key
(integer) 2                   #2表示删除了2个
127.0.0.1:6379> keys *        #查看当前库所有key值
1) "zhai"
2) "name"
3) "tim"
127.0.0.1:6379> flushall  #删除所在库的所有key
127.0.0.1:6379> save      #保存所有key到硬盘
127.0.0.1:6379> shutdown  #停止服务
not connected> 
[root@cenos50 ~]# /etc/init.d/redis_6379 start  #启动服务


常用命令
练习如下命令的使用:
  set mset get mget keys type
  exists ttl expire move
  del flushdb flushal save shutdown


=======================================================================
配置文件解析

修改Redis服务运行参数
  具体要求如下： 
     端口号6350
    IP地址1921684.50
     连接密码123456
     测试配置

配置分类
具体如下
名称                     说明
NETWORK             网络
GENERAL             常规
SNAPSHOTTING        快照
REPLICATION         复制
SECURITY            安全
CLIENTS             客户端
MEMORY MANAGEMENT   内存管理


数据单位
# 1k => 1000 bytes
# 1kb => 1024 bytes
# 1m => 100000 bytes
# 1mb => 1024*1024 bytes
# 1g => 1000000000 bytes
# 1gb => 1024*1024*1024 bytes
# units are case insensitive so 1GB 1Gb 1gB are all the same


常用配置
port 6379                       #端口
bind 127.0.0.1                  #P地址
daemonize yes                   #守护进程方式运行
databases 16                    #数据库个数
logfile /var/log/redis6379.log  #日志文件
maxclients 10000                #并发连接数量
dir /var/lib/redis/6379         #数据库目录

内存管理
达内教育
 内存清除策略
  volatile-lru  #近最少使用(针对设置了TL的key)
  allkeys-lru   #删除最少使用的key针对所有的key
  volatile-lfu  #所有key中清除使月频率最少的key
  allkeys-lfu   #从所有配置了过期时间的key中清除使用频率最少的key
  volatile-random          #在设置了T的key里随机移除
  allkeys-random           #随机移除key
  volatile-ttl(minor TTL)  #移除最近过期的ke
  eviction                 #不删除,写满时报错

优化设置
  maxmemory           #最大内存
  maxmemory-policy    #定义使用策略
  maxmemory- samples  #取key模板的个数(针对u和tt策


1. 连接密码
设置密码、ip地址、端口
]# vim /etc/redis/6379.conf
   requirepass 123456
   bind 192.168.4.50
   port 6350
]# redis-cli -h 192.168.4.50 -p 6350 #连接服务
]# redis-cli -h 192.168.4.50 -p 6350 -a 123456 shutdown  #停止服务
例:
[root@cenos50 ~]# /etc/init.d/redis_6379 stop #先停止服务(可以自动删除redis_6379.pid)
[root@cenos50 ~]# vim /etc/redis/6379.conf
70 bind 192.168.4.50
93 port 6350
501 requirepass 123456  
[root@cenos50 ~]# rm -rf /var/run/redis_6379.pid                     #重启服务时，如果报错pid存在，执行此步
[root@web1 ~]# redis-cli -h 192.168.4.50 -p 6350 -a 123456 shutdown  #停止IP连接服务
[root@cenos50 ~]# /etc/init.d/redis_6379 start                       #重启动服务
[root@cenos50 ~]# redis-cli -h 192.168.4.50 -p 6350 -a 123456        #连接时加密码
192.168.4.50:6350> ping
PONG  #PONG表示正常
修改脚本使/etc/init.d/redis_6379 stop可用
[root@cenos51 ~]# vim +43 /etc/init.d/redis_6379
$CLIEXEC -h 192.168.4.51 -p 6350 -a 123456 shutdown
[root@cenos51 ~]# /etc/init.d/redis_6379 stop 


================================================================
部署LNMP

1. 安装软件
安装源码ngnx及 php-fpm
]# yum -y install gcc pcre-devel zlib-devel
]# tar -zxvf nginx-1.1.2.2.tar.gz
]# cd nginx-1122
]# /configure
]# make
]# yum -y install php-fpm-5416-42 el7 x86_64. rpm
例:
[root@nosql71 ~]# yum -y install gcc pcre-devel zlib-devel
[root@nosql71 redis]# cd /redis/lnmp  #进入文件目录下
[root@nosql71 lnmp]# tar -zxvf nginx-1.12.2.tar.gz


修改配置
达内教育
修改 ngInx服务主配置文件
1# vim +65 /usr/local/nginx/conf/nginx. conf
location w \php$
知识讲
html.
fastcgi_pass 127.0.0.1: 9000
fastcgi_index index.php
4#fastcgi_param SCRIPT_FILENAME/scriptsSfastcgi_ script_name:
include fastcgi. conf;
.w9
1# /usr/local/nginx/sbin/nginx -t
则试修改

seduce
启动服务
达内教育
启动 ngInx服务
1#/usr/local/nginx/sbin/nginx
t netstat -utnlp grep 80
//查看端口
·启动phpm服务
1# systemctI start php-fpm
1# netstat -utnlp grep 9000
//查看端口
Seduce
测试配置
达内教育
编写测试文件
1* vim /usr/local/nginx/html/test. php
p
echo "hello world!
知识讲解
访问 ngInx服务
I#curlhttp://localhost/test.php
hello world! !
equ.c
达内教育
配置支持 Redis

eau.cn
运行 Redis服务
达内教育
装包并启动服务
tar -xZf redis-4.0.8. tar. gz
cd redis-4.0.8
make
知识讲解
make instal
#/utils/install server.sl
//初始化
#/etc/init. d/redis 6379 status
edt
配置支持 Redis
达内教育
安装php扩展
1# yum -y install php php-devel
rpm -q autoconf automake
#n 1# tar -Zxf php-redis-2.2. 4. tar.gz
识# cd phpredis-224/
讲
解]# phpize∥成配置文件 php-config及， configure命令
/configure --with-php-config=/usr/bin/php-config
make
1# make install
1 vim /etc/php. ini
728： extension dir=“目录名”；/模莫块目录
730： extension=“模块名”；/模块名
1# systemc restart php-tpi
educ
测试配置
达内教育

编写、部署测试文件，查看访问结果
]#php-m grep -i redis
//检查是否支持模块
知识讲解
#vm/usr/loca/ nginx/htm/ /redis。 php/编写测试文件
php
Redis= new redis:
$ redis-> connect(“IP地址
端口”)
$ redis->auth(“密码
redis->set(" Linux"，" redhat")；/存数据
echo Redis->get( Linux")；/取数据
1#curlhttp://localhost/redis.php
/方问 nginx服务
redhat

案例4：部署LNMP+ Redis
1.具体要求如下
2.部署LNMP环境
3.配置php支持 redis
4.测试配置


服务无法关闭
问题现象
达内教育
故障错误信息
service
redis_6379 stop
Waiting for Redis to shutdown
知识讲解
(error)NOAUTH Authentication required
原因分析
达内教育
分析故障信息
设置reds主从后，连接主服务器需要密码
而 redis启动脚本中未设置密码
知识讲解
分析故障原因
reds启动脚本通过执行 redis-cli-p6379 shutdown
关闭 redis，因此没有密码是无法关闭服务的
修改脚本reds-c-p6379-a密码 shutdown




[root@cenos50 ~]# vim /etc/redis/6379.conf
501 requirepass 123456
[root@cenos50 ~]# /etc/init.d/redis_6379 stop
[root@cenos50 ~]# /etc/init.d/redis_6379 start
[root@cenos50 ~]# redis-cli
127.0.0.1:6379> auth 123456 


71主机
[root@nosql71 ~]# vim +65 /usr/local/nginx/conf/nginx.conf
    location ~ \.php$ {
            root           html;
            fastcgi_pass   127.0.0.1:9000;
            fastcgi_index  index.php;
          #  fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;
            include        fastcgi.conf;
        }
[root@nosql71 ~]# /usr/local/nginx/sbin/nginx -s stop
[root@nosql71 ~]# /usr/local/nginx/sbin/nginx -t
[root@nosql71 ~]# /usr/local/nginx/sbin/nginx
[root@nosql71 ~]# netstat -untpl | grep :80
[root@nosql71 ~]# systemctl start php-fpm
[root@nosql71 ~]# netstat -untpl | grep :9000
[root@nosql71 ~]# vim /usr/local/nginx/html/test.php
<?php
    echo "zhaiyanquan";
?>
[root@nosql71 ~]# curl http://localhost/test.php
[root@nosql71`	 ~]# yum -y install php php-devel autoconf automake
[root@nosql71 ~]# cd /redis/
[root@nosql71 redis]# cd lnmp/
[root@nosql71 lnmp]# tar -zxf php-redis-2.2.4.tar.gz
[root@nosql71 lnmp]# cd  phpredis-2.2.4
[root@nosql71 phpredis-2.2.4]# phpize
[root@nosql71 phpredis-2.2.4]# ./configure --with-php-config=/usr/bin/php-config
[root@nosql71 phpredis-2.2.4]# make && make install
Installing shared extensions:     /usr/lib64/php/modules/
[root@nosql71 ~]# vim +728 /etc/php.ini
728 extension_dir = "/usr/lib64/php/modules/"  #模块目录
730 extension = "redis.so"  #模块名
[root@nosql71 ~]# sed -n "728p;730p" /etc/php.ini #查看修改内容
[root@nosql71 ~]# systemctl restart php-fpm
[root@nosql71 ~]# cd /redis/lnmp 
[root@nosql71 lnmp]# cp linkredis.php /usr/local/nginx/html 
[root@nosql71 lnmp]# curl http://localhost/linkredis.php

nosql_day02===========================================================================

集群环境

部署 redis集群
 具体要求如下:
   1.准备集群环境
   2.部署管理主机
   3.配置 redis服务器
   4.创建集群
   5.查看集群信息
   6.测试配置


redis服务器:6台
管理主机:1台
IP规划
redis服务器IP地址及端口规划
redisA 192.168.4.51 6351
redisB 192.168.4.52 6352
redisC 192.168.4.53 6353
redidD 192.168.4.54 6354
redisE 192.168.4.55 6355
redisF 192.168.4 56 6356
MGM 192.168.4.57 无

1. 准备集群环境
[root@room9pc01 ~]# for i in {51...56}  #将redis-4.0.8.tar.gz包分别上传51redisa,redisb,redisc,redisd,redise,redisf,redis58和redis59服务器上
> do
> /run/media/root/ZHAIYANQUAN/NSD1903/11.nosql/day1/redis-4.0.8.tar.gz root@192.168.4.$i:/
> done
在redisb,redisc,redisd,redise,redisf,redis58和redis59服务器上相同操作
[root@redisa ~]# rpm -q gcc || yum -y install gcc  #安装gcc包
[root@redisa ~]# mkdir /redis                      #创建目录redis
[root@redisa ~]# tar -zxvf /redis-4.0.8.tar.gz -C /redis
[root@redisa ~]# cd /redis/redis-4.0.8
[root@redisa redis-4.0.8]# make && make install       #编译安装
[root@redisa redis-4.0.8]# ./utils/install_server.sh  #初始化(一路回车,端口路径可以自定义)
[root@redisa ~]# /etc/init.d/redis_6379 stop          #停止服务
[root@redisa ~]# vim /etc/redis/6379.conf             #修改配置文件
70 bind 192.168.4.50
93 port 6350
[root@redisa ~]# rm -rf /var/run/redis_6379.pid       #重启服务时，如果报错pid存在，执行此步
[root@redisa ~]# /etc/init.d/redis_6379 start         #重启服务
[root@redisa ~]# netstat -nulpt | grep  redis-server  #查看进程进行


2. 创建集群
部署管理主机
也可部署在任意一台redis服务器上
  部署ruby脚本运行环境
  创建管理集群脚本
]# yum -y install rubygems
]# gem install redis-3.2.1.gem
]# rpm -q ruby || yum -y install ruby
]# mkdir /root/bin/  #创建命令检索目录
]# tar -zxvf redis-4.0.8.tar.gz
]# cd redis-4.0.8/src/
]# cp redis-trib.rb /root/bin/redis-trib  #创刨建管理集群脚本
]# chmod +x /root/bin/redis-trib
]# redis-tribsh help #查看命令帮助
例:
在管理mgm57主机上操作
[root@redisa ~]# scp -r /redis root@192.168.4.57:/  #将有关安装包上传到57管理主机
[root@mgm57 ~]# yum list | grep rubygems            #查找rubygems包
[root@mgm57 ~]# yum -y install rubygems
[root@mgm57 ~]# rpm -q ruby || yum -y install ruby
[root@mgm57 ~]# mkdir /root/bin  #创建命令检索目录
[root@mgm57 ~]# cd /redis
[root@mgm57 redis]# gem install redis-3.2.1.gem
[root@mgm57 redis]# tar -zxvf redis-4.0.8.tar.gz
[root@mgm57 redis]# cd redis-4.0.8/src 
[root@mgm57 src]# cp redis-trib.rb /root/bin/     #创刨建管理集群脚本
[root@mgm57 ~]# chmod +x /root/bin/redis-trib.rb  #给执行权限


redis-trib脚本
用法
]# redis-trib <command> <options> <arguments
命令                       描述
create              创建集群
check               检查集群
info                查看集群信息      
renard              重新分片
del-node            删除主机
add-node --slave    添加slave主机
add-node            添加master主机
rebalance           平均分配hash slots


3. 配置6台redis服务器
  启用集群
  查看服务信息
]# vim /etc/redis/redis. conf
  cluster-enabled yes                  #启用集群
  cluster-config-file nodes-xxxx.conf  #存储集群信息文件
  cluster-node-timeout 5000            #连接超时时间单位毫秒
]# /etc/init. d/redis 6379 restart     #重启服务
]# netstat -utnlp grep redis-server    #查看进程信息
tcp001921684.51:63510.0.0.0:* LISTEN21201/ redis- server
tcp001921684.51:163510.0.0.0:* LISTEN21201/ redis-server  #集群通信端口默认服务端口+10000
例:
在redisb,redisc,redisd,redise,redisf,redis58和redis59主机上相同操作
[root@redisa ~]# redis-cli -h 192.168.4.51 -p 6351 -a 123456 shutdown #停服务
[root@redisa ~]# rm -rf /var/lib/redis/6379/*        #删除数据内容
[root@redisa ~]# vim /etc/redis/6379.conf            #修改配置文件
815 cluster-enabled yes                              #启用集群
823 cluster-config-file nodes-6351.conf              #存储集群信息文件
829 cluster-node-timeout 5000                        #5秒,连接超时时间单位毫秒
[root@redisa ~]# /etc/init.d/redis_6379 start        #重启服务
[root@redisc ~]# netstat -nulpt | grep  redis-server #查看进程信息


4. 创建集群(在管理mgm57主机操作)
[root@MGM57 ]# redis-trib create --replicas 1 \  #--replicas定义每台主库从库个数
   192.168.4.51:6351 192.168.4.52:6352  \
   192.168.4.53:6353 192.168.4.54:6354  \
   192.168.4.55:6355 192.168.4.56:6356  \
>>>Creating cluster
on 6 nodes...
Using 3 masters： #选举出3个主库
192.168.4.51:6351
192.168.4.52:635
192.168.4.53:6353
OK] All nodes agree about slots configuration
>>> Check for open slots
>>> Check slots coverage
[oK]A16384 slots covered. #集群创建完成提示
例:
[root@mgm57 ~]# redis-trib.rb create --replicas 1 \
> 192.168.4.51:6351 192.168.4.52:6352 192.168.4.53:6353 \
> 192.168.4.54:6354 192.168.4.55:6355 192.168.4.56:6356
[OK] All 16384 slots covered.  #集群创建完成提示


5. 查看集群信息
 连接任意一台redis服务查看都可以
]# redis-cli -h 192.168.451 -p 6351
192168451:6351> cluster info  #查看集群信息
......
......
cluster known nodes: 6
cluster size: 3
192168451:6351> cluster nodes  #查看集群节点信息
6e841e2610c3d4d
192.168.4.51:6351@16351 master
b52feba0e6422b44.....192.168.4.52:6352@16352 myself, slave
a0c8e18619828487…192168455:6355@16355sa
例:
[root@redisa ~]# redis-cli -h 192.168.4.51 -p 6351 #连接任意一台redis服务查看都可以,
192.168.4.51:6351> cluster info   #查看集群信息
192.168.4.51:6351> cluster nodes  #查看集群节点信息
[root@mgm57 ~]# redis-trib.rb check 192.168.4.51:6351 #在管理mgm57主机查看集群信息


6. 测试配置
在客户端可以连接集群中任意一台 redis服务器
 命令]# redis-cli -C -h ip地址 -p 端口号
选项 -C 集群模式
[root@client50 - ] redis-cli -c -h 192. 168.4.56-p 6356
192. 168.4.56: 6356> set school tarena  #存在数据
->Redirected to slot [8455] located at 192.168.4.52:6352

[root@client50]# redis-cli -c -h 192.168.4.53 -p 6353
192.168.4.53:6353> get schoo   #取数据
Redirected to slot [5798] located at
例:
[root@redisa ~]# redis-cli -c -h 192.168.4.51 -p 6351
192.168.4.51:6351> set a 100
-> Redirected to slot [15495] located at 192.168.4.53:6353
192.168.4.53:6353> get a
"100"
192.168.4.53:6353> set zhai 200  #存在数据
-> Redirected to slot [7552] located at 192.168.4.52:6352
192.168.4.52:6352> get zhai  #取数据
"200"

===================================================================
管理集群


测试集群功能
故障切换测试
  停止master主机的redis服务
  master宕机后对应的ave自动被选举为master
  原master启动后会自动配置为当前 master的save
检测集群
查看信息
]# redis-trib check 192.168.4.51: 6351
]# redis-trib info 192. 168.4.51: 6351
例:
在管理主机上操作
[root@mgm57 ~]# redis-trib.rb info 192.168.4.52:6352   #查看集群信息
[root@mgm57 ~]# redis-trib.rb check 192.168.4.52:6352  #检查集群信息

===================================================================
添加服务器

添加服务器
具体要求如下:
   部署新的redis服务器
   添加maste角色主机到集群里
   添加slave角色主机到集群里


1. 添加master服务器
1).部署一台新 redis服务器
   运行服务并启用集群配置
添加master主机步骤
  添加 Master主机
  分配hash槽

添加master主机
  添加时不指定主机角色，默认新主机被选为master
  添加的 master主机，需手动分配hash槽
]# redis- trib add-node192.168.4.58:6358 192.168.4.51:6351
>>> Adding node192168.4.58:6358 to cluster1921684.51:6351
[OK] All nodes agree about slots configuration
......
[ OK] New node added correctly. #添加成功提示
例:
在管理mgm57主机操作
[root@mgm57 ~]# redis-trib.rb add-node 192.168.4.58:6358 192.168.4.51:6351
[OK] All 16384 slots covered.
>>> Send CLUSTER MEET to node 192.168.4.58:6358 to make it join the cluster.
[OK] New node added correctly. #添加成功提示
[root@mgm57 ~]# redis-trib.rb info 192.168.4.58:6358  #查看集群信息
192.168.4.58:6358 (39f6afe6...) -> 0 keys | 0 slots | 0 slaves.
192.168.4.53:6353 (fb8e4ab3...) -> 2 keys | 5461 slots | 1 slaves.
192.168.4.51:6351 (e7c45924...) -> 1 keys | 5461 slots | 1 slaves.
192.168.4.52:6352 (54bb718c...) -> 2 keys | 5462 slots | 1 slaves.

2).重新分片
  移出hash槽个数
  接收hash槽主机ID
  移出haSh槽主机ID
]# redis-trib.rb reshard 192.168.4.51:6351  #重新分片
How many slots do you want to move(from 1 to 16384)? 4096 #4096是4个master
What is the receiving node iD?
e081313ec843655d9bc5a17f3bed3deldccb1d2b
Please enter all the source node ids
......
Source node #1: 3550af084c94889ae2d0110e6da5793fdd851fc
Source node#2done  #结束指定
Do you want to proceed with the proposed reshard plan (yes/no)? yes
例:
[root@mgm57 ~]# redis-trib.rb add-node 192.168.4.58:6358 192.168.4.51:6351  #添加节点192.168.4.58:6358到集群192.168.4.51:6351
>>> Adding node 192.168.4.58:6358 to cluster 192.168.4.51:6351
[OK] All nodes agree about slots configuration.
......
>>> Send CLUSTER MEET to node 192.168.4.58:6358 to make it join the cluster.
......
[OK] New node added correctly..



添加save服务器
[root@mgm57 ~]# redis-trib.rb reshard 192.168.4.58:6358

[root@mgm57 ~]# redis-trib.rb add-node --slave 192.168.4.59:6359 192.168.4.51:6351


部署一台新redis服务器
运行服务并启用集群配置
添加slave主机
]# redis-trib add-node --slave [--master-id id值] ip地址端口 192.168.4.51:6351
注意: 如果不指定主节点的id的话，会把新节点随机添加为从节点最少的主库
]# redis-trib add-node- slave1921684.59:6359192.1684.51:6351
>> Adding node192168459:6359 to cluster1921684.51:6351
ig >>>Performing Cluster Check(using node 192.168.4.51: 6351
[OK]All 16384 slots covered
Automatically selected master 192. 168.4.51: 6
>> Send CLUSTER MEET to node 192.168.4.59: 6359 to make it join
the cluste
Waiting for the cluster to join
>>>Configure node as replica of 192.168.4.51: 635
OK New node added correctly。 #添加成功提示
例:
[root@mgm57 ~]# redis-trib.rb add-node --slave 192.168.4.59:6359 192.168.4.58:6358 #59主机添加到58主机,59主机为slave
[OK] All 16384 slots covered.
Automatically selected master 192.168.4.58:6358
>>> Send CLUSTER MEET to node 192.168.4.59:6359 to make it join the cluster.
Waiting for the cluster to join.
>>> Configure node as replica of 192.168.4.58:6358.
[OK] New node added correctly.
[root@mgm57 ~]#  redis-trib.rb check 192.168.4.58:6358  #检查集群信息
>>> Performing Cluster Check (using node 192.168.4.58:6358)
M: 39f6afe67c45b423dcd017dde04e1a985833ef4a 192.168.4.58:6358
   slots:0-1364,5461-6826,10923-12287 (4096 slots) master
   1 additional replica(s)
S: 35e4eaf6397eceb756bf4c9078133a1c7c82fce0 192.168.4.59:6359
   slots: (0 slots) slave
   replicates 39f6afe67c45b423dcd017dde04e1a985833ef4a

=====================================================================================
移除服务器

移除save服务器
移除slave主机
  从节点主机没有hash槽，直接移除即可.
  移除时指定从库id值
]# redis-trib del-node 192.168.4.51:6351 F6649ea99b2f01aca26217691222c17a3854381
>> Removing node f6649ea99b2f0lfaca26217691222c17a3854381
   from cluster 192.1684.51:6351
>> Sending CLUSTER FORGET messages to the cluster.
>> SHUTDOWN the node。#会停止移除主机的redis服务
例:
在管理mgg57主机操作
[root@mgm57 ~]# redis-trib.rb check 192.168.4.59:6359  #检查集群信息
S: 431054f95cc670fd9745ca3fb3982c1c3392e5a7 192.168.4.59:6359
   slots: (0 slots) slave
   replicates 39f6afe67c45b423dcd017dde04e1a985833ef4a
[root@mgm57 ~]# redis-trib.rb del-node 192.168.4.59:6359 431054f95cc670fd9745ca3fb3982c1c3392e5a7  #移除192.168.4.59主机slave,同时192.168.4.59主机服务被关掉
>>> Removing node 431054f95cc670fd9745ca3fb3982c1c3392e5a7 from cluster 192.168.4.59:6359
>>> Sending CLUSTER FORGET messages to the cluster...
>>> SHUTDOWN the node. #会停止移除主机的redis服务


移除master服务器
配置步骤
  释放占用的hash槽
  移除主机
]# redis-trib.rb reshard 192.168.4.51:6351  #重新分片
]# redis-trib。 rb del-node192.1684.51:6351 master主机id值
例:
[root@mgm57 ~]# redis-trib.rb del-node 192.168.4.58:6358 39f6afe67c45b423dcd017dde04e1a985833ef4a  #移除192.168.4.59master主机
>>> Performing Cluster Check (using node 192.168.4.58:6358)
M: 39f6afe67c45b423dcd017dde04e1a985833ef4a 192.168.4.58:6358
   slots:0-1364,5461-6826,10923-12287 (4096 slots) master
   1 additional replica(s)
[root@mgm57 ~]# redis-trib.rb check 192.168.4.51:6351  #检查集群信息  
>>> Performing Cluster Check (using node 192.168.4.51:6351)
M: e7c45924c7d80a312175a36eef8449efdc869136 192.168.4.51:6351
   slots:0-5915,6827-8646,12288-14108 (9557 slots) master
   1 additional replica(s)
[root@mgm57 ~]# redis-trib.rb reshard 192.168.4.51:6351 
How many slots do you want to move (from 1 to 16384)? 5461  #3个master,16384/3=5461
What is the receiving node ID? e7c45924c7d80a312175a36eef8449efdc869136
Source node #1:all
Do you want to proceed with the proposed reshard plan (yes/no)? yes
[root@mgm57 ~]# redis-trib.rb info 192.168.4.52:6352  #查看集群信息
192.168.4.52:6352 (54bb718c...) -> 0 keys | 2276 slots | 1 slaves.
192.168.4.53:6353 (fb8e4ab3...) -> 3 keys | 2275 slots | 1 slaves.
192.168.4.58:6358 (39f6afe6...) -> 3 keys | 2276 slots | 1 slaves.
192.168.4.51:6351 (e7c45924...) -> 7 keys | 9557 slots | 1 slaves.


移除 master服务器(续1)
达内教育
释放占用的s|ots
指定移出 slots个数
指定接收sots主机ID
知识
指定移出 slots主机ID
i F redis-trib. rb reshard 192.168.4.51: 6351
A How many slots do you want to move(from 1 to 16384)?4096
What is the receiving node ID?
4361720c3978a02347076218580a103c60a6d丌f
Please enter all the source node ids
Type ' all to use all the nodes as source nodes for the hash slots
Type 'done once you entered all the source nodes IDs.
Source node #1: e081313ec843655d9bc5a17f3bed3deldccb1d2b
Source node #2 done
Do you want to proceed with the proposed reshard plan (yes/no)? yes
eau.cn
移除 master服务器(续2)
达内教育
移除 mastel主机
1# redis-trib del-node 192 168.4.51: 6351
e081313ec843655d9bc5a17t3bed3deldccbld2b
>>>Removing node
知识讲解
e081313ec843655d9bc5a17f3bed3deldccb1d2b from cluster
192.1684.51:6351
>> Sending CLUSTER FORGET messages to the cluster.
>> SHUTDOWN the node

educ
案例3：移除服务器
达内教育
具体要求如下
把 slave角色主机移除集群
把 master角色主机移除集群
课堂练习
总结和答疑
管理集群
redis-tribl脚木选项总结
总结和答疑
sedu
达内教育
管理集群

redis-trib脚本选项总结
达内教育
redis-trib常用选项
选项
作用
知识讲解
create
创建集群
check
检查集群
reshard
重新分片
del-node
删除主机
add-node --sla
添加 slave主机
add-node
添加 master主机

nosql_day03===========================================================================

主从复制结构模式

结构模式
主一从、一主多从、主从从

主从复制工作原理
工作原理
  slave向 master发送sync命令
  master启动后台存盘进程，并收集所有修改数据命令
  master完成后台存盘后，传送整个数据文件到slave
  slave接收数据文件，加载到内存中完成首次完全同步
  后续有新数据产生时， master继续收集数据修改命令
  依次传给slave，完成同步

=========================================================================
配置主从复制

主从复制
  具体要求如下:
  1.将主机192168451配置为主库
  2.将主机1921684.52配置为192.168451的从库
  3.测试配置


1. 配置从库
  redis服务运行后，默认都是master 服务器
192.168.4.52:6379> info replication  #查看复制信息
#Replication
role                 #角色
master_host:         #主库ip地址
master port:         #主库端口号
master link status： #与主库连接状态
[root@redis52 -]# redis-cli-h 192 168.4.52
921684.526379> slaveof 192.168.4.51 -p 6351  #命令行配置,slaveof 主库IP地址 端口号
OK
]# vim /etc/redis/6379.con
  slaveof 192.168.4.5 16351  #永久配置
例:
[root@redisb ~]# redis-cli -h 192.168.4.52 -p 6352
192.168.4.52:6352> info replication  #查看复制信息(配置前)
# Replication
role:master  #角色
connected_slaves:0
192.168.4.52:6352> slaveof 192.168.4.51 6351  #命令行配置(当前有效),将192.168.4.52主机配置为192.168.4.51的slave
192.168.4.52:6352> info replication           #查看复制信息(配置后)
# Replication
role:slave                #角色
master_host:192.168.4.51  #主库ip地址
master_port:6351          #主库端口号
master_link_status:down   #与主库连接状态
[root@redisb ~]# vim /etc/redis/6379.conf                    #修改192.168.4.52主机配置文件
282 slaveof 192.168.4.51 6351                                #永久配置
[root@redisb ~]# redis-cli -h 192.168.4.52 -p 6352 shutdown  #停止服务
[root@redisb ~]# /etc/init.d/redis_6379 start                #重启服务


2. 反客为主
将从库恢复为主库
[root@redis52 ~]# redis-cli -h 192.168.4.52
192168452:6379> slave no one  #命令行临时设置
OK
]# vim /etc/redis/6379.conf
#slaveof 192.168.4.51 6351  #永久设置
例:
[root@redisb ~]# redis-cli -h 192.168.4.52 -p 6352 
192.168.4.52:6352> info replication  #查看复制信息(配置前)
# Replication
role:master  #角色
connected_slaves:0
192.168.4.52:6352> slaveof no one
192.168.4.52:6352> info replication  #查看复制信息(配置后)
# Replication
role:master  #角色
connected_slaves:0
[root@redisb ~]# vim /etc/redis/6379.conf                    #修改192.168.4.52主机配置文件
282 #slaveof 192.168.4.51 6351                               #永久配置
[root@redisb ~]# redis-cli -h 192.168.4.52 -p 6352 shutdown  #停止服务
[root@redisb ~]# /etc/init.d/redis_6379 start                #重启服务

================================================================
配置带验证的主从复制
  具体要求如下:
  1.基于案例1的配置
  2.设置主库192168451连接密码123456
  3.配置从库192.1684.52
  4.测试配置

配置带验证的主从复制
配置master
   设置连接密码，重启服务
]# sed -n '501p'/etc/redis/6379.conf
   requirepass 123456  #定义连接密码
配置 slave
  设置连接密码，重启服务
]# sed -n '282p;289p' /etc/redis/6379.conf
  masterauth 123456  #主库密码
例:
[root@redisa ~]# vim /etc/redis/6379.conf  #在192.168.4.51master主机操作
501 requirepass "123456"
[root@redisa ~]# redis-cli -h 192.168.4.51 -p 6351 -a 123456 shutdown #停止服务
[root@redisb ~]# /etc/init.d/redis_6379 start  #重启服务
[root@redisb ~]# vim /etc/redis/6379.conf      #在192.168.4.52slave主机操作
282 slaveof 192.168.4.51 6351
[root@redisb ~]# /etc/init.d/redis_6379 start  #重启服务

=====================================================================
哨兵服务

哨兵服务
 具体要求如下
 1.基于上个的配置
 2.配置哨兵服务
 3.则试配置
Master服务器192.168.4.51/24   Save服务器192.1684.52/24   哨兵服务器92.168.4.57/24

哨兵服务介绍
  监视 master服务器
  发现 master宕机后将从库升级为主库
  主配置文件 sentinel。conf
  模板文件： redis-4.0.8/ sentinel！conf

配置哨兵服务
   创建主配置文件
   启动服务
]# vim /etc/sentinel.conf
  sentinel monitor server 51 192.168.4.51 6351 1
  bind 0.0.0.0                        #服务地址
  sentinel auth-pass server51 123456  #接服务密码
]# redis-sentinel /etc/sentinel.conf  #启动服务
sentinel monitor 主机名 ip地址 端口 票数
主机名：自定义
IP地址： master主机的IP地址
端口： master主机redis服务使用的端口
票数：发现主库宕机的哨兵服务器个数
例:
[root@redise ~]# vim /etc/sentined.conf 
sentinel monitor server51 192.168.4.51 6351 1       #192.168.4.51是主库服务器
bind 0.0.0.0                                        #服务地址
sentinel auth-pass server51 123456                  #接服务密码
[root@redise ~]# redis-sentinel /etc/sentined.conf  #启动服务


======================================================
持久化

RDB介绍
  Redis数据库文件,全称 Redis Data Base
   数据持久化方式之
   数据持久化默认方式
   按照指定时间间隔，将内存中的数据集快照写入硬盘
   快照术语叫 Snapshot
   恢复时，将快照文件直接读入内存
定义RDB文件名
   dbfilename “dump.rdb"  #文件名

使用RDB文件恢复数据
要求如下:
  1.启用RDB
  2.设置存盘间隔为120秒10个key改变即存盘
  3.备份RDB文件
  4.删除数据
  5.使用RDB文件恢复数据


使用RDB文件恢复数据
备份数据
   备份 dump.rdb文件到其他位置
]# cp 数据库目录/ dump.rdb备份目录
例:
[root@redisa ~]# redis-cli -h 192.168.4.51 -p 6351 -a 123456  #连接192.168.4.51主库数据库
192.168.4.51:6351> save                                       #手动保存到磁盘
[root@redisa ~]# cp /var/lib/redis/6379/dump.rdb /root/       #备份192.168.4.51主机数据
[root@redisa ~]# scp /root/dump.rdb root@192.168.4.52:/root/  #将备份的数据拷贝到192.168.4.52主机
恢复数据
  拷贝备份文件到数据库目录，重启redis服务
]# cp 备份目录/dumprdb 数据库目录/
例:
[root@redisb ~]# redis-cli -h 192.168.4.52 -p 6352 shutdown  #停止192.168.4.52主机服务
[root@redisb ~]# cp /root/dump.rdb /var/lib/redis/6379/      #将备份数据拷贝到数据库目录下
[root@redisb ~]# /etc/init.d/redis_6379 start                #重启192.168.4.52主机服务
[root@redisb ~]# redis-cli -h 192.168.4.52 -p 6352           #测试
192.168.4.52:6352> keys *


优化设置
数据从内存保存到硬盘的频率
save 900 1     #15分钟且有1个key改变
save 300 10    #15分钟且有10个key改变
save 60 10000  #1分钟且有10000个key改变
手动存盘
save    #阻塞写存盘
bgsave  #不阻塞写存盘
例:
[root@redisa ~]# vim /etc/redis/6379.conf
219 save 60 5      #1分钟且有5个key改变
220 save 300 10    #15分钟且有10个key改变
221 save 60 10000  #1分钟且有10000个key改变
[root@redisa ~]# redis-cli -h 192.168.4.51 -p 6351 -a 123456 shutdown  #停止服务
[root@redisa ~]# /etc/init.d/redis_6379 start                          #重启服务
[root@redisa ~]# redis-cli -h 192.168.4.51 -p 6351 -a 123456           #连接服务
192.168.4.51:6351> save    #阻塞写存盘
192.168.4.51:6351> bgsave  #不阻塞写存盘
Background saving started  


RDB优点与缺点
RDB优点
  高性能的持久化实现——创建—个子进程来执行持久
  化，先将数据写入临时文件，持久化过程结束后，再
  用这个临时文件替换上次持久化好的文件；过程中主
  进程不做任何IO操作
  比较适合大规模数据恢复，且对数据完整性要求不非常高的场合
RDB的缺点
  意外宕机时，丢失最后一次持久化的所有数据

=================================================================
AOF

使用AOF文件恢复数据
要求如下:
  1.启用AOF
  2.备份AOF文件
  3.删除数据
  4.使用AOF文件恢复数据

AOF介绍
Append Only File
  迫加方式记录写操作的文件
  记录redis服务所有写操作
  不断的将新的写操作，追加到文件的末尾
  默认没有启用
  使用ca命令可以查看文件内容

1. 启用AOF
> config set appendonly yes  #启用
> config rewrite             #写进配置文件
例:
[root@redisa ~]# redis-cli -h 192.168.4.51 -p 6351 -a 123456 
192.168.4.51:6351> config set appendonly yes  #启用(使用数据自动保存到磁盘)
192.168.4.51:6351> config rewrite             #写进配置文件


2. 使用AOF文件恢复数据
1).备份数据
  备份 appendonly aof文件到其他位置
  ]# cp 数据库目录/applendonly.aof  #备份目录
例:
[root@redisa ~]# cp /var/lib/redis/6379/appendonly.aof /root/       #备份192.168.4.51主机数据
[root@redisa ~]# scp /root/appendonly.aof root@192.168.4.52:/root/  #将备份的数据拷贝到192.168.4.52主机

2).恢复数据
  拷贝备份文件到数据库目录
  重启redis服务
]# cp 备份目录/appendonly.aof #数据库目录
]# /etc/reds/reds_端口 start
例: 
[root@redisb ~]#  redis-cli -h 192.168.4.52 -p 6352 shutdown   #停止192.168.4.52主机服务
[root@redisb ~]# cp /root/appendonly.aof /var/lib/redis/6379/  #将备份数据拷贝到数据库目录下
[root@redisb ~]# /etc/init.d/redis_6379 start                  #重启192.168.4.52主机服务
[root@redisb ~]# redis-cli -h 192.168.4.52 -p 6352             #重启192.168.4.52主机服务
192.168.4.52:6352> keys *                                      #测试


3. 优化配置
定义文件名
  appendonly yes  #启用aof,默认no
  appendfilename "appendonly.aof"  #指定文件名
AOF文件记录写操作的方式
  appendfsync always    #时记录，并完成磁盘同步
  appendfsync everysec  #每秒记录次，并完成磁盘同步
  appendfsync no        #写入aof，不执行磁盘同步
例:
[root@redisa ~]# redis-cli -h 192.168.4.51 -p 6351 -a 123456  #连接数据服务器
192.168.4.51:6351> config set appendonly yes        #启用aof,默认no
192.168.4.51:6351> config set appendfsync always    #时记录，并完成磁盘同步
192.168.4.51:6351> config set appendfsync everysec  #每秒记录次，并完成磁盘同步
192.168.4.51:6351> config set appendfsync no        #写入aof，不执行磁盘同步
 

4. 日志文件会不断增大，何时触发日志重写
  auto-aof-rewrite-min-size 64mb    #次重写触发值
  auto- aof-rewrite-percentage 100  #再次重写，增长百分比
修复AOF文件
  把文件恢复到最后一次的正确操作
[root@redis53 6379]# redis-check-aof --fix appendonly.aof
83: Expected\r\n,got: 6166
AOF analyzed: size=160, ok_up-to=123,diff=37
This will shrink the AOF from 160 bytes, with 37 bytes, to 123
bytes
Continue? y/N]: y
Successfully truncated AOF

AOF优点与缺点
AOF优点
  可以灵活设置持久化方式
  出现意外宕机时，仅可能丢失1秒的数据
AOF缺点
  持久化文件的体积通常会大于RDB方式
  执行 fsync策略时的速度可能会比RDB方式慢


==============================================================
数据类型

String字符串

1. 宇符串操作
１) set key value [ex seconds] [px milliseconds] [nx|xx]
  设置key及值，过期时间可以使用秒或毫秒为单位
strange key offset value
  从偏移量开始复写key的特定位的值
> set first "hello world"
> strange first 6 "Redis"  #改写为hello Redis  
strlen key，统计字串长度
>strlen first
例:
192.168.4.51:6351> set first "rtrewtrfs"    #定义变量
192.168.4.51:6351> setrange first 6 "Rdis"  #
192.168.4.51:6351> get first
"rtrewtRdis"
192.168.4.51:6351> strlen first  #统计变量值字串长度
(integer) 10

2) append key value
  存在则追加，不存在则创建key及vaue，返回key长度
> append myname jacob
例：
192.168.4.51:6351> set myname zhai
192.168.4.51:6351> get myname
"zhai"
192.168.4.51:6351> append myname yanquan　＃追加
(integer) 11
192.168.4.51:6351> get myname
"zhaiyanquan"
192.168.4.51:6351> get name
(nil)
192.168.4.51:6351> append name zyq　#name不存则创建,赋值zyq
(integer) 3
192.168.4.51:6351> get zyq
(nil)
192.168.4.51:6351> get name
"zyq"

3) tetbit key offset value
  对key所存储字串，设置或清除特定偏移量上的位(bⅰt)
  value值可以为1或0， offset为0~2A32之间
  key不存在，则创建新key
> etbit bit o 1   #设置bit第0位为1
> setbit bit 1 0  #设置bit第1位为0
例:
192.168.4.51:6351> setbit  yan 0 1  #设置bit第0位为1
(integer) 1
192.168.4.51:6351> setbit quan 1 0  #设置bit第1位为0
(integer) 0

4) bitcount key
  统计字串中被设置为1的比特位数量
> setbit bits 0 1  #0001
> setbit bits 3 1  #1001
> bitcount bits  　#结果为2
> setbit peter 100 1  #网站上线100天用户登录了一次
> setbit peter 105 1　#网站上线105天用户登录了一次
> bitcount peter
场景说明：
记录网站用户上线频率，如用户A上线了多少天等类似的数据
如用户在某天上线，则使用 sethi，以用户名为将网站上线日为 offset，并在
该offset上设置1，最后计算用户总上线次数时，使用bitcount用广名即可
这样，即使网站运行10年，每个用户仅占用10*365比特位即456字节
例：
192.168.4.51:6351> setbit yan 3 1
(integer) 0
192.168.4.51:6351> bitcount yan　　#结果为2
(integer) 2
192.168.4.51:6351> setbit zhai 100 1　#网站上线100天用户登录了一次
192.168.4.51:6351> get zhai　　
"\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\b"
192.168.4.51:6351> setbit zhai 105 1  #网站上线105天用户登录了一次
192.168.4.51:6351> get zhai
"\x80\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\b@"

5) decr key
　将key中的值减1，key不存在则先初始化为0，再减1
> set test 10
> decr test
例：
192.168.4.51:6351> set sum 100
192.168.4.51:6351> decr sum
(integer) 99
192.168.4.51:6351> get sum
"99"

6) derby key decrement
  将key中的值，减去decrement
> set count 100
> derby count 20
例：
192.168.4.51:6351> set n 100
192.168.4.51:6351> get n
"100"
192.168.4.51:6351> decrby n 10 #将n值减去10
(integer) 90
192.168.4.51:6351> get n
"90"

7) get key
  返回key存储的字符串值，若key不存在则返回nul
  若key的值不是字串，则返回错误，get只能处理字串
例：
192.168.4.51:6351> keys *
(empty list or set)
192.168.4.51:6351> get x  #x不存在,返回nul
(nil)
192.168.4.51:6351> set y 100
192.168.4.51:6351> get y
"100"

8) getrange key start end
返回字串值中的子字串，截取范围为star和end
负数偏移量表示从末尾开始计数，-1表示最后一个字
知识讲解
符，-2表示倒数第二个字符
> set first "hello, the world"
> getrange first -5 -1
> getrange first 0 4
例:
192.168.4.51:6351> set sum zhaiyanquan
OK
192.168.4.51:6351> get sum
"zhaiyanquan"
192.168.4.51:6351> getrange sum -6 -1
"anquan"
192.168.4.51:6351> getrange sum 1 5
"haiya"
192.168.4.51:6351> getrange sum 0 5
"zhaiya"

9) incr key
  将key的值加1，如果key不存在，则初始为0后再加1
  主要应用为计数器
> set page 20
> incr page
例:
192.168.4.51:6351> set a 30
OK
192.168.4.51:6351> incr a
(integer) 31
192.168.4.51:6351> get a
"31"

10) incrby key increment
 将key的值增加 increment
例:
192.168.4.51:6351> set b 100
OK
192.168.4.51:6351> incrby b 20
(integer) 120
192.168.4.51:6351> get b
"120"

11) incrbyfloat key increment
为key中所储存的值加上浮点数增量 increment
> set num 16.1
> incrbyfloat num 1.1
例:
192.168.4.51:6351> set num 12.1
192.168.4.51:6351> get num
"12.1"
192.168.4.51:6351> incrbyfloat num 2.3  #加2.3
"14.4"
192.168.4.51:6351> get num
"14.4"

12) mget key [key...]
 获取一个或多个key的值，空格分隔，具有原子性
例:
192.168.4.51:6351> keys *
1) "sum"
2) "b"
3) "a"
4) "y"
5) "num"
192.168.4.51:6351> mget sum b a y #显示多个变量值
1) "zhaiyanquan"
2) "120"
3) "52"
4) "100"
192.168.4.51:6351> 

13) mset key value [key value...]
  设置多个key及值，空格分隔，具有原子性
例:
192.168.4.51:6351> mset a 10 b 20 c 30 d 40  #创建多个变量同时赋值
OK
192.168.4.51:6351> mget a b c d
1) "10"
2) "20"
3) "30"
4) "40"

==============================================================
List列表

List列表简介
  Redis的list是一个字符队列
  先进后出
  一个key可以有多个值

1. List列表操作
1) push key value [value.
将一个或多个值vaue插入到列表key的表头
Key不存在，则创建key
> lpush list a b c  #ist1值依次为c、b、a
例:
192.168.4.51:6351> lpush list a b c
2) lrange key start stop
  从开始位置读取key的值到stop结束
> lrange list 0 2   #从0位开始,读到2位为止
> lrange list 0 -1  #从开始督导结束为止
> lrange list 0 -2  #从开始读到倒数第2为为止
例:
192.168.4.51:6351> lrange list 0 1   #从0位开始,读到1位为止
1) "c"
2) "b"
192.168.4.51:6351> lrange list 0 -1  #从开始督导结束为止
1) "c"
2) "b"
3) "a"
192.168.4.51:6351> lrange list 0 -2  #从开始读到倒数第2为为止
1) "c"
2) "b"

3) lpop key
 移除并返回列表头元素数据,key不存在则返回nil
> lpop list  #删除表头元素,可以多次执行
例:
192.168.4.51:6351> lpush list2 z y q zhai yan quan
(integer) 6
192.168.4.51:6351> lpop list2  #删除第一个元素
"quan"
192.168.4.51:6351> lrange list2 0 -1
1) "yan"
2) "zhai"
3) "q"
4) "y"
5) "z"

4) llen key
  返回列表key的长度
例:
192.168.4.51:6351> llen list2
(integer) 5

5) lindex key index
  返回列表中第index个值
> lindex key 0; lindex key 2; lindex key -2
例:
192.168.4.51:6351> lrange list2 0 -1
1) "yan"
2) "zhai"
3) "q"
4) "y"
5) "z"
192.168.4.51:6351> lindex list2 2   #返回列表中第3个值
"q" 
192.168.4.51:6351> lindex list2 0   #返回列表中第1个值
"yan"
192.168.4.51:6351> lindex list2 -2  #返回列表中倒数第2个值
"y"

6) lset key index value
  将key中index位置的值修改为valve
> lset list 3 test  #将list中第3个值修改为test
例:
192.168.4.51:6351> lrange list2 0 -1
1) "yan"
2) "zhai"
3) "q"
4) "y"
5) "z"
192.168.4.51:6351> lset list2 4 zhai  #将list2中第4个值修改为zhai
192.168.4.51:6351> lrange list2 0 -1
1) "yan"
2) "zhai"
3) "q"
4) "y"
5) "zhai"

7) rpush key value [value...]
 将value插入到key的末尾
> rpush list3 a b c  #list3值为a b c
> rpush list3 d      #末尾插入d
例:
192.168.4.51:6351> lrange list2 0 -1
1) "-1"
2) "0"
3) "yan"
4) "zhai"
5) "q"
6) "y"
7) "zhai"
192.168.4.51:6351> rpush list2 a b c  #在末尾插入a b c
192.168.4.51:6351> lrange list2 0 -1
 1) "-1"
 2) "0"
 3) "yan"
 4) "zhai"
 5) "q"
 6) "y"
 7) "zhai"
 8) "a"
 9) "b"
10) "c"

8) 删除并返回key末尾的值
> rpush list4 a b c  #list4值为a b c
> rpop list4  #删除末尾的c,并返回删除的值
例:
192.168.4.51:6351> rpush list3 z y q
192.168.4.51:6351> lpush list3 0 -1
192.168.4.51:6351> lrange list3 0 -1
1) "-1"
2) "0"
3) "z"
4) "y"
5) "q"
192.168.4.51:6351> rpop list3  #删除并返回list3末尾的值
"q"

===============================================================
Hash表

HaSh表eHaSh表简介
Redis hash
  是一个 string类型的field和value的映射表
  一个key可对应多个field，一个field对应一个value
  将一个对象存储为hash类型，较于每个字段都存储成string类型更能节省内存

1. Hash表操作
1) hset key field value
   将hash表中fed值设置为value
> hset site google 'www.g.cn'
> hset site baidu 'wwwbaidu.com' 
例:
192.168.4.51:6351> hset site zhaiyanquan 453413243432  #hset site key

2)hget key filed 
  获取hash表中field的值
> hget site google
192.168.4.51:6351> hget site zhaiyanquan
"453413243432"

3)hmset key field value [field value...]
  同时给hash表中的多个field赋值
> hmset site google www.g.cn baidu www.baidu.com
例:
192.168.4.51:6351> hmset site sina www.g.cn baidu www.baidu.com
192.168.4.51:6351> hmset site zhai 432423 yan 99999

4)hmget key field [field.
  返回hash表中多个feld的值
> hmget site google baidukeys key
返回hash表中所有fed名称
> hmsetsitegooglewww.g.cnbaiduwww.baidu.com
例:
192.168.4.51:6351> hmset site zhai 432423 yan 99999
192.168.4.51:6351> hmget site zhai
1) "432423"
192.168.4.51:6351> hmget site zhai yan
1) "432423"
2) "99999"

5)hgetall key
  返回hash表中所有field的值 
> hals key
例:

12.security============================================================================================================

security_day01=========================================================================================================

常用系统监控命令
1.1 问题

本案例要求熟悉查看Linux系统状态的常用命令，为进一步执行具体的监控任务做准备：
  1.查看内存信息
  2.查看交换分区信息
  3.查看磁盘信息
  4.查看CPU信息
  5.查看网卡信息
  6.查看端口信息
  7.查看网络连接信息

1.2 方案
  一般企业做监控的目的：实时报告系统状态，提前发现系统的问题。
  监控的资源可以分为：共有数据（HTTP、FTP等）和私有数据（CPU、内存、进程数等）。
  监控软件可以使用：系统自带的命令、Cacti监控系统、Nagios监控系统、Zabbix监控系统。


Zabbix监控原理：
    Agentd安装在被监控的主机上，Agent负责定期收集客户端本地各项数据，并发送至Zabbix Server端，Zabbix Server收到数据，
将数据存储到数据库中，用户基于Zabbix WEB可以看到数据在前端展现图像。当Zabbix监控某个具体的项目，改项目会设置一个触发器阈值，
当被监控的指标超过该触发器设定的阈值，会进行一些必要的动作，动作包括：发送信息（邮件、微信、短信）、发送命令（SHELL 命令、Reboot、Restart、Install等）。

Zabbix监控部署在系统中，包含常见的五个程序：zabbix_server、zabbix_agentd、zabbix_proxy、zabbix_get、zabbix_sender等。

五个程序的功能如下：
zabbix server：zabbix服务端守护进程，其中zabbix_agentd、zabbix_get、zabbix_sender、zabbix_proxy的数据最终都提交给zabbix server；
zabbix agentd：客户端守护进程，负责收集客户端数据，例如：收集cpu负载、内存、硬盘使用情况等；
zabbix proxy：zabbix分布式代理守护进程，通过大于500台主机，需要进行分布式监控架构部署；
zabbix get：zabbix数据接收工具，单独使用的命令，通常在server或者proxy端执行获取远程客户端信息的命令；
zabbix sender：zabbix数据发送工具，用户发送数据给server或proxy端，通常用户耗时比较长的检查。


1.3 步骤
实现此案例需要按照如下步骤进行。

步骤一：使用命令查看计算机状态数据
1）查看内存与交换分区信息
[root@proxy ~]# free  #查看内存信息
              total        used        free      shared  buff/cache   available
Mem:       16166888     8017696      720016      106504     7429176     7731740
Swap:       4194300      218268     3976032
[root@proxy ~]# free | awk '/Mem/{print $4}'  #查看剩余内存容量
720928
[root@proxy ~]# swapon -s   #查看交换分区信息
  文件名                      类型                  大小        已用        权限
/dev/sda3             partition        4194300    218268    -1


步骤二：查看磁盘与CPU利用率
1）查看磁盘信息
[root@proxy ~]# df  #查看所有磁盘的使用率
文件系统             1K-块         已用          可用           已用% 挂载点
/dev/sda2      476254208   116879624   335159084     26%         /
/dev/sda1       198174     133897      49737         73%         /boot
[root@proxy ~]# df | awk '/\/$/{print $5}'   #查看根分区的利用率

2）查看CPU平均负载
[root@proxy ~]# uptime  #查看CPU负载（1，5，15分钟）
 23:54:12 up 38 days, 14:54,  9 users,  load average: 0.00, 0.04, 0.05
[root@proxy ~]# uptime |awk '{print $NF}'  #仅查看CPU的15分钟平均负载
0.05


步骤二：查看网卡信息、端口信息、网络连接信息

1）查看网卡信息
[root@proxy ~]# ifconfig eth0
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 192.168.4.5  netmask 255.255.255.0  broadcast 172.25.0.255
        inet6 fe80::5054:ff:fe00:b  prefixlen 64  scopeid 0x20<link>
        ether 52:54:00:00:00:0b  txqueuelen 1000  (Ethernet)
        RX packets 62429  bytes 10612049 (10.1 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 5674  bytes 4121143 (3.9 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
[root@proxy ~]# ifconfig eth0 |awk '/inet /{print $2}'  #查看IP地址信息
192.168.4.5
[root@proxy ~]# ifconfig eth0 |awk '/RX p/{print $5}'   #网卡接受数据包流量
10625295
[root@proxy ~]# ifconfig eth0 |awk '/TX p/{print $5}'   #网卡发送数据包流量
4130821
2）查看端口信息
[root@proxy ~]# ss -ntulp  #查看本机监听的所有端口
# -n以数字显示端口号
# -t显示tcp连接
# -u显示udp连接
# -p显示监听端口对应的程序名称

3）查看网络连接信息
[root@proxy ~]# ss -antup  查看所有的网络连接信息
# -a查看所有连接状态信息


===================================================================
部署Zabbix监控平台

2.1 问题
要求部署一台Zabbix监控服务器，一台被监控主机，为进一步执行具体的监控任务做准备：
  1.安装LNMP环境
  2.源码安装Zabbix
  3.安装监控端主机，修改基本配置
  4.初始化Zabbix监控Web页面
  5.修改PHP配置文件，满足Zabbix需求
  6.安装被监控端主机，修改基本配置

2.2 方案
使用1台RHEL7虚拟机，安装部署LNMP环境、Zabbix及相关的依赖包，配置数据库并对Zabbix监控平台进行初始化操作。使用2台被监控端，源码安装Zabbix Agent。完成Zabbix实验需要我们搭建一个实验环境，拓扑结构如表-1所示。
主机名称                      网卡与IP地址
zabbixserver         eth1: 192.168.2.5
zabbixserver_web1    eth1: 192.168.2.100
zabbixserver_web2    eth1: 192.168.2.200

2.3 步骤

实现此案例需要按照如下步骤进行。
步骤一：部署监控服务器
1）安装LNMP环境
Zabbix监控管理控制台需要通过Web页面展示出来，并且还需要使用MySQL来存储数据，因此需要先为Zabbix准备基础LNMP环境。
[student@room9pc01 ~]$ scp -r Zabbix root@192.168.4.7:/  #将关包上传到zabbixserver主机
[root@zabbixserver ~]#  yum -y install gcc pcre-devel openssl-devel
[root@zabbixserver ~]# cd /Zabbix
[root@zabbixserver ~]# tar -xf nginx-1.12.2.tar.gz
[root@zabbixserver ~]# cd nginx-1.12.2
[root@zabbixserver nginx-1.12.2]# ./configure --with-http_ssl_module
[root@zabbixserver nginx-1.12.2]# make && make install
[root@zabbixserver ~]# yum -y install php php-mysql mariadb mariadb-devel mariadb-server
[root@zabbixsrever ~]# cd /Zabbix/
[root@zabbixserver Zabbix]# rpm -ivh --nodeps  php-fpm-5.4.16-42.el7.x86_64.rpm

2）修改Nginx配置文件
配置Nginx支持PHP动态网站，因为有大量PHP脚本需要执行，因此还需要开启Nginx的各种fastcgi缓存，加速PHP脚本的执行速度。
[root@zabbixserver ~]# vim +65 /usr/local/nginx/conf/nginx.conf
… …
http{
… …
    fastcgi_buffers 8 16k;        #缓存php生成的页面内容，8个16k
    fastcgi_buffer_size 32k;      #缓存php生产的头部信息
    fastcgi_connect_timeout 300;  #连接PHP的超时时间
    fastcgi_send_timeout 300;     #发送请求的超时时间
    fastcgi_read_timeout 300;     #读取请求的超时时间
location ~ \.php$ {
                root           html;
                fastcgi_pass   127.0.0.1:9000;
                fastcgi_index  index.php;
                include        fastcgi.conf;
        }
… …

3）启动服务
启动Nginx、PHP-FPM、MariaDB服务，关闭SELinux与防火墙。
[root@zabbixserver ~]# /usr/local/nginx/sbin/nginx -s stop  #停止服务
[root@zabbixserver ~]# /usr/local/nginx/sbin/nginx          #重启服务
[root@zabbixserver ~]# netstat -nuptl | grep :80
[root@zabbixserver ~]# systemctl start mariadb  #重启服务
[root@zabbixserver ~]# netstat -nuptl | grep :3306
[root@zabbixserver ~]# systemctl start php-fpm  #重启服务
[root@zabbixserver ~]# netstat -nuptl | grep :9000
[root@zabbixserver ~]# ln -s /usr/local/nginx/sbin/nginx /sbin/nginx
[root@zabbixserver ~]# nginx
[root@zabbixserver ~]# firewall-cmd --set-default-zone=trusted
[root@zabbixserver ~]# setenforce 0

4）客户端测试LNMP环境
服务器创建PHP测试页面，浏览器访问页面测试网页连通性。
[root@zabbixserver ~]# cat /usr/local/nginx/html/test.php
<?php
$i=33;
echo $i;
?>
[root@zabbixserver ~]# curl http://192.168.2.5/test.php
或
[root@room9pc01 ~]#  firefox http://192.168.2.5/test.php  #真机访问


步骤二：部署监控服务器Zabbix Server

1）源码安装Zabbix Server
多数源码包都是需要依赖包的，zabbix也一样，源码编译前需要先安装相关依赖包。
[root@zabbixserver ~]# cd /Zabbix/
[root@zabbixserver Zabbix]# yum -y install  net-snmp-devel  curl-devel              #安装相关依赖包
[root@zabbixserver Zabbix]# yum -y install  libevent-devel-2.0.21-4.el7.x86_64.rpm  #注意libevent-devel这个软件包在Zabbix目录下有提供
[root@zabbixserver Zabbix]# tar -xf zabbix-3.4.4.tar.gz
[root@zabbixserver Zabbix]# cd zabbix-3.4.4
[root@zabbixserver zabbix-3.4.4]#./configure  --enable-server  --enable-proxy --enable-agent --with-mysql=/usr/bin/mysql_config  --with-net-snmp --with-libcurl
# --enable-server安装部署zabbix服务器端软件
# --enable-agent安装部署zabbix被监控端软件
# --enable-proxy安装部署zabbix代理相关软件
# --with-mysql配置mysql_config路径
# --with-net-snmp允许zabbix通过snmp协议监控其他设备
# --with-libcurl安装相关curl库文件，这样zabbix就可以通过curl连接http等服务，测试被监控主机服务的状态
[root@zabbixserver zabbix-3.4.4]# make && make install  #编译并安装

2）初始化Zabbix
创建数据库，上线Zabbix的Web页面
[root@zabbixserver ~]# mysql
mysql> create database zabbix character set utf8;                           #创建数据库，支持中文字符集
mysql> grant all on zabbix.* to zabbix@'localhost' identified by 'zabbix';  #创建可以访问数据库的账户与密码
[root@zabbixserver ~]# cd /Zabbix/zabbix-3.4.4/database/mysql/
[root@zabbixserver mysql]# mysql -uzabbix -pzabbix zabbix < schema.sql
[root@zabbixserver mysql]# mysql -uzabbix -pzabbix zabbix < images.sql
[root@zabbixserver mysql]# mysql -uzabbix -pzabbix zabbix < data.sql
#刚刚创建是空数据库，zabbix源码包目录下，有提前准备好的数据cd /Zabbix/zabbix-3.4.4/database/mysql/
#使用mysql导入这些数据即可（注意导入顺序）

3) 上线Zabbix的Web页面
[root@zabbixserver php]# cd /Zabbix/zabbix-3.4.4/frontends/php
[root@zabbixserver php]# cp -a * /usr/local/nginx/html/ #-a表示所有属性
[root@zabbixserver php]# chmod -R 777 /usr/local/nginx/html/*


根据错误提示，修改PHP配置文件，满足Zabbix_server的Web环境要求
php-bcmath和php-mbstring都在lnmp_soft目录下有提供软件包。
[root@zabbixserver ~]# yum -y install  php-gd php-xml
[root@zabbixserver ~]# yum list | grep php-mbstring     
[root@zabbixserver ~]# yum list | grep  php-bcmath    
[root@zabbixserver ~]# yum -y install php-gd php-xml php-ldap php-bcmath php-mbstring
[root@zabbixserver ~]# vim /etc/php.ini
879 date.timezone = Asia/Shanghai  #设置时区
385 max_execution_time = 300       #最大执行时间，秒
673 post_max_size = 32M            #POST数据最大容量
394 max_input_time = 300           #服务器接收数据的时间限制
406 memory_limit = 128M            #内存容量限制
[root@zabbixserver ~]# systemctl restart php-fpm

4)修改Zabbix_agent配置文件，启动Zabbix_agent服务
[root@zabbixserver ~]# vim /usr/local/etc/zabbix_agentd.conf
93 Server=127.0.0.1,192.168.2.5         #允许哪些主机监控本机
134 ServerActive=127.0.0.1,192.168.2.5  #允许哪些主机通过主动模式监控本机
145 Hostname=zabbix_server              #设置本机主机名
30 LogFile=/tmp/zabbix_server.log       #设置日志文件
UnsafeUserParameters=1                  #是否允许自定义key
[root@zabbixserver ~]# useradd -s /sbin/nologin zabbix
[root@zabbixserver ~]# zabbix_agentd  #启动监控agent
[root@zabbixserver ~]# ss -ntulp |grep zabbix_agentd  #查看端口信息为10050
tcp    LISTEN     0      128       *:10050                 *:*             users:(("zabbix_agentd",pid=23505,fd=4),("zabbix_agentd",pid=23504,fd=4)

5)提示：如果是因为配置文件不对，导致服务无法启动时，不要重复执行zabbix_agentd，
一定要先使用killall zabbix_agentd关闭服务后，再重新启动一次。
浏览-器访问Zabbix_server服务器的Web页面
[root@zabbixserver ~]# firefox http://192.168.2.5/index.php 
#第一次访问，初始化PHP页面会检查计算机环境是否满足要求，如果不满足会给出修改建议
#默认会提示PHP的配置不满足环境要求，需要修改PHP配置文件
[root@zabbixserver ~]# yum list | grep php-bcmath      
[root@zabbixserver ~]# yum -y install php-bcmath.x86_64
[root@zabbixserver php]#  yum list | grep php-mbstring
[root@zabbixserver php]# yum -y install php-mbstring.x86_64

6) 修改Zabbix_server配置文件，设置数据库相关参数，启动Zabbix_server服务
[root@zabbixserver ~]# vim /usr/local/etc/zabbix_server.conf
85 DBHost=localhost                #数据库主机，默认该行被注释
95 DBName=zabbix                   #设置数据库名称
109 DBUser=zabbix                  #设置数据库账户
119 DBPassword=zabbix              #设置数据库密码，默认该行被注释
38 LogFile=/tmp/zabbix_server.log  #设置日志，仅查看以下即可
[root@zabbixserver ~]# useradd -s /sbin/nologin zabbix  #不创建用户无法启动服务
[root@zabbixserver ~]# zabbix_server                    #启动服务
[root@zabbixserver ~]# ss -ntulp |grep zabbix_server    #确认连接状态，端口10051
tcp LISTEN 0 128 *:10051 *:* users:(("zabbix_server",pid=23275,fd=4),("zabbix_server",pid=23274,fd=4)
提示：如果是因为配置文件不对，导致服务无法启动时，不要重复执行zabbix_server，
一定要先使用killall zabbix_server关闭服务后，再重新启动一次。

=======================================================================================
步骤三：部署被监控主机Zabbix Agent

1）源码安装Zabbix agent软件nginx
在2.100和2.200做相同操作（以zabbixclient_web1为例）。
[root@zabbixclient_web1 ~]# useradd -s /sbin/nologin  zabbix
[root@zabbixclient_web1 ~]# yum -y install php-ldap
[root@zabbixclient_web1 ~]# yum -y install gcc pcre-devel
[root@web1 ~]# cd /Zabbix
[root@zabbixclient_web1 ~]# tar -xf zabbix-3.4.4.tar.gz 
[root@zabbixclient_web1 ~]# cd zabbix-3.4.4/
[root@zabbixclient_web1 zabbix-3.4.4]# ./configure --enable-agent
[root@zabbixclient_web1 zabbix-3.4.4]# make && make install 

2）修改agent配置文件，启动Agent
[root@web1 ~]# vim /usr/local/etc/zabbix_agentd.conf
69 EnableRemoteCommands=1               #监控异常后，是否允许服务器远程过来执行命令，如重启某个服务
93 Server=127.0.0.1,192.168.2.5         #谁可以监控本机（被动监控模式）
134 ServerActive=127.0.0.1,192.168.2.5  #谁可以监控本机（主动监控模式）
145 Hostname=web1                       #是否允许自定义key监控
[root@web1 ~]# zabbix_agentd            #启动agent服务

3）拷贝启动脚本（非必须操作，可选做），有启动脚本可以方便管理服务，启动与关闭服务。启动脚本位于zabbix源码目录下。
[root@web1 core]# cd /Zabbix/zabbix-3.4.4/misc/init.d/fedora/core
[root@web1 core]# cp zabbix_agentd /etc/init.d/
[root@web1 core]# /etc/init.d/zabbix_agentd start
[root@web1 core]# /etc/init.d/zabbix_agentd stop
[root@web1 core]# /etc/init.d/zabbix_agentd status
[root@web1 core]# /etc/init.d/zabbix_agentd restart


==================================================================================
配置及使用Zabbix监控系统

3.1 问题

沿用练习一，使用Zabbix监控平台监控Linux服务器，实现以下目标：
   1.监控CPU
   2.监控内存
   3.监控进程
   4.监控网络流量
   5.监控硬盘


3.2 方案
通过Zabbix监控平台，添加被监控zabbixclient_web1主机（192.168.2.100）并链接监控模板即可，Zabbix默认模板就可以监控CPU、内存、进程、网络、磁盘等项目。

3.3 步骤

3.3 步骤
实现此案例需要按照如下步骤进行。

步骤一：添加监控主机
  1.主机是Zabbix监控的基础，Zabbix所有监控都是基于Host主机。
  2.使用火狐浏览器登录http://192.168.2.5，通过Configuration（配置）-->Hosts（主机）-->Create Host（创建主机）添加被监控Linux主机，
  3.添加被监控主机时，需要根据提示输入被监控Linux主机的主机名称（最好与电脑的主机名一致，但也允许不一致）、主机组、IP地址等参数

步骤二：为被监控主机添加监控模板
  1.Zabbix通过监控模板来对监控对象实施具体的监控功能，根据模板来定义需要监控哪些数据，对于Linux服务器的监控，Zabbix已经内置了相关的模板（Template OS Linux），选择模板并链接到主机即可，

步骤三：查看监控数据
  1.查看监控数据，登录Zabbix Web控制台，点击Monitoring(监控中)—> Latest data(最新数据)，正过滤器中填写过滤条件，根据监控组和监控主机选择需要查看哪些监控数据
   2.找到需要监控的数据后，可以点击后面的Graph查看监控图形


==============================================================================================================
自定义Zabbix监控项目


4.1 问题
沿用练习二，使用Zabbix实现自定义监控，实现以下目标：监控Linux服务器系统账户的数量。

4.2 方案
需要使用Zabbix自定义key的方式实现自定义监控，参考如下操作步骤：
  1.创建自定义key
  2.创建监控项目
  3.创建监控图形
  4.将监控模板关联到主机


4.3 步骤
实现此案例需要按照如下步骤进行。
步骤一：被监控主机创建自定义key（在192.168.2.100操作）

1）创建自定义key
  1.自定义key语法格式为：UserParameter=自定义key名称,命令。
  2.自定义的key文件一般存储在/usr/local/etc/zabbix_agentd.conf.d/目录，这里还需要修改zabbix_agentd.conf文件，允许自定义监控key，来读取该目录下的所有文件 。
[root@zabbixclient_web1 ~]# vim /usr/local/etc/zabbix_agentd.conf
Include=/usr/local/etc/zabbix_agentd.conf.d/  #加载配置文件目录
[root@zabbixclient_web1 ~]# cd /usr/local/etc/zabbix_agentd.conf.d/
[root@zabbixclient_web1 zabbix_agentd.conf.d]# vim count.line.passwd
UserParameter=count.line.passwd,wc -l /etc/passwd | awk ' {print $1} '  #自定义key语法格式:
//UserParameter=自定义key名称,命令
例:
[root@web1 ~]# vim /usr/local/etc/zabbix_agentd.conf
261 Include=/usr/local/etc/zabbix_agentd.conf.d/   #加载配置文件目录
[root@web1 ~]# cd /usr/local/etc/zabbix_agentd.conf.d/
[root@web1 zabbix_agentd.conf.d]#  vim count.line.passwd
UserParameter=count.line.passwd,wc -l /etc/passwd | awk ' {print $1} '  #自定义key语法格式:

2）测试自定义key是否正常工作
[root@zabbixclient_web1 ~]# killall  zabbix_agentd
[root@zabbixclient_web1 ~]# zabbix_agentd	#重启agent服务
[root@zabbixclient_web1 ~]# zabbix_get -s 127.0.0.1 -k count.line.passwd
21
例:
[root@web1 ~]#  killall -9  zabbix_agentd
[root@web1 ~]# zabbix_agentd  #重启agent服务
[root@web1 ~]# zabbix_get -s 127.0.0.1 -k count.line.passwd
21
注意：如zabbix_get命令执行错误，提示Check access restrictions in Zabbix agent configuration，则需要检查agent配置文件是否正确：
[root@zabbixclient_web1 ~]# vim /usr/local/etc/zabbix_agentd.conf
Server=127.0.0.1,192.168.2.5
ServerActive=127.0.0.1,192.168.2.5

1）添加监控模板
登录Zabbix Web监控控制台，通过Configuration(配置)-->Template(模板)-->Create template(创建模板)，填写模板名称，新建模板群组

security_day02=========================================================================================================

自定义监控案例
5.1 问题

沿用前面的练习，使用自定义key监控常用监控项目，实现以下目标：
监控Nginx状态
监控网络连接状态
5.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：监控Nginx服务状态

1）准备环境，部署nginx软件
安装nginx软件，开启status模块
[root@web2 ~]# yum -y install gcc pcre-devel  openssl-devel
[root@zabbixsrever ~]# tar -xvf /Zabbix/nginx-1.12.2.tar.gz
[root@web1 ~]# cd /Zabbix/nginx-1.12.2/
[root@zabbixclient_web2 nginx-1.12.2]# ./configure --with-http_stub_status_module 
[root@web2 nginx-1.12.2]# make && make install
[root@web2 ~]# cat /usr/local/nginx/conf/nginx.conf  
… …
location /status {
                stub_status on;
        }
… …
[root@web2 ~]# /usr/local/nginx/sbin/nginx 
[root@web2 ~]# curl  http://192.168.2.100/status
Active connections: 1 
server accepts handled requests
10 10 3 
Reading: 0 Writing: 1 Waiting: 0

2）自定义监控key
语法格式：
UserParameter=key,command
UserParameter=key[*],<command>
key里的所有参数，都会传递给后面命令的位置变量
如：
UserParameter=ping[*],echo $1
ping[0]，	返回的结果都是0
ping[aaa]，	返回的结果都是aaa
注意：被监控端修改配置文件，注意要允许自定义key并设置Include！
创建自定义key
[root@zabbixclient_web1 ~]# vim /usr/local/etc/zabbix_agentd.conf.d/nginx.status
UserParameter=nginx.status[*],/usr/local/bin/nginx_status.sh $1
[root@zabbixclient_web1 ~]# killall zabbix_agentd  #杀死zabbix_agentd进程
[root@zabbixclient_web1 ~]# zabbix_agentd          #重启服务

自定义监控脚本（仅供参考，未检测完整状态）
[root@zabbixclient_web1 ~]# vim /usr/local/bin/nginx_status.sh
#!/bin/bash
case $1 in
active)
    curl -s http://192.168.2.100/status |awk '/Active/{print $NF}';;
waiting)
    curl -s http://192.168.2.100/status |awk '/Waiting/{print $NF}';;
accepts)
    curl -s http://192.168.2.100/status |awk 'NR==3{print $2}';;
esac
[root@zabbixclient_web1 ~]# chmod +x  /usr/local/bin/nginx_status.sh

测试效果：
[root@zabbixclient_web1 ~]# zabbix_get  -s 127.0.0.1 -k 'nginx.status[accepts]'


=====================================================================
Zabbix主动监控


3.1 问题
沿用前面的练习，配置Zabbix主动监控，实现以下目标：
   1.修改被监控主机agent为主动监控模式
   2.克隆模板，修改模板为主动监控模板
   3.添加监控主机，并链接主动监控模板


3.2 方案
默认zabbix采用的是被动监控，主动和被动都是对被监控端主机而言的！
被动监控：Server向Agent发起连接，发送监控key，Agent接受请求，响应监控数据。
主动监控：Agent向Server发起连接，Agent请求需要检测的监控项目列表，Server响应Agent发送一个items列表，Agent确认收到监控列表，TCP连接完成，会话关闭，Agent开始周期性地收集数据。
区别：Server不用每次需要数据都连接Agent，Agent会自己收集数据并处理数据，Server仅需要保存数据即可。
当监控主机达到一定量级后，Zabbix服务器会越来越慢，此时，可以考虑使用主动监控，释放服务器的压力。
另外，Zabbix也支持分布式监控，也是可以考虑的方案。


3.3 步骤
实现此案例需要按照如下步骤进行。
步骤一：添加被监控主机
1）为被监控主机安装部署zabbix agent
注意：前面的实验，我们已经在zabbixclient_web2主机安装部署了zabbix agent，如果已经完成，则如下操作可以忽略。
[root@zabbixclient_web2 ~]# yum -y install gcc pcre-devel
[root@zabbixclient_web2 ~]# tar -xf zabbix-3.4.4.tar.gz 
[root@zabbixclient_web2 ~]# cd zabbix-3.4.4/
[root@zabbixclient_web2 ~]#./configure --enable-agent
[root@zabbixclient_web2 ~]# make && make install
例:
[root@web1 ~]# yum -y install gcc pcre-devel
[root@web1 ~]# cd /Zabbix/
[root@web1 Zabbix]# cd zabbix-3.4.4
[root@web1 zabbix-3.4.4]# ./configure --enable-agent
[root@web1 zabbix-3.4.4]#  make && make install


2）修改agent配置文件

将agent监控模式修改为主动模式。

[root@zabbixclient_web2 ~]# vim /usr/local/etc/zabbix_agentd.conf 
#Server=127.0.0.1,192.168.2.5
//注释该行，允许谁监控本机
StartAgents=0			
//被动监控时启动多个进程
//设置为0，则禁止被动监控，不启动zabbix_agentd服务
ServerActive=192.168.2.5
//允许哪些主机监控本机（主动模式），一定要取消127.0.0.1
Hostname=zabbixclient_web2
//告诉监控服务器，是谁发的数据信息
//一定要和zabbix服务器配置的监控主机名称一致（后面设置）
RefreshActiveChecks=120
//默认120秒检测一次
UnsafeUserParameters=1			
//允许自定义key
Include=/usr/local/etc/zabbix_agentd.conf.d/
[root@zabbixclient_web2 ~]# killall zabbix_agentd  #关闭服务
[root@zabbixclient_web2 ~]# zabbix_agentd		 #启动服务
例:
[root@web1 ~]# vim /usr/local/etc/zabbix_agentd.conf
93 #Server=127.0.0.1,192.168.2.5
118 StartAgents=0
134 ServerActive=192.168.2.5
145 Hostname=web1
183 RefreshActiveChecks=120
280 UnsafeUserParameters=1
261 Include=/usr/local/etc/zabbix_agentd.conf.d/
[root@web1 ~]# killall zabbix_agentd
[root@web1 ~]# zabbix_agentd

步骤二：创建主动监控的监控模板
1）克隆Zabbix自动的监控模板
为了方便，克隆系统自带模板（在此基础上就该更方便）。
通过Configuration（配置）-->Templates（模板）-->选择Template OS Linux
-->全克隆，克隆该模板，新建一个新的模板。如图-24所示。
新模板名称为：Template OS Linux ServerActive。


============================================================================
自定义监控案例

5.1 问题

沿用前面的练习，使用自定义key监控常用监控项目，实现以下目标：
  1.监控Nginx状态
  2.监控网络连接状态


5.2 步骤
实现此案例需要按照如下步骤进行。
步骤一：监控Nginx服务状态
1）准备环境，部署nginx软件
安装nginx软件，开启status模块
[root@zabbixclient_web1 nginx-1.12.2]# ./configure \
> --with-http_stub_status_module 
[root@zabbixclient_web1 nginx-1.12.2]# make && make install
[root@zabbixclient_web1 ~]# cat /usr/local/nginx/conf/nginx.conf
… …
location /status {
                stub_status on;
        }
… …
[root@zabbixclient_web1 ~]# curl  http://192.168.2.100/status
Active connections: 1 
server accepts handled requests
10 10 3 
Reading: 0 Writing: 1 Waiting: 0
例:


security_day03=========================================================================================================

Linux基本防护措施


Linux系统的基本防护措施，完成以下任务：

修改用户zhangsan的账号属性，设置为2019-12-31日失效（禁止登录）
临时锁定用户lisi的账户，使其无法登录，验证效果后解除锁定
修改tty终端提示，使得登录前看到的第一行文本为“Windows Server 2012 Enterprise R2”，第二行文本为“NT 6.2 Hybrid”
锁定文件/etc/resolv.conf、/etc/hosts，以防止其内容被无意中修改

步骤一：修改用户zhangsan的账户属性，设置为2019-12-31日失效（禁止登录）

1）正常情况下，未过期的账号可以正常登录，使用chage可以修改账户有效期。
chage命令的语法格式：
chage –l	账户名称    #查看账户信息
chage –E 时间 账户名称   #修改账户有效期
例:
[root@web1 ~]# chage -l zhai
[root@web1 ~]# chage -E 2019-6-30 zhai
帐户过期时间		：6月 30, 2019

2）失效的用户将无法登录
使用chage命令将用户zhangsan的账户设为当前已失效（比如已经过去的某个时间）：
[root@proxy ~]# useradd zhangsan
[root@proxy ~]# chage -E 2019-12-31 zhangsan
尝试以用户zhangsan重新登录，输入正确的用户名、密码后直接闪退，返回登录页，说明此帐号已失效。

3）重设用户zhangsan的属性，将失效时间设为2019-12-31
[root@proxy ~]# chage -E 2019-12-31 zhangsan  #修改失效日期
[root@proxy ~]# chage -l zhangsan    	   #查看账户年龄信息
Last password change 					: May 15, 2017
Password expires   					: never
Password inactive   					: never
Account expires  						: Dec 31, 2019
Minimum number of days between password change  		: 0
Maximum number of days between password change   		: 99999
Number of days of warning before password expires 	: 7

4）定义默认有效期（扩展知识）
/etc/login.defs这个配置文件，决定了账户密码的默认有效期。
[root@proxy ~]# cat /etc/login.defs
PASS_MAX_DAYS	99999	       #密码最长有效期
PASS_MIN_DAYS	0            #密码最短有效期
PASS_MIN_LEN	5	       #密码最短长度
PASS_WARN_AGE	7            #密码过期前几天提示警告信息
UID_MIN                  1000	 #UID最小值
UID_MAX                  60000	 #UID最大值
例:
[root@web1 ~]# vim /etc/login.defs
25 PASS_MAX_DAYS   99
26 PASS_MIN_DAYS   0
27 PASS_MIN_LEN    6
28 PASS_WARN_AGE   10
33 UID_MIN                 2000
34 UID_MAX                 80000
[root@web1 ~]# useradd lisi
[root@web1 ~]# chage -l lisi
最近一次密码修改时间			     ：6月 29, 2019
密码过期时间				     ：10月 06, 2019
密码失效时间				     ：从不
帐户过期时间				     ：从不
两次改变密码之间相距的最小天数	     ：0
两次改变密码之间相距的最大天数	     ：99
在密码过期之前警告的天数	             ：10


步骤二：临时锁定用户zhangsan的账户，使其无法登录，验证效果后解除锁定

1）锁定用户账号
使用passwd或usermod命令将用户zhangsan的账户锁定。
[root@proxy ~]# passwd -l zhangsan   #锁定用户账号lock
锁定用户 zhangsan 的密码。
passwd: 操作成功
例:
[root@web1 ~]# useradd lisi
[root@web1 ~]# echo 123456 | passwd --stdin lisi
[root@web1 ~]# su - zhai
[zhai@web1 ~]$ su - lisi
[root@web1 ~]# passwd -l lisi  #账户锁定密码
锁定用户 lisi 的密码 。
passwd: 操作成功
[zhai@web1 ~]$ su - lisi
Password: 
su: Authentication failure
[root@web1 ~]# passwd -S lisi
lisi LK 2019-06-29 0 99 10 -1 (密码已被锁定。)

2）验证用户zhangsan已无法登录，说明锁定生效
输入正确的用户名、密码，始终提示“Login incorrect”，无法登录。

3）解除对用户zhangsan的锁定
[root@proxy ~]# passwd -u zhangsan  #解锁用户账号
解锁用户 zhangsan 的密码 。
passwd: 操作成功
[root@proxy ~]# passwd -S zhangsan  #查看状态
zhangsan PS 2018-08-14 0 99999 7 -1 (密码已设置，使用 SHA512 加密。)
例:
[root@web1 ~]# passwd -u lisi  #解锁用户账号
解锁用户 lisi 的密码。
passwd: 操作成功
[root@web1 ~]# passwd -S lisi  #查看状态,S(大写)
lisi PS 2019-06-29 0 99 10 -1 (密码已设置，使用 SHA512 算法。)


步骤三：修改tty登录的提示信息，隐藏系统版本
1）账户在登录Linux系统时，默认会显示登陆信息（包括操作系统内核信息）
/etc/issue这个配置文件里保存的就是这些登陆信息，修改该文件防止内核信息泄露。
[root@proxy ~]# cat /etc/issue  #确认原始文件
Red Hat Enterprise Linux Server release 6.5 (Santiago)
Kernel \r on an \m
[root@proxy ~]# cp /etc/issue /etc/issue.origin  #备份文件
[root@proxy ~]# vim /etc/issue                   #修改文件内容
Windows Server 2012 Enterprise R2
NT 6.2 Hybrid
例:
[root@web1 ~]# vim /etc/issue
fdkzhaidlka;ffdsfaf  #随便修改

2）测试版本伪装效果
退出已登录的tty终端，或者重启Linux系统，刷新后的终端提示信息会变成自定义的文本内容


步骤四：锁定文件/etc/resolv.conf、/etc/hosts

1）语法格式：
# chattr +i  文件名  #锁定文件（无法修改、删除等）
# chattr -i  文件名  #解锁文件
# chattr +a  文件名  #锁定后文件仅可追加
# chattr -a  文件名  #解锁文件
# lsattr 文件名	 #查看文件特殊属性

2) 使用+i锁定文件，使用lsattr查看属性
[root@proxy ~]# chattr +i /etc/resolv.conf 
[root@proxy ~]# lsattr /etc/resolv.conf 
----i---------- /etc/resolv.conf
例:
[root@web1 ~]# chattr +i /etc/resolv.conf  #锁定文件（无法修改、删除等）
[root@web1 ~]# lsattr /etc/resolv.conf
----i----------- /etc/resolv.conf
[root@web1 ~]# echo "fdsfds" >> /etc/resolv.conf  #操作修改
-bash: /etc/resolv.conf: 权限不够
[root@web1 ~]# rm -rf /etc/resolv.conf  #操作删除
rm: 无法删除"/etc/resolv.conf": 不允许的操作
[root@web1 ~]# lsattr /etc/resolv.conf  #查看文件特殊属性
----i----------- /etc/resolv.conf

3）使用+a锁定文件(仅可追加)，使用lsattr查看属性
[root@proxy ~]# chattr +a /etc/hosts
[root@proxy ~]# lsattr /etc/hosts
-----a---------- /etc/hosts
例:
[root@web1 ~]# chattr +a /etc/hosts  #仅可追加
[root@web1 ~]# lsattr /etc/hosts     #查看文件特殊属性
-----a---------- /etc/hosts
[root@web1 ~]# echo "192.168.4.5 web1" > /etc/hosts
-bash: /etc/hosts: 不允许的操作
[root@web1 ~]# echo "192.168.4.5 web1" >> /etc/hosts #追加

5）恢复这两个文件原有的属性（避免对后续实验造成影响）
[root@proxy ~]# chattr -i /etc/resolv.conf 
[root@proxy ~]# chattr -i /etc/hosts
[root@proxy ~]# lsattr /etc/resolv.conf /etc/hosts
--------------- /etc/resolv.conf
--------------- /etc/hosts
例:
[root@web1 ~]# lsattr /etc/hosts /etc/resolv.conf
-----a---------- /etc/hosts
----ia---------- /etc/resolv.conf
[root@web1 ~]# chattr -a /etc/hosts         #恢复特殊属性
[root@web1 ~]# chattr -ia /etc/resolv.conf  #恢复特殊属性
[root@web1 ~]# lsattr /etc/hosts /etc/resolv.conf
---------------- /etc/hosts
---------------- /etc/resolv.conf


================================================================
使用sudo分配管理权限


要求利用sudo机制分配管理操作权限，主要完成以下任务：
1. 使用su命令临时切换账户身份，并执行命令
2. 允许softadm管理系统服务的权限
3. 允许用户useradm通过sudo方式添加/删除/修改除root以外的用户账号
4. 允许wheel组成员以特权执行所有命令
5. 为sudo机制启用日志记录，以便跟踪sudo执行操作


2.2 步骤
实现此案例需要按照如下步骤进行。

步骤一：使用su命令临时切换账户身份，并以root执行命令
su(Substitute User)命令可以快速切换账户身份，普通用户切换账户身份时需要输入密码，root使用su命令切换任何身份都不需要密码，如法格式如下：
# su -  [账户名称]
# su -  [账户名称]  -c '命令'  

1)从普通用户切换为root账户身份(如果没有普通账户则需要先创建)
[zhangsan@proxy ~]# whoami
zhangsan
[zhangsan@proxy ~]# su -	  #切换账户，默认切换为root账户
密码:                              #输入root的密码
[root@proxy ~]# whoami	  #确认结果
root
例:
[root@web1 ~]# whoami  #显示当前登录的用户
root
[root@web1 ~]# su - zhai
[zhai@web1 ~]$ su -  #切换账户，默认切换为root账户
Password: 
[root@web1 ~]# whoami
root

2)以普通身份创建文件(如果没有普通账户则需要先创建)，以root身份重启服务
[root@proxy ~]# su - zhangsan  -c "touch /tmp/test.txt"  #管理员切换普通用户
[root@proxy ~]# ll  /tmp/test.txt
例:
[root@web1 ~]# su - zhai -c "touch /home/zhai/test.txt"  #以root身份给普通用户创建文件
[root@web1 ~]# su - zhai
[zhai@web1 ~]$ ls
test.txt

[zhangsan@proxy ~]# su - -c "systemctl restart sshd"  #在普通用户环境,以管理员重启服务
例1:
[root@web1 ~]# su - zhai
[zhai@web1 ~]$ su - -c "systemctl restart sshd"  #以管理员重启服务
Password:                                        #输入root的密码
例:
[root@web1 ~]# su - zhai
[zhai@web1 ~]$ su - -c "systemctl restart sshd"  
Password: 
[zhai@web1 ~]$ logout
[root@web1 ~]# netstat -nuptl | grep sshd
tcp        0      0 0.0.0.0:22         0.0.0.0:*       LISTEN      1619/sshd


步骤二：允许softadm管理系统服务的权限

1）修改/etc/sudoers配置
修改/etc/sudoers可以直接使用vim编辑该文件，或使用visudo命令修改该文件。
为softadm授予相关脚本的执行权限，允许通过systemctl工具来管理系统服务。
如果没有softadm账户可以先创建该账户。
[root@proxy ~]# useradd softadm
[root@proxy ~]# vim /etc/sudoers  #修改文件后，需要使用wq强制保存
.. ..
softadm    localhost,主机名=/sbin/* 		
例:
[root@web1 ~]# useradd zhaiyanquan
[root@web1 ~]# vim /etc/sudoers  #设置zhaiyanquan用户可以访问/sbin/下的命令
93 zhaiyanquan localhost,web1=/sbin/*
[root@web1 ~]# su - zhaiyanquan  #切换用户
[zhaiyanquan@web1 ~]$ sudo -l    #列出可以执行权限
User zhaiyanquan may run the following commands on web1:
    (root) /sbin/*
[zhaiyanquan@web1 ~]$ sudo fdisk -l  #列出可以分区的磁盘
   Device Boot      Start         End      Blocks   Id  System
/dev/vda1   *        2048    62914526    31456239+  83  Linux
[zhaiyanquan@web1 ~]$ sudo fdisk /dev/vda1  #执行分区命令
Command (m for help):

2）切换为softadm用户，并验证sudo执行权限
[root@proxy ~]# vim /etc/sudoers  #修改文件后，需要使用wq强制保存
.. ..
softadm    ALL=(ALL)   /usr/bin/systemctl 		
//授权softadm以root身份执行systemctl命令（ALL包括root）

[root@proxy ~]# su - softadm
[softadm@proxy ~]$ sudo -l
… …
[sudo] password for softadm:  #输入softadm的口令
.. ..
用户 softadm 可以在该主机上运行以下命令：
    (ALL) /usr/bin/systemctl
[softadm@proxy ~]$ systemctl start httpd  #不用sudo时启动服务失败
Authentication is required
.. ..
[softadm@proxy ~]$ sudo systemctl restart httpd  #通过sudo启动服务成功
例:
[root@web1 ~]# useradd zyq                       #创建用户
[root@web1 ~]# echo 123456 | passwd --stdin zyq  #给用户设置密码
[root@web1 ~]# vim /etc/sudoers                  #设置zyq用户可以使用systemctl命令
94 zyq ALL=(ALL) /usr/bin/systemctl
[root@web1 ~]# su - zyq                     #切换用户
[zyq@web1 ~]$ systemctl restart httpd       #不用sudo时启动服务失败
[zyq@web1 ~]$ sudo systemctl restart httpd  #通过sudo启动服务成功


步骤三：允许用户useradm通过sudo方式添加/删除/修改除root以外的用户账号

1）修改/etc/sudoers配置
为useradm授予用户管理相关命令的执行权限，例外程序以!符号取反，放在后面。在执行相关程序时，可以利用通配符*。
[root@proxy ~]# useradd useradm
[root@proxy ~]# vim /etc/sudoers
.. ..
useradm ALL=(ALL)  /usr/bin/passwd,!/usr/bin/passwd root,/usr/sbin/user*,!/usr/sbin/user* * root


2）切换为useradm用户，验证sudo权限

可以通过sudo方式来添加/删除/修改普通用户：

[useradm@proxy ~]$ sudo -l
.. ..
用户useradm可以在该主机上运行以下命令：
    (root) /usr/bin/passwd, !/usr/bin/passwd root, /usr/sbin/user*,
!/usr/sbin/user* * root
[useradm@proxy ~]$ sudo useradd newuser01  #可以添加用户
[useradm@proxy ~]$ sudo passwd newuser01   #可以修改普通用户的口令
更改用户 newuser01 的密码 。
新的 密码：
重新输入新的 密码：
passwd： 所有的身份验证令牌已经成功更新。
但是不能修改root用户的密码：
[useradm@proxy ~]$ sudo passwd root
对不起，用户 useradm 无权以 root 的身份在 localhost 上
执行 /usr/bin/passwd root。
[root@web1 ~]# vim /etc/sudoers
99 zhaiuser ALL=(ALL)  /usr/bin/passwd,/usr/bin/useradd/,NOPASSWD: ALL  #NOPASSWD: ALL是执行命令时不用输入密码
[root@web1 ~]# useradd zhaiuser #创建用户zhaiuser
[root@web1 ~]# echo "123456" | passwd --stdin zhaiuser
[root@web1 ~]# su - zhaiuser
[zhaiuser@web1 ~]$ sudo useradd zhai01  #可以添加用户
[zhaiuser@web1 ~]$ sudo passwd zhai01   #可以修改普通用户的口令
[zhaiuser@web1 ~]$ sudo passwd root     #现在还可以修改root密码
[root@web1 ~]# vim /etc/sudoers         #设置普通用户不能修改root密码
99 zhaiuser ALL=(ALL)  /usr/bin/passwd,!/usr/bin/passwd root,/usr/bin/useradd/ #加NOPASSWD: ALL取反会失效
[zhaiuser@web1 ~]$ sudo passwd root  #测试修改root密码
Sorry, user zhaiuser is not allowed to execute '/bin/passwd root' as root on web1. #普通用户修改root密码失败


步骤五：为sudo机制启用日志记录，以便跟踪sudo执行操作

1）修改/etc/sudoers配置，添加日志设置
[root@proxy ~]# visudo
Defaults  logfile="/var/log/sudo"
.. ..
例:
[root@web1 ~]# cat /var/log/sudo
cat: /var/log/sudo: 没有那个文件或目录
[root@web1 ~]# vim /etc/sudoers
66 Defaults logfile="/var/log/sudo"
[root@web1 ~]# su - zhaiuser      #切换用户
[zhaiuser@web1 ~]$ sudo -l        #查看授权的sudo操作
[root@web1 ~]# cat /var/log/sudo  #再次查看日记文件
Jun 29 18:33:43 : zhaiuser : TTY=pts/0 ; PWD=/home/zhaiuser ; USER=root ;
    COMMAND=list


============================================================================
sudo别名设置


主要用途
  提高可重用性,易读性
  简化配置,使记录更加有条理
[root@web1 ~]# vim /etc/sudoers
 95 User_Alias MYUSER=yan,quan       #设置多个用户别名
 96 Host_Alias MYSER=localhost,web1  #设置主机名别名
 97 Cmnd_Alias MYCMND=/user/bin/rpm,/usr/bin/yum,/usr/bin/vim/,/etc/my.cnf,/usr/bin/systemctl * mysqld  #提权命令
 98 MYUSER MYSER=MYCMND,NOPASSWD: ALL  #NOPASSWD: ALL是执行命令时不用输入密码
[root@web1 ~]# useradd yan
[root@web1 ~]# useradd quan
[root@web1 ~]# echo 123456 | passwd --stdin yan
[root@web1 ~]# echo 123456 | passwd --stdin quan
[student@room9pc01 ~]$ ssh -X yan@192.168.2.100
[yan@web1 ~]$ sudo -l  #查看可以执行命令
用户 yan 可以在 web1 上运行以下命令：
    (root) /user/bin/rpm, /usr/bin/yum, /usr/bin/vim/, /etc/my.cnf, /usr/bin/systemctl * mysqld, NOPASSWD: ALL=
[yan@web1 ~]$ sudo yum -y install vsftpd  #测试命令


============================================================================================
提高SSH服务安全

要求提高Linux主机上SSH服务端的安全性，完成以下任务：
  1. 配置基本安全策略（禁止root、禁止空口令）
  2. 针对SSH访问采用仅允许的策略，未明确列出的用户一概拒绝登录
  3. 实现密钥验证登录（私钥口令）、免密码登入
  4. 确认密钥验证使用正常后，禁用口令验证


实现此案例需要按照如下步骤进行。

步骤一：配置基本安全策略

1）调整sshd服务配置，并重载服务

[root@proxy ~]# vim /etc/ssh/sshd_config
.. ..
Protocol 2               #SSH协议
PermitRootLogin no  	#禁止root用户登录
PermitEmptyPasswords no  #禁止密码为空的用户登录
UseDNS  no  	      #不解析客户机地址
LoginGraceTime  1m  	#登录限时
MaxAuthTries  3  		#每连接最多认证次数
.. ..
[root@proxy ~]# systemctl restart sshd
例:
[root@web1 ~]# vim /etc/ssh/sshd_config 
 17 Protocol 2                 #启用SSH V2版本协议
 18 Port 220                   #设置ssh端口号
 39 PermitRootLogin no         #禁止root用户登录
 52 PasswordAuthentication no  #不允许使用密码登录
 65 PermitEmptyPasswords no    #禁止密码为空的用户登录
 43 PubkeyAuthentication yes   #可以使用公钥登录
 116 UseDNS no                 #不解析客户机地址
 38 LoginGraceTime 2m          #登录限时,2m表示2分钟后才再可以登录
 41 MaxAuthTries 3             #每连接最多认证次数,3次
[root@web1 ~]# systemctl restart sshd


2）测试基本安全策略
尝试以root用户SSH登录，失败：
[root@proxy ~]# ssh root@192.168.4.5
root@192.168.4.5's password:
Permission denied, please try again.
将服务器上用户kate(如无该账户则先创建)的密码设为空，尝试SSH登录，也会失败：
[root@proxy ~]# passwd -d kate  #清空用户口令
清除用户的密码 kate。
passwd: 操作成功
[root@proxy ~]# ssh kate@192.168.4.5
kate@192.168.4.5's password:
Permission denied, please try again.


步骤三：实现密钥对验证登录（私钥口令）、免密码登入

1）准备客户机测试环境
为客户机的用户root建立SSH密钥对
使用ssh-keygen创建密钥对，将私钥口令设为空（直接回车）：
例:
[root@web1 ~]# ssh-keygen  #创建秘钥对
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): y
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in y.
Your public key has been saved in y.pub.
The key fingerprint is:
SHA256:fteWbr5vWzId5yr/8xs7W4n4D4PJ0alnDdyVejEcGMA root@web1
The key's randomart image is:
+---[RSA 2048]----+
|          ....o. |
|           E .. o|
|               =.|
|            o + +|
|        S  . * +.|
|       .  . *.=++|
|        . .*.**+=|
|         . .=o+**|
|             *B@@|
+----[SHA256]-----+
[root@client ~]$ ls -lh ~/.ssh/id_rsa*  #确认密钥对文件
-rw-------. 1 root root 1.8K 8月  15 10:35 /root/.ssh/id_rsa
-rw-r--r--. 1 root root  403 8月  15 10:35 /root/.ssh/id_rsa.pub


2）将客户机上用户root的公钥部署到SSH服务器
以用户root登入客户机，使用ssh-copy-id命令将自己的公钥部署到服务器：
[root@client ~]$ ssh-copy-id root@192.168.4.5
root@192.168.4.5's password:
Now try logging into the machine, with "ssh 'root@192.168.4.5'", and check in:
  .ssh/authorized_keys
to make sure we haven't added extra keys that you weren't expecting.

4）在客户机上测试SSH密钥对验证
在客户机用户root的环境中，以远程用户root登入192.168.4.5主机时，无需验证口令即可登入（因为私钥口令为空）：
[root@client ~]$ ssh root@192.168.4.5  #免交互直接登入
Last login: Thu Aug 15 10:48:09 2013 from 192.168.4.100


步骤四：确认密钥验证使用正常后，禁用口令验证
1）调整sshd服务配置，将PasswordAuthentication设为no
[root@proxy ~]# vim /etc/ssh/sshd_config
.. ..
PasswordAuthentication no  #将此行yes改成no
[root@proxy ~]# systemctl restart sshd


====================================================================================
SELinux安全防护

本案例要求熟悉SELinux防护机制的开关及策略配置，完成以下任务：
  1.将Linux服务器的SELinux设为enforcing强制模式
  2.从/root目录下移动一个包文件到FTP下载目录，调整策略使其能够被下载


4.2 步骤
实现此案例需要按照如下步骤进行。
步骤一：将Linux服务器的SELinux设为enforcing强制模式
1）固定配置：修改/etc/selinux/config文件
SELINUX=enforcing	   #设置SELinux为强制模式
SELINUXTYPE=targeted  #保护策略为保护主要的网络服务安全

2）临时配置：使用setenforce命令
查看当前SELinux状态，如果是disabled则需要根据第1）步的配置重启系统；如果是permissive则使用setenforce命令修改为enforcing即可：
[root@proxy ~]# getenforce    #查看当前状态为警告模式
Permissive
[root@proxy ~]# setenforce 1  #设置SELinux为强制模式
[root@proxy ~]# getenforce    #查看当前模式为强制模式
Enforcing
[root@proxy ~]# setenforce 0  #设置SELinux为强制模式
[root@proxy ~]# getenforce    #查看当前模式为警告模式
Permissive


步骤二：在SELinux启用状态下，调整策略打开vsftpd服务的匿名上传访问
1）配置一个允许匿名上传的vsftpd服务作为测试环境
[root@proxy ~]# setenforce 1
[root@proxy ~]# yum -y install vsftpd
.. ..
[root@proxy ~]# vim /etc/vsftpd/vsftpd.conf
anonymous_enable=YES  			   #开启匿名访问
anon_upload_enable=YES  			   #允许上传文件
anon_mkdir_write_enable=YES  		   #允许上传目录
[root@proxy ~]# systemctl start vsftpd  #启动服务
#默认Vsftpd共享目录为/var/ftp/
例:
[root@redisa ~]# vim /etc/vsftpd/vsftpd.conf
[root@redisa ~]# yum -y install vsftpd
12 anonymous_enable=YES
29 anon_upload_enable=YES
33 anon_mkdir_write_enable=YES
[root@redisa ~]# systemctl restart vsftpd


步骤三：从/root目录下移动2个包文件到FTP下载目录，调整文件的安全上下文
1）建立两个FTP下载用的测试文件
由root用户创建两个测试压缩包，一个直接建立到/var/ftp/目录下，另一个先在/root/下建立，然后移动至/var/ftp/目录。
#测试文件1，直接在ftp目录下创建文件
[root@proxy ~]# tar -czf  /var/ftp/log1.tar  /var/log
[root@proxy ~]# ls -lh /var/ftp/
-rw-r--r--. 1 root root 8M 8月  16 10:16 log1.tar
[root@proxy ~]# ls -Z /var/ftp/
-rw-r--r--. root root unconfined_u:object_r:public_content_t:s0 log1.tar
例:
[root@redisa ~]# tar -czf /var/ftp/log1.tar /var/log
[root@redisa ~]# ls -lh /var/ftp #显示文件夹下所有文件,包含易读单位
-rw-r--r-- 1 root root 706K 7月   2 11:26 log1.tar
[root@redisa ~]#  ls -Z /var/ftp/
-rw-r--r-- root root ?                                log1.tar

2) 测试文件2，在/root下建立，然后移动至/var/ftp目录
[root@proxy ~]# tar -czf  log2.tar  /var/log
[root@proxy ~]# mv log2.tar /var/ftp/
[root@proxy ~]# ls -lh /var/ftp/
-rw-r--r--. 1 root root 8M 8月  16 10:16 log2.tar
[root@proxy ~]# ls -Z /var/ftp/
-rw-r--r--. 1 root root unconfined_u:object_r:admin_home_t:s0 log2.tar
例:
[root@redisa ~]# tar -czf log2.tar /var/log
[root@redisa ~]# mv log2.tar /var/ftp/
[root@redisa ~]# ls -lh /var/ftp
-rw-r--r-- 1 root root 706K 7月   2 15:18 log2.tar
3）通过FTP方式测试下载
使用wget命令分别下载这两个包文件，第二个包将会下载失败（看不到文件）。
[root@proxy ~]# wget ftp://192.168.4.5/log1.tar  #下载第一个文件，成功
[root@proxy ~]# wget ftp://192.168.4.5/log2.tar  #下载第二个文件，失败
例:
[root@redisa ~]# yum -y install wget  #如果没有wget命令,要安装wget包
[root@redisa ~]# wget ftp://192.168.4.51/log1.tar  #下载第一个文件，成功
2019-07-02 15:22:40 (789 MB/s) - “log1.tar” 已保存 [722492
[root@redisa ~]# wget ftp://192.168.4.51/log2.tar  #下载第二个文件，失败

4）检查该测试包的安全上下文，正确调整后再次下载第二个包成功。
文件已经存放到共享目录下，但客户端无法访问下载，是因为被SELinux拦截了！
[root@proxy ~]# ls -Z /var/ftp/
-rw-r--r--. root root unconfined_u:object_r:public_content_t:s0 log1.tar
-rw-r--r--. 1 root root unconfined_u:object_r:admin_home_t:s0   log2.tar

[root@proxy ~]# chcon -t public_content_t /var/ftp/d2.tar.gz
[root@proxy ~]# ls -Z /var/ftp/log2.tar
-rw-r--r--. root root unconfined_u:object_r:public_content_t:s0 log2.tar

[root@proxy ~]# wget ftp://192.168.4.5/log2.tar  #再次下载，成功

注意：上例中的chcon操作可替换为（效果相同）：
# restorecon /var/ftp/log2.tar.gz
或者
# chcon --reference=/var/ftp/log1.tar.gz /var/ftp/log2.tar.gz

security_day04=========================================================================================================

加密与解密应用

要求采用gpg工具实现加/解密及软件签名等功能，分别完成以下任务：
  1.检查文件的MD5校验和
  2.使用GPG实现文件机密性保护，加密和解密操作
  3.使用GPG的签名机制，验证数据的来源正确性

方案
加密算法主要有以下几种分类：
1.为确保数据机密性算法：
  a) 对称加密算法(AES,DES)
  b) 非对称加密算法（RSA，DSA）
2.为确保数据完整性算法：
  a) 信息摘要（MD5，SHA256，SHA512）

1） 查看文件改动前的校验和，复制为新文件其校验和不变
[root@proxy ~]# vim file1.txt
abcdef
123456779
[root@proxy ~]# cp file1.txt file2.txt
[root@proxy ~]# cat file1.txt > file3.txt
[root@proxy ~]# md5sum file?.txt  #文件内容一致，则校验和也不变
b92aa0f8aa5d5af5a47c6896283f3536  file1.txt
b92aa0f8aa5d5af5a47c6896283f3536  file2.txt
b92aa0f8aa5d5af5a47c6896283f3536  file3.txt
例:
[root@redisb ~]# echo "fdsafdsfd45464"  >> /test.txt
[root@redisb ~]# md5sum /test.txt  #校验
c04428466e54f37186e8b0e7e10babe1  /test.txt
[root@redisb ~]# md5sum /test.txt  #文件内容一致，则校验和也不变
c04428466e54f37186e8b0e7e10babe1  /test.txt
[root@redisb ~]# echo "2346547657657" >> /test.txt #修改文本内容
[root@redisb ~]# md5sum /test.txt   #再校验
9e50ffcc1227e1f7912ac55b499e9c22  /test.txt
[root@redisb ~]# ls /root/ | md5sum  #校验目录
a320ff84d32a2822bfc7d7cd02aa910f  -
创建文件
[root@redisb ~]# echo "123456" > /test1.txt
[root@redisb ~]# echo "123456" > /test2.txt
[root@redisb ~]# echo "123456fretregf" > /test3.txt
[root@redisb ~]# echo "123456fretregftreterfgds" > /test4.txt
[root@redisb ~]# md5sum /test?.txt  #同时校验多个文件
f447b20a7fcbf53a5d5be013ea0b15af  /test1.txt
f447b20a7fcbf53a5d5be013ea0b15af  /test2.txt
3ed95ebbd0befe36de881d051ae0291f  /test3.txt
a632faeb2ae7a91568d449130473e950  /test4.txt


步骤二：使用GPG对称加密方式保护文件
GnuPG是非常流行的加密软件，支持所有常见加密算法，并且开源免费使用。
1）确保已经安装了相关软件（默认已经安装好了）
[root@proxy ~]# yum -y install gnupg2  #安装软件
[root@proxy ~]# gpg --version          #查看版本
gpg (GnuPG) 2.0.22

2） gpg使用对称加密算法加密数据的操作
执行下列操作：
[root@proxy ~]# gpg -c file2.txt
.. ..
根据提示依次输入两次密码即可。如果是在GNOME桌面环境，设置密码的交互界面会是弹出的窗口程序
根据提示输入两次口令，加密后的文件（自动添加后缀 .gpg）就生成了，传递过程中只要发送加密的文件（比如 file2.txt.gpg）就可以了。
例:
[root@redisb ~]# gpg -c /test4.txt  #加密
[root@redisb ~]# scp -r /test4.txt.gpg root@192.168.4.51:/  #将密文发给对方
[root@redisa ~]# cat /test4.txt.gpg  #查看加密数据为乱码
ŠfY������7#��V�RA�
N��z���o�F�\�6�n�+��"��@>].�~�Y`�=�øt��i*A�
[root@redisa ~]# gpg -d /test4.txt.gpg  #解密,弹出窗口输入加密密码即可
gpg: CAST5 加密过的数据
gpg: 以 1 个密码加密
123456fretregftreterfgds  #是解密内容
gpg: 警告：报文未受到完整的保护

3）使用gpg对加密文件进行解密操作
收到加密的文件后，必须进行解密才能查看其内容。
[root@proxy ~]# gpg -d file2.txt.gpg > file2.txt  #解密后保存
gpg: 3DES 加密过的数据
.. ..                                  #根据提示输入正确密码
[root@proxy ~]# cat file2.txt  #查看解密后的文件
abcdef
123456779
例:
[root@redisa ~]# gpg -d /test4.txt.gpg > /test.txt  #解密后保存
gpg: CAST5 加密过的数据
gpg: 以 1 个密码加密
gpg: 警告：报文未受到完整的保护
[root@redisa ~]# cat /test.txt  #查看解密后的文件
123456fretregftreterfgds


步骤三：使用GPG非对称加密方式保护文件

非对称加密/解密文件时，UserA（192.168.4.100）生成私钥与公钥，并把公钥发送给UserB（192.168.4.5），UserB使用公钥加密数据，并把加密后的数据传给UserA，UserA最后使用自己的私钥解密数据。
实现过程如下所述。
1）接收方UserA创建自己的公钥、私钥对(在192.168.4.100操作)
[root@client ~]# gpg --gen-key  #创建密钥对
… …
请选择您要使用的密钥种类：
   (1) RSA and RSA (default)  #默认算法为RSA
   (2) DSA and Elgamal
   (3) DSA (仅用于签名)
   (4) RSA (仅用于签名)
您的选择?  #直接回车默认(1)
RSA 密钥长度应在 1024 位与 4096 位之间。
您想要用多大的密钥尺寸？(2048)   #接受默认2048位
您所要求的密钥尺寸是 2048 位
请设定这把密钥的有效期限。
         0 = 密钥永不过期
      <n>  = 密钥在 n 天后过期
      <n>w = 密钥在 n 周后过期
      <n>m = 密钥在 n 月后过期
      <n>y = 密钥在 n 年后过期
密钥的有效期限是？(0)  #接受默认永不过期
密钥永远不会过期
以上正确吗？(y/n)y  #输入y确认
You need a user ID to identify your key; the software constructs the user ID
from the Real Name, Comment and Email Address in this form:
    "Heinrich Heine (Der Dichter) <heinrichh@duesseldorf.de>"
真实姓名：UserA
电子邮件地址：UserA@tarena.com
注释：UserA
您选定了这个用户标识：
    “UserA (UserA) <UserA@tarena.com>”
更改姓名(N)、注释(C)、电子邮件地址(E)或确定(O)/退出(Q)？O  #输入大写O确认
您需要一个密码来保护您的私钥。
我们需要生成大量的随机字节。这个时候您可以多做些琐事(像是敲打键盘、移动
鼠标、读写硬盘之类的)，这会让随机数字发生器有更好的机会获得足够的熵数。
gpg: 正在检查信任度数据库
gpg: 需要 3 份勉强信任和 1 份完全信任，PGP 信任模型
gpg: 深度：0 有效性：  1 已签名：  0 信任度：0-，0q，0n，0m，0f，1u
pub   2048R/421C9354 2017-08-16
密钥指纹 = 8A27 6FB5 1315 CEF8 D8A0  A65B F0C9 7DA6 421C 9354
uid                  UserA (UserA) <UserA@tarena.com>
sub   2048R/9FA3AD25 2017-08-16
例:
[userb@redisb ~]$ gpg --gen-key  #创建密钥对
以上正确吗？(y/n)y
真实姓名：zhaiyanquan
电子邮件地址：zhaiyanquan@163.com
注释：djfldksjflds;
[userb@redisb ~]$ rm -rf /home/userb/.gnupg/*    #如果没创建成功,先删除
[root@redisb ~]# mv /dev/random /dev/random1
[root@redisb ~]# ln -s /dev/urandom /dev/random  #重新生成随机数
[userb@redisb ~]$ gpg --gen-key                  #再次创建密钥对
[userb@redisb ~]$ ls -a  
.  ..  .bash_history  .bash_logout  .bash_profile  .bashrc  .gnupg  .mozilla
注意：生产密钥后当前终端可能会变的无法使用，执行reset命令即可，或者关闭后再开一个终端。

2）UserA导出自己的公钥文件(在192.168.4.100操作)
用户的公钥、私钥信息分别保存在pubring.gpg和secring.gpg文件内：
[root@client ~]# gpg --list-keys  #查看公钥环
/root/.gnupg/pubring.gpg
------------------------------
pub   2048R/421C9354 2017-08-16
uid                  UserA (User A) <UserA@tarena.com>
sub   2048R/9FA3AD25 2017-08-16
使用gpg命令结合--export选项将其中的公钥文本导出：
[root@client ~]# gpg -a --export UserA > UserA.pub
#--export的作用是导出密钥，-a的作用是导出的密钥存储为ASCII格式
[root@client ~]# scp UserA.pub 192.168.4.5:/tmp/ 
#将密钥传给Proxy
例:
[root@redisb ~]# gpg --list-keys                      #查看公钥环
[root@redisb ~]# gpg --export zhaiyanquan > zhai.pub  #公钥文本导出
[root@redisb ~]# scp -r /tmp/test03.pub root@192.168.4.51:/
[root@redisb ~]# scp -r zhai.pub root@192.168.2.5:/  #将密钥传给zabbixserver 

3）UserB导入接收的公钥信息（在192.168.4.5操作）
使用gpg命令结合--import选项导入发送方的公钥信息，以便在加密文件时指定对应的公钥。
[root@proxy ~]# gpg --import /tmp/UserA.pub
gpg: 密钥 421C9354：公钥“UserA (UserA) <UserA@tarena.com>”已导入
gpg: 合计被处理的数量：1
gpg:           已导入：1  (RSA: 1) 
例:
[root@zabbixserver ~]# gpg --import /zhai.pub  #导入接收的公钥信息

4) UserB使用公钥加密数据，并把加密后的数据传给UserA（在192.168.4.5操作）
[root@proxy ~]# echo "I love you ." > love.txt
[root@proxy ~]# gpg -e -r UserA love.txt
无论如何还是使用这把密钥吗？(y/N)y   #确认使用此密钥加密文件
# -e选项是使用密钥加密数据
# -r选项后面跟的是密钥，说明使用哪个密钥对文件加密
[root@proxy ~]# scp love.txt.gpg  192.168.4.100:/root  #加密的数据传给UserA
例:
[root@zabbixserver ~]# echo "999999999999999000000" > /test.txt 
[root@zabbixserver ~]# gpg -e -r zhaiyanquan /test.txt  #zhaiyanquan是密钥的用户
无论如何还是使用这把密钥吗？(y/N)y  #确认使用此密钥加密文件
[root@zabbixserver ~]# scp /test.txt.gpg root@192.168.2.100:/  #加密的数据传给web1
[root@web1 ~]# gpg -d /test.txt.gpg > test.txt

5）UserA以自己的私钥解密文件（在192.168.4.100操作）
[root@client ~]# gpg -d love.txt.gpg > love.txt
您需要输入密码，才能解开这个用户的私钥：“UserA (UserA) <UserA@tarena.com>”
2048 位的 RSA 密钥，钥匙号 9FA3AD25，建立于 2017-08-16 (主钥匙号 421C9354)
                                                  #验证私钥口令
gpg: 由 2048 位的 RSA 密钥加密，钥匙号为 9FA3AD25、生成于 2017-08-16
      “UserA (UserA) <UserA@tarena.com>”
[root@client ~]# cat love.txt  #获得解密后的文件内容
I love you.
例:
[root@web1 ~]# gpg -d /test.txt.gpg > test.txt
[root@web1 ~]# cat test.txt
999999999999999000000


步骤四：使用GPG的签名机制，检查数据来源的正确性

使用私钥签名的文件，是可以使用对应的公钥验证签名的，只要验证成功，则说明这个文件一定是出自对应的私钥签名，除非私钥被盗，否则一定能证明这个文件来自于某个人！
1）在client(192.168.4.100)上，UserA为软件包创建分离式签名
将软件包、签名文件、公钥文件一起发布给其他用户下载。
[root@client ~]# tar zcf log.tar /var/log  #建立测试软件包
[root@client ~]# gpg -b log.tar            #创建分离式数字签名
[root@client ~]# ls -lh log.tar*
-rw-rw-r--. 1 root root 170 8月  17 21:18 log.tar
-rw-rw-r--. 1 root root 287 8月  17 21:22 log.tar.sig
[root@client ~]# scp log.tar* 192.168.4.5:/root  #将签名文件与签名传给UserB
例:
[root@web1 ~]# tar -zcf log.tar.gz /var/log  #建立测试软件包
[root@web1 ~]# gpg -b log.tar.gz             #创建分离式数字签名
[root@web1 ~]# ls -lh log.tar*   
[root@web1 ~]# scp log.tar* root@192.168.2.5:/  #将签名文件与签名传给azbbixserver

2）在192.168.4.5上验证签名
[root@proxy ~]# gpg --verify log.tar.sig log.tar
gpg:于2028年06月07日 星期六 23时23分23秒 CST 创建的签名，使用 RSA，钥匙号 421C9354
gpg: 完好的签名，来自于“UserA (UserA) <UserA@tarena.com>”
.. ..
例:
[root@zabbixserver ~]# gpg --verify /log.tar.gz.sig
gpg: 于 2019年07月03日 星期三 17时52分36秒 CST 创建的签名，使用 RSA，钥匙号 E635D962
gpg: 完好的签名，来自于“zhaiyanquan (djfldksjflds;) <zhaiyanquan@163.com>”


=======================================================================
使用AIDE做入侵检测


本案例要求熟悉Linux主机环境下的常用安全工具，完成以下任务操作：
  1.安装aide软件
  2.执行初始化校验操作，生成校验数据库文件
  3.备份数据库文件到安全的地方
  4.使用数据库执行入侵检测操作

2.2 方案
Aide通过检查数据文件的权限、时间、大小、哈希值等，校验数据的完整性。
使用Aide需要在数据没有被破坏前，对数据完成初始化校验，生成校验数据库文件，在被攻击后，可以使用数据库文件，快速定位被人篡改的文件。

2.3 步骤
实现此案例需要按照如下步骤进行。


步骤一：部署AIDE入侵检测系统
1）安装软件包
[root@proxy ~]# yum -y install aide
例:
[root@redisb ~]# yum -y install aide

2) 修改配置文件
确定对哪些数据进行校验，如何校验数据
[root@proxy ~]# vim /etc/aide.conf
@@define DBDIR /var/lib/aide                #数据库目录
@@define LOGDIR /var/log/aide               #日志目录
database_out=file:@@{DBDIR}/aide.db.new.gz  #数据库文件名
//一下内容为可以检查的项目（权限，用户，组，大小，哈希值等）
#p:      permissions
#i:      inode:
#n:      number of links
#u:      user
#g:      group
#s:      size
#md5:    md5 checksum
#sha1:   sha1 checksum
#sha256:        sha256 checksum
DATAONLY =  p+n+u+g+s+acl+selinux+xattrs+sha256
#以下内容设置需要对哪些数据进行入侵校验检查
#注意：为了校验的效率，这里将所有默认的校验目录与文件都注释
#仅保留/root目录，其他目录都注释掉
/root   DATAONLY
#/boot   NORMAL  #对哪些目录进行什么校验
#/bin    NORMAL
#/sbin   NORMAL
#/lib    NORMAL
#/lib64  NORMAL
#/opt    NORMAL
#/usr    NORMAL
#!/usr/src  #使用[!]，设置不校验的目录
#!/usr/tmp
例:
[root@redisb ~]# sed -i '99,312s/^/#/' /etc/aide.conf  
98 /root/   DATAONLY


步骤二：初始化数据库，入侵后检测
1）入侵前对数据进行校验，生成初始化数据库
[root@proxy ~]# aide --init
AIDE, version 0.15.1
AIDE database at /var/lib/aide/aide.db.new.gz initialized.
//生成校验数据库，数据保存在/var/lib/aide/aide.db.new.gz
例:
[root@redisb ~]# aide --init  #入侵前对数据进行校验，生成初始化数据库
AIDE, version 0.15.1
### AIDE database at /var/lib/aide/aide.db.new.gz initialized.

2）备份数据库，将数据库文件拷贝到U盘（非必须的操作）
[root@proxy ~]# cp /var/lib/aide/aide.db.new.gz /media/

3）入侵后检测
[root@proxy ~]# cd /var/lib/aide/
[root@proxy ~]# mv aide.db.new.gz aide.db.gz
[root@proxy ~]# aide --check  #检查哪些数据发生了变化
例:
[root@web1 ~]# aide --init #入侵前对数据进行校验，生成初始化数据库
[root@web1 ~]# ls /root/
Desktop  log.tar.gz  log.tar.gz.sig  test.txt  zhai  zhai.pub  zhai.txt
[root@web1 ~]# echo "fdsfdsf" > zhai.txt  #修改文件和添加文件
[root@web1 ~]# mv /var/lib/aide/aide.db.new.gz /var/lib/aide/aide.db.gz
[root@web1 ~]# aide --check  #检查哪些数据发生了变化


===========================================================================
扫描与抓包分析

3.1 问题
本案例要求熟悉Linux主机环境下的常用安全工具，完成以下任务操作：
  1.使用NMAP扫描来获取指定主机/网段的相关信息
  2.使用tcpdump分析FTP访问中的明文交换信息

3.2 步骤
实现此案例需要按照如下步骤进行。

步骤一：使用NMAP扫描来获取指定主机/网段的相关信息
1）安装软件
[root@proxy ~]# yum -y install nmap
//基本用法：
# nmap  [扫描类型]  [选项]  <扫描目标 ...>
#常用的扫描类型
# -sS，TCP SYN扫描（半开）
# -sT，TCP 连接扫描（全开）
# -sU，UDP扫描
# -sP，ICMP扫描
# -A，目标系统全面分析
例:
[root@redisb ~]# yum -y install nmap

2）检查192.168.4.100主机是否可以ping通
[root@proxy ~]# nmap  -sP  192.168.4.100
Starting Nmap 6.40 ( http://nmap.org ) at 2018-06-06 21:59 CST
mass_dns: warning: Unable to determine any DNS servers. Reverse DNS is disabled. Try using --system-dns or specify valid servers with --dns-servers
Nmap scan report for host3 (192.168.4.100)
Host is up (0.00036s latency).
MAC Address: 52:54:00:71:07:76 (QEMU Virtual NIC)
Nmap done: 1 IP address (1 host up) scanned in 0.02 seconds
例:
[root@room9pc01 ~]# nmap  -sP  192.168.4.51  #检查192.168.4.100主机是否可以ping通
Starting Nmap 6.40 ( http://nmap.org ) at 2019-07-01 15:36 CST
Nmap scan report for 192.168.4.51
Host is up (0.000016s latency).
Not shown: 999 closed ports
PORT   STATE SERVICE
22/tcp open  ssh
MAC Address: 52:54:00:10:7B:54 (QEMU Virtual NIC)
Nmap done: 1 IP address (1 host up) scanned in 0.09 seconds

使用-n选项可以不执行DNS解析
[root@proxy ~]# nmap -n -sP  192.168.4.100
Starting Nmap 6.40 ( http://nmap.org ) at 2018-06-06 22:00 CST
Nmap scan report for 192.168.4.100
Host is up (0.00046s latency).
MAC Address: 52:54:00:71:07:76 (QEMU Virtual NIC)
Nmap done: 1 IP address (1 host up) scanned in 0.03 seconds
例:
[root@redisb ~]# nmap -n -sP 192.168.4.52  #使用-n选项可以不执行DNS解析
Starting Nmap 6.40 ( http://nmap.org ) at 2019-07-01 15:41 CST
Nmap scan report for 192.168.4.52
Host is up.
Nmap done: 1 IP address (1 host up) scanned in 0.00 seconds

3）检查192.168.4.0/24网段内哪些主机可以ping通
[root@proxy ~]# nmap  -n  -sP  192.168.4.0/24
Starting Nmap 5.51 ( http://nmap.org ) at 2017-05-17 18:01 CST
Nmap scan report for 192.168.4.1
Host is up.
Nmap scan report for 192.168.4.7
Host is up.
Nmap scan report for 192.168.4.120
Host is up (0.00027s latency).
MAC Address: 00:0C:29:74:BE:21 (VMware)
Nmap scan report for 192.168.4.110
Host is up (0.00016s latency).
MAC Address: 00:50:56:C0:00:01 (VMware)
Nmap scan report for 192.168.4.120
Host is up (0.00046s latency).
MAC Address: 00:0C:29:DB:84:46 (VMware)
Nmap done: 256 IP addresses (5 hosts up) scanned in 3.57 seconds
例:
[root@room9pc01 ~]# nmap -n -sP 176.121.212.0/24          #检查176.121.212.0/24网段内哪些主机可以ping通
[root@room9pc01 ~]# nmap -n -sP 176.121.212.0/24 | wc -l  #统计176.121.212.0/24网段内在线多少台主机

4）检查目标主机所开启的TCP服务
[root@proxy ~]# nmap -sT 192.168.4.100
Starting Nmap 5.51 ( http://nmap.org ) at 2018-05-17 17:55 CST
Nmap scan report for 192.168.4.100
Host is up (0.00028s latency).
Not shown: 990 closed ports
PORT    STATE SERVICE
21/tcp  open  ftp
22/tcp  open  ssh
25/tcp  open  smtp
80/tcp  open  http
110/tcp open  pop3
111/tcp open  rpcbind
143/tcp open  imap
443/tcp open  https
993/tcp open  imaps
995/tcp open  pop3s
MAC Address: 00:0C:29:74:BE:21 (VMware)
Nmap done: 1 IP address (1 host up) scanned in 1.31 seconds
例:
[root@room9pc01 ~]# nmap -sT 192.168.4.51  #检查目标主机所开启的TCP服务
Starting Nmap 6.40 ( http://nmap.org ) at 2019-07-01 15:50 CST
Nmap scan report for 192.168.4.51
Host is up (0.00043s latency).
Not shown: 999 closed ports
PORT   STATE SERVICE
22/tcp open  ssh
MAC Address: 52:54:00:10:7B:54 (QEMU Virtual NIC)
Nmap done: 1 IP address (1 host up) scanned in 0.09 seconds

5）检查192.168.4.0/24网段内哪些主机开启了FTP、SSH服务
[root@proxy ~]# nmap -p 21-22 192.168.4.0/24
Starting Nmap 5.51 ( http://nmap.org ) at 2017-05-17 18:00 CST
Nmap scan report for 192.168.4.1
Host is up (0.000025s latency).
PORT   STATE SERVICE
21/tcp open  ftp
22/tcp open  ssh
Nmap scan report for 192.168.4.7
Host is up.
PORT   STATE    SERVICE
21/tcp filtered ftp
22/tcp filtered ssh
Nmap scan report for 192.168.4.120
Host is up (0.00052s latency).
PORT   STATE SERVICE
21/tcp open  ftp
22/tcp open  ssh
MAC Address: 00:0C:29:74:BE:21 (VMware)
Nmap scan report for pc110.tarena.com (192.168.4.110)
Host is up (0.00038s latency).
PORT   STATE  SERVICE
21/tcp closed ftp
22/tcp closed ssh
MAC Address: 00:50:56:C0:00:01 (VMware)
Nmap scan report for 192.168.4.120
Host is up (0.00051s latency).
PORT   STATE  SERVICE
21/tcp closed ftp
22/tcp closed ssh
MAC Address: 00:0C:29:DB:84:46 (VMware)
Nmap done: 256 IP addresses (5 hosts up) scanned in 4.88 seconds
例:
[root@room9pc01 ~]# nmap -p 22-200 176.121.212.0/24  #

6）检查目标主机所开启的UDP服务
[root@proxy ~]# nmap   -sU  192.168.4.100  #指定-sU扫描UDP
53/udp   open          domain
111/udp  open          rpcbind

7）全面分析目标主机192.168.4.100和192.168.4.5的操作系统信息
[root@proxy ~]# nmap -A 192.168.4.100,5
Starting Nmap 5.51 ( http://nmap.org ) at 2017-05-17 18:03 CST
Nmap scan report for 192.168.4.100  #主机mail的扫描报告
Host is up (0.0016s latency).
Not shown: 990 closed ports
PORT    STATE SERVICE  VERSION
21/tcp  open  ftp      vsftpd 2.2.2
| ftp-anon: Anonymous FTP login allowed (FTP code 230)
| -rw-r--r--    1 0        0            1719 Aug 17 13:33 UserB.pub
| -rw-r--r--    1 0        0             122 Aug 13 05:27 dl.txt
| drwxr-xr-x    2 14       0            4096 Aug 13 09:07 pub
| -rw-rw-r--    1 505      505           170 Aug 17 13:18 tools-1.2.3.tar.gz
|_-rw-rw-r--    1 505      505           287 Aug 17 13:22 tools-1.2.3.tar.gz.sig
22/tcp  open  ssh      OpenSSH 5.3 (protocol 2.0)
| ssh-hostkey: 1024 86:be:d6:89:c1:2d:d9:1f:57:2f:66:d1:af:a8:d3:c6 (DSA)
|_2048 16:0a:15:01:fa:bb:91:1d:cc:ab:68:17:58:f9:49:4f (RSA)
25/tcp  open  smtp     Postfix smtpd
80/tcp  open  http     Apache httpd 2.2.15 ((Red Hat))
|_http-methods: No Allow or Public header in OPTIONS response (status code 302)
| http-title: 302 Found
|_Did not follow redirect to https://192.168.4.100//
110/tcp open  pop3     Dovecot pop3d
|_pop3-capabilities: USER CAPA UIDL TOP OK(K) RESP-CODES PIPELINING STLS SASL(PLAIN)
111/tcp open  rpcbind
MAC Address: 00:0C:29:74:BE:21 (VMware)
No exact OS matches for host (If you know what OS is running on it, see http://nmap.org/submit/ ).
TCP/IP fingerprint:
OS:SCAN(V=5.51%D=8/19%OT=21%CT=1%CU=34804%PV=Y%DS=1%DC=D%G=Y%M=000C29%TM=52
OS:11ED90%P=x86_64-redhat-linux-gnu)SEQ(SP=106%GCD=1%ISR=10B%TI=Z%CI=Z%II=I
OS:%TS=A)OPS(O1=M5B4ST11NW6%O2=M5B4ST11NW6%O3=M5B4NNT11NW6%O4=M5B4ST11NW6%O
OS:5=M5B4ST11NW6%O6=M5B4ST11)WIN(W1=3890%W2=3890%W3=3890%W4=3890%W5=3890%W6
OS:=3890)ECN(R=Y%DF=Y%T=40%W=3908%O=M5B4NNSNW6%CC=Y%Q=)T1(R=Y%DF=Y%T=40%S=O
OS:%A=S+%F=AS%RD=0%Q=)T2(R=N)T3(R=N)T4(R=Y%DF=Y%T=40%W=0%S=A%A=Z%F=R%O=%RD=
OS:0%Q=)T5(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)T6(R=Y%DF=Y%T=40%W=0%
OS:S=A%A=Z%F=R%O=%RD=0%Q=)T7(R=Y%DF=Y%T=40%W=0%S=Z%A=S+%F=AR%O=%RD=0%Q=)U1(
OS:R=Y%DF=N%T=40%IPL=164%UN=0%RIPL=G%RID=G%RIPCK=G%RUCK=G%RUD=G)IE(R=Y%DFI=
OS:N%T=40%CD=S)
Network Distance: 1 hop
Service Info: Host:  mail.tarena.com; OS: Unix
TRACEROUTE
HOP RTT     ADDRESS
1   1.55 ms 192.168.4.100


=================================================================
使用tcpdump分析FTP访问中的明文交换信息

1）准备Vsftpd服务器（192.168.4.5操作）
[root@proxy ~]# yum -y install vsftpd
[root@proxy ~]# systemctl restart vsftpd
例:
[root@redisb ~]# yum -y install vsftpd
[root@redisb ~]# systemctl restart vsftpd

2）启用tcpdump命令行抓包
执行tcpdump命令行，添加适当的过滤条件，只抓取访问主机192.168.4.5的21端口的数据通信 ，并转换为ASCII码格式的易读文本。
这里假设，192.168.4.5主机有vsftpd服务，如果没有需要提前安装并启动服务！！！
[root@proxy ~]# tcpdump -A host 192.168.4.5 and tcp port 21
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
.. ..                                            #进入等待捕获数据包的状态
#监控选项如下：
# -i，指定监控的网络接口（默认监听第一个网卡）
# -A，转换为 ACSII 码，以方便阅读
# -w，将数据包信息保存到指定文件
# -r，从指定文件读取数据包信息
#tcpdump的过滤条件：
# 类型：host、net、port、portrange
# 方向：src、dst
# 协议：tcp、udp、ip、wlan、arp、……
# 多个条件组合：and、or、not
例:
[root@redisb ~]# tcpdump  #抓所有的包
[root@redisb ~]# tcpdump -c 2 -w zhai.cap  #抓2个包,将数据包信息文件zhai.cap
[root@redisb ~]# tcpdump -r zhai.cap       #读取数据包信息
 
3）执行FTP访问，并观察tcpdump抓包结果
从192.168.4.100访问主机192.168.4.5的vsftpd服务。
[root@client ~]# yum -y install ftp
[root@client ~]# ftp 192.168.4.5
Connected to 192.168.4.200 (192.168.4.200).
220 (vsFTPd 3.0.2)
Name (192.168.4.200:root): tom  #输入用户名
331 Please specify the password.
Password:  #输入密码
530 Login incorrect.
Login failed.
ftp>quit  #退出
例:
在B主机操作
[root@redisb ~]# useradd zyq  
[root@redisb ~]# echo 123456 | passswd --stdin zyq
[root@redisb ~]# yum -y install vsftpd
[root@redisb ~]# systemctl restart vsftpd
[root@redisb ~]# cp /etc/passwd /var/ftp/

在A主机操作
[root@redisa ~]# yum -y install ftp
[root@redisa ~]# ftp 192.168.4.52
Connected to 192.168.4.52 (192.168.4.52).
220 (vsFTPd 3.0.2)
Name (192.168.4.52:root): zyq   #输入用户名
331 Please specify the password.
Password:    #输入密码
230 Login successful.
Remote system type is UNIX.
Using binary mode to transfer files.

观察抓包的结果（回到porxy主机观察tcpdump抓包的结果）：
[root@proxy ~]#
... …
18:47:27.960530 IP 192.168.4.100.novation > 192.168.4.5.ftp: Flags [P.], seq 1:14, ack 21, win 65515, length 13
E..5..@.@......x...d.*..G.\c.1BvP.......USER tom
18:47:29.657364 IP 192.168.4.100.novation > 192.168.4.5.ftp: Flags [P.], seq 14:27, ack 55, win 65481, length 13
E..5..@.@......x...d.*..G.\p.1B.P.......PASS 123

4)再次使用tcpdump抓包，使用-w选项可以将抓取的数据包另存为文件，方便后期慢慢分析。
[root@proxy ~]# tcpdump -A -w ftp.cap host 192.168.4.5 and tcp port 21  #抓包并保存

tcpdump命令的-r选项，可以去读之前抓取的历史数据文件
[root@proxy ~]# tcpdump  -A  -r  ftp.cap | egrep  '(USER|PASS)' #分析数据包
.. ..
E..(..@.@.. ...x...d.*..G.\c.1BbP.............
18:47:25.967592 IP 192.168.4.5.ftp > 192.168.4.100.novation: Flags [P.], seq 1:21, ack 1, win 229, length 20
E..<FJ@.@.jE...d...x...*.1BbG.\cP...V...220 (vsFTPd 2.2.2)
… …
18:47:27.960530 IP 192.168.4.100.novation > 192.168.4.5.ftp: Flags [P.], seq 1:14, ack 21, win 65515, length 13
E..5..@.@......x...d.*..G.\c.1BvP.......USER mickey
… …
18:47:27.960783 IP 192.168.4.5.ftp > 192.168.4.100.novation: Flags [P.], seq 21:55, ack 14, win 229, length 34
E..JFL@.@.j5...d...x...*.1BvG.\pP...i~..331 Please specify the password.
… …
18:47:29.657364 IP 192.168.4.5.ftp > 192.168.4.100.novation: Flags [P.], seq 14:27, ack 55, win 65481, length 13
E..5..@.@......x...d.*..G.\p.1B.P.......PASS pwd123
… …
18:47:29.702671 IP 192.168.4.100.novation > 192.168.4.5.ftp: Flags [P.], seq 55:78, ack 27, win 229, length 23
E..?FN@.@.j>...d...x...*.1B.G.\}P.......230 Login successful.


步骤三：扩展知识，使用tcpdump分析Nginx的明文账户认证信息信息
1）在proxy主机(192.168.4.5)准备一台需要用户认证的Nginx服务器
[root@proxy ~]# cd /usr/local/nginx/conf/
[root@proxy ~]# cp nginx.conf.default  nginx.conf  #还原配置文件
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
server {
  listen 80;
  server_name localhost;
auth_basic "xx";
auth_basic_user_file "/usr/local/nignx/pass";
… …
[root@proxy ~]# htpasswd -c /usr/local/nginx/pass jerry  #创建账户文件
New password:123          #输入密码
Re-type new password:123  #确认密码
[root@proxy ~]# nginx -s reload

2）在proxy主机使用tcpdump命令抓包
[root@proxy ~]# tcpdump  -A  host 192.168.4.5  and  tcp  port  80

3)在真实机使用浏览器访问192.168.4.5
[root@pc001 ~]# firefox  http://192.168.4.5  #根据提示输入用户名与密码

4）回到proxy查看抓包的数据结果
[root@proxy ~]# tcpdump -A host 192.168.4.5 and tcp port 80
tcpdump: verbose output suppressed, use -v or -vv for full protocol decode
listening on eth0, link-type EN10MB (Ethernet), capture size 262144 bytes
… …
Authorization: Basic dG9tOjEyMzQ1Ng==
… …

5) 查看base64编码内容
[root@proxy ~]# echo "dG9tOjEyMzQ1Ng==" | base64 -d
tom:123456
[root@proxy ~]# echo "tom:123456" | base64 
dG9tOjEyMzQ1Ngo=


security_day05=========================================================================================================

部署audit监控文件


本案例要求熟悉audit审计工具的基本使用，完成以下任务操作：
  1.使用audit监控/etc/ssh/sshd_config
  2.当该文件发生任何变化即记录日志
  3.通过手动和ausearch工具查看日志内容

1.2 方案

    审计的目的是基于事先配置的规则生成日志，记录可能发生在系统上的事件（正常或非正常行为的事件），审计不会为系统提供额外的安全保护，但她会发现并记录违反安全策略的人及其对应的行为。
    审计能够记录的日志内容：
   a) 日期与事件以及事件的结果
   b) 触发事件的用户
   c) 所有认证机制的使用都可以被记录，如ssh等
   d) 对关键数据文件的修改行为等都可以被记录


1.3 步骤
实现此案例需要按照如下步骤进行。

步骤一：配置audit审计系统
1）安装软件包，查看配置文件（确定审计日志的位置）
[root@proxy ~]# yum -y  install  audit      #安装软件包
[root@proxy ~]# cat /etc/audit/auditd.conf  #查看配置文件，确定日志位置
log_file = /var/log/audit/audit.log         #日志文件路径
[root@proxy ~]# systemctl start auditd      #启动服务
[root@proxy ~]# systemctl enable auditd     #设置开机自启
例:
[root@redisa ~]# yum -y install audit        #安装软件包
[root@redisa ~]# cat /etc/audit/auditd.conf  #查看配置文件，确定日志位置
log_file = /var/log/audit/audit.log          #日志文件路径

2）配置审计规则
可以使用auditctl命令控制审计系统并设置规则决定哪些行为会被记录日志。
语法格式如下：
[root@proxy ~]# auditctl  -s  #查询状态
[root@proxy ~]# auditctl  -l  #查看规则
[root@proxy ~]# auditctl  -D  #删除所有规则
例:
[root@redisa ~]# auditctl -s  #查询状态
[root@redisa ~]# auditctl -l  #查看规则
[root@redisa ~]# auditctl -D  #删除所有规则

定义临时文件系统规则：
#语法格式：auditctl  -w  path  -p  permission  -k  key_name
# path为需要审计的文件或目录
# 权限可以是r,w,x,a(文件或目录的属性发生变化)
# Key_name为可选项，方便识别哪些规则生成特定的日志项
[root@proxy ~]# auditctl  -w  /etc/passwd  -p wa  -k  passwd_change
#设置规则所有对passwd文件的写、属性修改操作都会被记录审计日志
 [root@proxy ~]# auditctl  -w  /etc/selinux/  -p wa  -k  selinux_change
#设置规则，监控/etc/selinux目录
 [root@proxy ~]# auditctl  -w  /usr/sbin/fdisk  -p x  -k  disk_partition
#设置规则，监控fdisk程序
[root@proxy ~]# auditclt  -w  /etc/ssh/sshd_conf  -p warx  -k  sshd_config
#设置规则，监控sshd_conf文件
例:
[root@redisa ~]# auditctl -w /etc/passwd -p wa -k passwd_change
[root@redisa ~]# auditctl -w /usr/bin/ssh -p x -k  ssh_config
[root@redisa ~]# auditctl -w /etc/ssh/sshd_conf -p warx  -k sshd_config
[root@redisa ~]# auditctl -w /usr/sbin/fdisk -p x -k fdisk_partition
[root@redisa ~]# auditctl -l  #查看规则
-w /etc/passwd -p wa -k passwd_change
-w /usr/bin/ssh -p x -k ssh_config
-w /etc/ssh/sshd_conf -p rwxa -k sshd_config
-w /usr/sbin/fdisk -p x -k fdisk_partition

如果需要创建永久审计规则，则需要修改规则配置文件：
[root@proxy ~]# vim  /etc/audit/rules.d/audit.rules
-w /etc/passwd -p wa -k passwd_changes
-w /usr/sbin/fdisk -p x -k partition_disks
例:
[root@redisa ~]# vim /etc/audit/rules.d/audit.rules  #配置永久审计规则
-w /etc/passwd -p wa -k passwd_change
-w /usr/bin/ssh -p x -k ssh_config
-w /etc/ssh/sshd_conf -p rwxa -k sshd_config
-w /usr/sbin/fdisk -p x -k fdisk_partition


步骤二：查看并分析日志
1）手动查看日志
查看SSH的主配置文件/etc/ssh/sshd_conf，查看audit日志信息：
[root@proxy ~]# tailf  /var/log/audit/audit.log
type=SYSCALL msg=audit(1517557590.644:229228): arch=c000003e 
syscall=2 success=yes exit=3 
a0=7fff71721839 a1=0 a2=1fffffffffff0000 a3=7fff717204c0 
items=1 ppid=7654 pid=7808 auid=0 uid=0 gid=0 euid=0 suid=0 
fsuid=0 egid=0 sgid=0 fsgid=0 tty=pts2 ses=3 comm="cat" 
exe="/usr/bin/cat" 
subj=unconfined_u:unconfined_r:unconfined_t:s0-s0:c0.c1023 key="sshd_config"
.. ..
#内容分析
# type为类型
# msg为(time_stamp:ID)，时间是date +%s（1970-1-1至今的秒数）
# arch=c000003e，代表x86_64（16进制）
# success=yes/no，事件是否成功
# a0-a3是程序调用时前4个参数，16进制编码了
# ppid父进程ID，如bash，pid进程ID，如cat命令
# auid是审核用户的id，su - test, 依然可以追踪su前的账户
# uid，gid用户与组
# tty:从哪个终端执行的命令
# comm="cat"            用户在命令行执行的指令
# exe="/bin/cat"        实际程序的路径
# key="sshd_config"    管理员定义的策略关键字key
# type=CWD        用来记录当前工作目录
# cwd="/home/username"
# type=PATH
# ouid(owner's user id）    对象所有者id
# guid(owner's groupid）    对象所有者id
例:


2）通过工具搜索日志
系统提供的ausearch命令可以方便的搜索特定日志，默认该程序会搜索/var/log/audit/audit.log，ausearch options -if file_name可以指定文件名。
[root@proxy ~]# ausearch -k sshd_config -i    
#根据key搜索日志，-i选项表示以交互式方式操作


========================================================================================
加固常见服务的安全
2.1 问题

本案例要求优化提升常见网络服务的安全性，主要完成以下任务操作：
   1.优化Nginx服务的安全配置
   2.优化MySQL数据库的安全配置
   3.优化Tomcat的安全配置

2.2 方案
  1.Nginx安全优化包括：删除不要的模块、修改版本信息、限制并发、拒绝非法请求、防止buffer溢出。
  2.MySQL安全优化包括：初始化安全脚本、密码安全、备份与还原、数据安全。
  3.Tomcat安全优化包括：隐藏版本信息、降权启动、删除默认测试页面.


2.3 步骤
实现此案例需要按照如下步骤进行。
步骤一：优化Nginx服务的安全配置
1） 删除不需要的模块
Nignx是模块化设计的软件，需要什么功能与模块以及不需要哪些模块，都可以在编译安装软件时自定义，使用--with参数可以开启某些模块，使用--without可以禁用某些模块。最小化安装永远都是对的方案！
下面是禁用某些模块的案例：
[root@proxy ~]# tar -xf nginx-1.12.tar.gz
[root@proxy ~]# cd nginx-1.12
[root@proxy nginx-1.12]# ./configure \
>--without-http_autoindex_module \            //禁用自动索引文件目录模块
>--without-http_ssi_module
[root@proxy nginx-1.12]# make
[root@proxy nginx-1.12]# make install
例:
[student@room9pc01 ~]$ scp nginx-1.12.2.tar.gz root@192.168.4.51:/
[root@redisa ~]# tar -xf /nginx-1.12.2.tar.gz
[root@redisa ~]# cd nginx-1.12.2/
[root@redisa nginx-1.12.2]# yum -y install pcre-devel
[root@redisa nginx-1.12.2]# yum -y install zlib-devel
[root@redisa nginx-1.12.2]# ./configure --without-http_autoindex_module --without-http_ssi_module
[root@redisa nginx-1.12.2]# make && make install
[root@redisa nginx-1.12.2]# /usr/local/nginx/sbin/nginx  #启服务
[root@redisa ~]# mkdir /usr/local/nginx/html/game
[root@redisa ~]# echo 5435234 > /usr/local/nginx/html/game/a.html
[root@redisa ~]# echo 5435234fdsfasd > /usr/local/nginx/html/game/b.html
[root@redisa ~]# echo 5435234fdsfas1111111111d > /usr/local/nginx/html/game/c.html

2） 修改版本信息，并隐藏具体的版本号
默认Nginx会显示版本信息以及具体的版本号，这些信息给攻击者带来了便利性，便于他们找到具体版本的漏洞。
如果需要屏蔽版本号信息，执行如下操作，可以隐藏版本号。
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
… …
http{
     server_tokens off;  #在http下面手动添加这么一行
     … …
}
[root@proxy ~]# nginx -s reload
[root@proxy ~]# curl -I http://192.168.4.5  #查看服务器响应的头部信息
例:

[root@redisa ~]# vim /usr/local/nginx/conf/nginx.conf #修改配置文件
20     server_tokens off;
[root@redisa ~]#  /usr/local/nginx/sbin/nginx -s stop  #关掉服务
[root@redisa ~]#  /usr/local/nginx/sbin/nginx          #重启服务,让配置文件生效
[root@redisa sbin]# curl -I http://192.168.4.51        #看服务器响应的头部信息

但服务器还是显示了使用的软件为nginx，通过如下方法可以修改该信息。
[root@proxy nginx-1.12]# vim +48 src/http/ngx_http_header_filter_module.c
#注意：vim这条命令必须在nginx-1.12源码包目录下执行！！！！！！
#该文件修改前效果如下：
static u_char ngx_http_server_string[] = "Server: nginx" CRLF;
static u_char ngx_http_server_full_string[] = "Server: " NGINX_VER CRLF;
static u_char ngx_http_server_build_string[] = "Server: " NGINX_VER_BUILD CRLF;
#下面是我们修改后的效果：
static u_char ngx_http_server_string[] = "Server: Jacob" CRLF;
static u_char ngx_http_server_full_string[] = "Server: Jacob" CRLF;
static u_char ngx_http_server_build_string[] = "Server: Jacob" CRLF;
#修改完成后，再去编译安装Nignx，版本信息将不再显示为Nginx，而是Jacob
[root@proxy nginx-1.12]# ./configure
[root@proxy nginx-1.12]# make && make install
[root@proxy nginx-1.12]# killall nginx
[root@proxy nginx-1.12]# /usr/local/nginx/sbin/nginx  #启动服务
[root@proxy nginx-1.12]# curl -I http://192.168.4.5   #查看版本信息验证
例:
[root@redisa sbin]# curl -I http://192.168.4.51  #修改前显示信息
HTTP/1.1 200 OK
Server: nginx
Date: Tue, 02 Jul 2019 06:34:46 GMT
Content-Type: text/html
Content-Length: 612
Last-Modified: Tue, 02 Jul 2019 03:53:46 GMT
Connection: keep-alive
ETag: "5d1ad54a-264"
Accept-Ranges: bytes
[root@redisa ~]# cd nginx-1.12.2  #进入nginx-1.12.2目录里
[root@redisa nginx-1.12.2]# vim +48 src/http/ngx_http_header_filter_module.c  #修改配置文件
49 static u_char ngx_http_server_string[] = "Server: zyq" CRLF;
50 static u_char ngx_http_server_full_string[] = "Server:yan " CRLF;
51 static u_char ngx_http_server_build_string[] = "Server:zyq " CRLF;
[root@redisa nginx-1.12.2]# killall nginx
[root@redisa nginx-1.12.2]# /usr/local/nginx/sbin/nginx  #启动服务
[root@redisa nginx-1.12.2]# curl -I http://192.168.4.51 #修改后
HTTP/1.1 200 OK
Server: zyq
Date: Tue, 02 Jul 2019 06:42:01 GMT
Content-Type: text/html
Content-Length: 612
Last-Modified: Tue, 02 Jul 2019 03:53:46 GMT
Connection: keep-alive
ETag: "5d1ad54a-264"
Accept-Ranges: bytes

3） 限制并发量
DDOS攻击者会发送大量的并发连接，占用服务器资源（包括连接数、带宽等），这样会导致正常用户处于等待或无法访问服务器的状态。
Nginx提供了一个ngx_http_limit_req_module模块，可以有效降低DDOS攻击的风险，操作方法如下：
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
… …
http{
… …
limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
    server {
        listen 80;
        server_name localhost;
        limit_req zone=one burst=5;
            }
}
#备注说明：
#limit_req_zone语法格式如下：
#limit_req_zone key zone=name:size rate=rate;
#上面案例中是将客户端IP信息存储名称为one的共享内存，内存空间为10M
#1M可以存储8千个IP信息，10M可以存储8万个主机连接的状态，容量可以根据需要任意调整
#每秒中仅接受1个请求，多余的放入漏斗
#漏斗超过5个则报错
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
例:
[root@redisa ~]# vim /usr/local/nginx/conf/nginx.conf  #修改配置
http{
34 limit_req_zone $binary_remote_addr zone=one:10m rate=1r/s;
    server {
        listen 80;
        server_name localhost;
38        limit_req zone=one burst=5;
            }
}
[root@redisa ~]# /usr/local/nginx/sbin/nginx -s stop    #先停止服务
[root@redisa ~]# /usr/local/nginx/sbin/nginx            #启动服务
[root@redisa ~]# ab -c 100 -n 100 http://192.168.4.51/  #客户端使用ab测试软件测试效果(同一个IP的访问)

4） 拒绝非法的请求
网站使用的是HTTP协议，该协议中定义了很多方法，可以让用户连接服务器，获得需要的资源。但实际应用中一般仅需要get和post。
具体HTTP请求方法的含义
未修改服务器配置前，客户端使用不同请求方法测试：
[root@client ~]# curl -i -X GET  http://192.168.4.5  #正常
[root@client ~]# curl -i -X HEAD http://192.168.4.5  #正常
#curl命令选项说明：
#-i选项：访问服务器页面时，显示HTTP的头部信息
#-X选项：指定请求服务器的方法
例:
[root@room9pc01 ~]# curl -i -X GET http://192.168.4.51
[root@room9pc01 ~]# curl -i -X HEAD http://192.168.4.51

通过如下设置可以让Nginx拒绝非法的请求方法：
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
http{
       server {
                 listen 80;
#这里，!符号表示对正则取反，~符号是正则匹配符号
#如果用户使用非GET或POST方法访问网站，则retrun返回444的错误信息
              if ($request_method !~ ^(GET|POST)$ ) {
                     return 444;
               }    
        }
}
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
例:
[root@redisa ~]# /usr/local/nginx/sbin/nginx -s stop  #先关闭服务
[root@redisa ~]# vim /usr/local/nginx/conf/nginx.conf
server {
 if ($request_method !~ ^(GET|POST)$ ) {
                     return 444;
               }
}
[root@redisa ~]# /usr/local/nginx/sbin/nginx  #启动服务
[root@room9pc01 ~]# curl -i -X GET http://192.168.4.51   #测试正常
[root@room9pc01 ~]# curl -i -X HEAD http://192.168.4.51  #测试报错

4） 防止buffer溢出
当客户端连接服务器时，服务器会启用各种缓存，用来存放连接的状态信息。
如果攻击者发送大量的连接请求，而服务器不对缓存做限制的话，内存数据就有可能溢出（空间不足）。
修改Nginx配置文件，调整各种buffer参数，可以有效降低溢出风险。
[root@proxy ~]# vim /usr/local/nginx/conf/nginx.conf
http{
client_body_buffer_size  1K;
client_header_buffer_size 1k;
client_max_body_size 1k;
large_client_header_buffers 2 1k;
 … …
}
[root@proxy ~]# /usr/local/nginx/sbin/nginx -s reload
例:
[root@redisa ~]# /usr/local/nginx/sbin/nginx -s stop
[root@redisa ~]# vim /usr/local/nginx/conf/nginx.conf
17 http {
 26     client_body_buffer_size  1K;
 27     client_header_buffer_size 1k;
 28     client_max_body_size 1k;
 29     large_client_header_buffers 2 1k;
124 }
[root@redisa ~]# /usr/local/nginx/sbin/nginx  #启动服务


步骤二：数据库安全
1） 初始化安全脚本
安装完MariaDB或MySQL后，默认root没有密码，并且提供了一个任何人都可以操作的test测试数据库。有一个名称为mysql_secure_installation的脚本，该脚本可以帮助我们为root设置密码，并禁止root从远程其他主机登陆数据库，并删除测试性数据库test。
[root@proxy ~]# systemctl status mariadb
#确保服务已启动 
[root@proxy ~]# mysql_secure_installation
#执行初始化安全脚本
例:
[root@redisa ~]# yum -y install mariadb-server mariadb  #安装软件包
[root@redisa ~]# systemctl restart mariadb              #重启服务
[root@redisa ~]# systemctl status mariadb               #确保服务已启动 
[root@redisa ~]# mysql_secure_installation              #执行初始化安全脚本
Enter current password for root (enter for none):       #直接回车即可
Set root password? [Y/n] Y
Remove anonymous users? [Y/n] Y
Disallow root login remotely? [Y/n] Y
Remove test database and access to it? [Y/n] Y
Reload privilege tables now? [Y/n] Y 
Thanks for using MariaDB!

2）密码安全
手动修改MariaDB或MySQL数据库密码的方法：
[root@proxy ~]# mysqladmin -uroot -predhat password 'mysql'
#修改密码，旧密码为redhat，新密码为mysql
[root@proxy ~]# mysql -uroot -pmysql
MariaDB [(none)]>set password for root@'localhost'=password('redhat');
#使用账户登录数据库，修改密码
MariaDB [(none)]> select user,host,password from mysql.user;
+--------+---------+---------------------------------------------+--------------------------------------------------------+
| user     | host     | password                                       |
+--------+---------+---------------------------------------------+--------------------------------------------------------+
| root     | localhost     | *84BB5DF4823DA319BBF86C99624479A198E6EEE9 |
| root     | 127.0.0.1     | *84BB5DF4823DA319BBF86C99624479A198E6EEE9 |
| root     | ::1           | *84BB5DF4823DA319BBF86C99624479A198E6EEE9 |
+--------+-----------+--------------------------------------------+-------------------------------------------------------+
例:
[root@redisa ~]# mysqladmin -uroot -p123456 password "mysql"             #修改数据库root密码
[root@redisa ~]# mysql -uroot -pmysql                                    #连接数据库
MariaDB [(none)]> set password for root@'localhost'=password('redhat');  #使用账户登录数据库，修改密码
MariaDB [(none)]> select user,host,password from mysql.user;

修改密码成功，而且密码在数据库中是加密的，有什么问题吗？问题是你的密码被明文记录了，下面来看看明文密码：
[root@proxy ~]# cat .bash_history   
mysqladmin -uroot -pxxx password 'redhat'
#通过命令行修改的密码，bash会自动记录历史，历史记录中记录了明文密码
[root@proxy ~]# cat .mysql_history 
set password for root@'localhost'=password('redhat');
select user,host,password from mysql.user;
flush privileges;
#通过mysql命令修改的密码，mysql也会有所有操作指令的记录，这里也记录了明文密码
例:
[root@redisa ~]# cat .bash_history           #查看密码被明文记录
[root@redisa ~]# cat .mysql_history          #查看密码被明文记录
[root@redisa ~]# echo " " >  .mysql_history  #清空记录
[root@redisa ~]# echo " " >  .bash_history   #清空记录

3）数据备份与还原
首先，备份数据库（注意用户名为root，密码为redhat）：
[root@proxy ~]# mysqldump -uroot -predhat mydb table > table.sql     #备份数据库中的某个数据表
[root@proxy ~]# mysqldump -uroot -predhat mydb > mydb.sql            #备份某个数据库
[root@proxy ~]# mysqldump -uroot -predhat --all-databases > all.sql  #备份所有数据库
例:
[root@redisa ~]# mysql -uroot -predhat  #连接数据库
MariaDB [(none)]> create database day;  #创建数据
[root@redisa ~]# mysqldump -uroot -predhat day > table.sql            #备份某个数据库
[root@redisa ~]# mysqldump -uroot -predhat --all-databases > all.sql  #备份所有数据库

接下来，还原数据库（注意用户名为root，密码为redhat）：
[root@proxy ~]# mysql -uroot -predhat mydb < table.sql  #还原数据表
[root@proxy ~]# mysql -uroot -predhat mydb < mydb.sql   #还原数据库
[root@proxy ~]# mysql -uroot -predhat < all.sql         #还原所有数据库


步骤三：Tomcat安全性
1） 隐藏版本信息、修改tomcat主配置文件（隐藏版本信息）
未修改版本信息前，使用命令查看服务器的版本信息
注意：proxy有192.168.2.5的IP地址，这里使用proxy作为客户端访问192.168.2.100服务器。
[root@proxy ~]# curl -I http://192.168.2.100:8080/xx  #访问不存在的页面文件，查看头部信息
[root@proxy ~]# curl -I http://192.168.2.100:8080     #访问存在的页面文件，查看头部信息
[root@proxy ~]# curl http://192.168.2.100:8080/xx     #访问不存在的页面文件，查看错误信息

#修改tomcat配置文件，修改版本信息(在192.168.2.100操作)：
[root@web1 tomcat]# yum -y install java-1.8.0-openjdk-devel
[root@web1 tomcat]# cd /usr/local/tomcat/lib/
[root@web1 lib]# tar -xf catalina.jar
[root@web1 lib]# vim org/apache/catalina/util/ServerInfo.properties 
例:
[root@redisa ~]#  yum -y install java-1.8.0-openjdk-devel

#根据自己的需要，修改版本信息的内容
[root@web1 lib]# /usr/local/tomcat/bin/shutdown.sh  #关闭服务
[root@web1 lib]# /usr/local/tomcat/bin/startup.sh   #启动服务

修改后，客户端再次查看版本信息（在192.168.2.5操作）：
[root@proxy ~]# curl -I http://192.168.2.100:8080/xx  #访问不存在的页面文件，查看头部信息
[root@proxy ~]# curl -I http://192.168.2.100:8080     #访问存在的页面文件，查看头部信息
[root@proxy ~]# curl http://192.168.2.100:8080/xx     #访问不存在的页面文件，查看错误信息

2）降级启动
默认tomcat使用系统高级管理员账户root启动服务，启动服务尽量使用普通用户。
[root@web1 ~]# useradd tomcat
[root@web1 ~]# chown -R tomcat:tomcat /usr/local/tomcat/      #修改tomcat目录的权限，让tomcat账户对该目录有操作权限
[root@web1 ~]# su -c /usr/local/tomcat/bin/startup.sh tomcat  #使用su命令切换为tomcat账户，以tomcat账户的身份启动tomcat服务
[root@web1 ~]# chmod +x /etc/rc.local                         #该文件为开机启动文件
[root@web1 ~]# vim /etc/rc.local                              #修改文件，添加如下内容
su -c /usr/local/tomcat/bin/startup.sh tomcat

3）删除默认的测试页面
[root@web1 ~]# rm -rf  /usr/local/tomcat/webapps/*

==============================================================================================
使用diff和patch工具打补丁

本案例要求优化提升常见网络服务的安全性，主要完成以下任务操作：
  1.使用diff对比文件差异
  2.使用diff生成补丁文件
  3.使用patch命令为旧版本打补丁

3.2 方案
  1.程序是人设计出来的，总是会有这样那样的问题与漏洞，目前的主流解决方法就是为有问题的程序打补丁，升级新版本。
  2.在Linux系统中diff命令可以为我们生成补丁文件，然后使用patch命令为有问题的程序代码打补丁。


3.3 步骤
实现此案例需要按照如下步骤进行。
步骤一：对比单个文件差异
1） 编写两个版本的脚本，一个为v1版本，一个为v2版本。
[root@proxy ~]# cat test1.sh  #v1版本脚本
#!/bin/bash
echo "hello wrld"
[root@proxy ~]# cat test2.sh  #v2版本脚本
#!/bin/bash
echo "hello the world"
echo "test file"
例:
[root@client81 ~]# vim /test1.sh  #v1版本脚本
#!/bin/bash
echo "hello wrld zhaiyanquan"
[root@client81 ~]# vim /test2.sh  #v2版本脚本
#!/bin/bash
echo "hello the world  zhaiyanquan"
echo "test file"

2） 使用diff命令语法
使用diff命令查看不同版本文件的差异。
[root@proxy ~]# diff  test1.sh test2.sh  #查看文件差异
@@ -1,3 +1,3 @@
 #!/bin/bash
-echo "hello world"
-echo "test"
+echo "hello the world"
+echo "test file"
[root@proxy ~]# diff -u test1.sh test2.sh  #查看差异，包含头部信息
--- test1.sh    2018-02-07 22:20:02.723971251 +0800
+++ test2.sh    2018-02-07 22:20:13.358760687 +0800
@@ -1,3 +1,3 @@
 #!/bin/bash
-echo "hello world"
-echo "test"
+echo "hello the world"
+echo "test file"
diff制作补丁文件的原理：告诉我们怎么修改第一个文件后能得到第二个文件。
这样如果第一个版本的脚本有漏洞，我们不需要将整个脚本都替换，仅需要修改有问题的一小部分代码即可，diff刚好可以满足这个需求！
像Linux内核这样的大块头，一旦发现有一个小漏洞，我们不可能把整个内核都重新下载，全部替换一遍，而仅需要更新有问题的那一小部分代码即可！
diff命令常用选项：
-u	输出统一内容的头部信息（打补丁使用），计算机知道是哪个文件需要修改
-r	递归对比目录中的所有资源（可以对比目录）
-a	所有文件视为文本（包括二进制程序）
-N	无文件视为空文件（空文件怎么变成第二个文件）
-N选项备注说明：
A目录下没有txt文件，B目录下有txt文件
diff比较两个目录时，默认会提示txt仅在B目录有（无法对比差异，修复文件）
diff比较时使用N选项，则diff会拿B下的txt与A下的空文件对比，补丁信息会明确说明如何从空文件修改后变成txt文件，打补丁即可成功！
例:
[root@client81 ~]# diff -u /test1.sh /test2.sh  #查看差异，包含头部信息
--- /test1.sh	2019-07-04 09:22:04.619689989 +0800  # ---表示减去/test1.sh
+++ /test2.sh	2019-07-04 09:22:26.089689989 +0800
@@ -1,2 +1,3 @@
 #!/bin/bash
-echo "hello wrld zhaiyanquan"
+echo "hello the world  zhaiyanquan"
+echo "test file"

2) 生成补丁文件
[root@proxy demo]# diff -u test1.sh test2.sh > test.patch #生成补丁文件
例:
[root@client81 ~]# diff -u /test1.sh /test2.sh > test.patch
[root@client81 ~]# diff -uaNr /dome/source1 /dome/source2 > /source.patch  #生成补丁文件

3）使用patch命令打补丁
在代码相同目录下为代码打补丁
[root@proxy demo]# yum -y install patch
[root@proxy demo]# patch -p0 < test.patch  #打补丁
patching file test1.sh
#patch -pnum（其中num为数字，指定删除补丁文件中多少层路径前缀）
#如原始路径为/u/howard/src/blurfl/blurfl.c
# -p0则整个路径不变
# -p1则修改路径为u/howard/src/blurfl/blurfl.c
# -p4则修改路径为blurfl/blurfl.c
# -R(reverse)反向修复，-E修复后如果文件为空，则删除该文件
[root@proxy demo]# patch -RE < test.patch   #还原旧版本，反向修复
例:
[root@web81 ~]# yum -y install patch #安装patch包
[root@web81 ~]# mkdir /dome
[root@client81 ~]# scp -r /dome/source1 root@192.168.4.81:/dome
[root@client81 ~]# scp /source.patch root@192.168.4.81:/
[root@web81 ~]# ls /dome/source1/  #打补丁前
find  test.sh
[root@web81 source1]# patch -p3 <  /source.patch  #打补丁
[root@web81 ~]# ls /dome/source1/                 #打补丁后
find  test2.sh  test.sh  tmp.sh
[root@web81 source1]# patch -RE < /source.patch   #还原旧版本，反向修复(撤销补丁)
[root@web81 source1]# ls                          #撤销补丁后
find  test.sh


步骤三：对比目录中所有文件的差异
1） 准备实验环境
[root@proxy ~]# mkdir demo
[root@proxy ~]# cd demo
[root@proxy demo]# mkdir {source1,source2}
[root@proxy demo]# echo "hello world"  > source1/test.sh
[root@proxy demo]# cp /bin/find source1/
[root@proxy demo]#  tree source1/  #source1目录下2个文件
|-- find
`-- test.sh
[root@proxy demo]# echo "hello the world"  > source2/test.sh
[root@proxy demo]# echo "test" > source2/tmp.txt
[root@proxy demo]# cp /bin/find source2/
[root@proxy demo]# echo "1" >> source2/find 
[root@proxy demo]#  tree source2/  #source1目录下3个文件
|-- find
|-- test.sh
`-- tmp.txt
#注意：两个目录下find和test.sh文件内容不同，source2有tmp.txt而source1没有该文件
例:
[root@web481 ~]# mkdir /demo
[root@web481 ~]# cd /demo
[root@web481 demo]# mkdir {sourcel1,source2}
[root@web481 demo]# echo "zhaiyanquan9999" > sourcel1/test.txt
[root@web481 demo]# echo "zhaiyanquan9999" > source2/test.sh
[root@web481 demo]# cp /bin/find sourcel1/

2）制作补丁文件
[root@proxy demo]# diff -u source1/ source2/    #仅对比了文本文件test.sh；二进制文件、tmp都没有对比差异，仅提示，因为没有-a和-N选项
[root@proxy demo]# diff -Nu source1/ source2/   #对比了test.sh，并且使用source2目录的tmp.txt与source1的空文件对比差异。
[root@proxy demo]# diff -Nua source1/ source2/  #对比了test.sh、tmp.txt、find(程序)。
例:
[root@web481 demo]# diff -u sourcel1/ source2/    #仅对比了文本文件test.sh；二进制文件、tmp都没有对比差异，仅提示，因为没有-a和-N选项
[root@web481 demo]# diff -Nu sourcel1/ source2/   #对比了test.sh，并且使用source2目录的tmp.txt与source1的空文件对比差异。
[root@web481 demo]# diff -Nua sourcel1/ source2/  #对比了test.sh、tmp.txt、find(程序)。

步骤四：使用patch命令对目录下的所有代码打补丁
1）使用前面创建的source1和source2目录下的代码为素材，生成补丁文件
[root@proxy ~]# cd demo
[root@proxy demo]# diff -Nuar source1/ source2/ > source.patch
[root@web481 demo]# diff -Nua sourcel1/ source2/
例:
[root@web481 demo]# diff -Nuar sourcel1/ source2/ > source.patch  #生成补丁文件(sourcel1是旧文件,source2新文件)
[root@web481 demo]# diff -Nua sourcel1/ source2/

2）使用patch命令为代码打补丁
[root@proxy demo]# ls
source1  source2  source.patch
[root@proxy demo]# cat source.patch  #对比的文件有路径信息
--- source1/test.sh 2018-02-07 22:51:33.034879417 +0800
+++ source2/test.sh 2018-02-07 22:47:32.531754268 +0800
@@ -1 +1 @@
-hello world
+hello the world
[root@proxy demo]# cd source1
[root@proxy source1]# patch  -p1 < ../source.patch
例:
[root@web481 ~]# ls /demo/source2  #补丁前
test.sh
[root@web481 ~]# cd /demo/sourcel1
[root@web481 sourcel1]# patch -p3 < /demo/source.patch  #开始打补丁
[root@web481 sourcel1]# ls                              #补丁后
find  test.txt


security_day06=========================================================================================================

 


1.1 问题
本案例要求练习iptables命令的使用，按照要求完成以下任务：
   1.关闭firewalld，开启iptables服务
   2.查看防火墙规则
   3.追加、插入防火墙规则
   4.删除、清空防火墙规则


1.2 步骤
实现此案例需要按照如下步骤进行。
步骤一：关闭firewalld，启动iptables服务
1）关闭firewalld服务器
[root@proxy ~]# systemctl stop firewalld.service 
[root@proxy ~]# systemctl disable firewalld.service
例:
[root@porxy80 ~]# systemctl stop firewalld.service
[root@porxy80 ~]# systemctl disable firewalld.service

2）安装iptables-services并启动服务
[root@proxy ~]# yum -y install iptables-services
[root@proxy ~]# systemctl start iptables.service
例:
[root@proxy80 ~]# yum -y install iptables-services
[root@porxy80 ~]# systemctl restart iptables.service
[root@porxy80 ~]# systemctl enable iptables.service 
[root@porxy80 ~]# systemctl status iptables.service  #查看运行状态


步骤二：熟悉iptables框架
1）iptables的4个表（区分大小写）：
iptables默认有4个表，nat表（地址转换表）、filter表（数据过滤表）、raw表（状态跟踪表）、mangle表（包标记表）。
2）iptables的5个链（区分大小写）：
INPUT链（入站规则）
OUTPUT链（出站规则）
FORWARD链（转发规则）
PREROUTING链（路由前规则）
POSTROUTING链（路由后规则）

表名包括：
  raw：高级功能，如：网址过滤。
  mangle：数据包修改（QOS），用于实现服务质量。
  net：地址转换，用于网关路由器。
  filter：包过滤，用于防火墙规则。

规则链名包括：
  INPUT链：处理输入数据包。
  OUTPUT链：处理输出数据包。
  PORWARD链：处理转发数据包。
  PREROUTING链：用于目标地址转换（DNAT）。
  POSTOUTING链：用于源地址转换（SNAT）。

动作包括：
  ACCEPT：接收数据包,允许通过/放行
  DROP：丢弃数据包,不给出任何回应
  REDIRECT：重定向、映射、透明代理。
  SNAT：源地址转换。
  DNAT：目标地址转换。
  MASQUERADE：IP伪装（NAT），用于ADSL。
  LOG：日志记录。

基本的目标操作
  ACCEPT：允许通过/放行
  DROP: 直接丢弃,不给出任何回应
  REJECT:拒绝通过,必要时会给出提升
  LOG: 记录日志,然后传给下一个条规则

选项:
-t<表>：指定要操纵的表； 
-A：向规则链中添加条目； 
-D：从规则链中删除条目； 
-i：向规则链中插入条目； 
-R：替换规则链中的条目； 
-L：显示规则链中已有的条目； 
-F：清楚规则链中已有的条目； 
-Z：清空规则链中的数据包计算器和字节计数器； 
-N：创建新的用户自定义规则链； 
-P：定义规则链中的默认目标； 
-h：显示帮助信息； 
-p：指定要匹配的数据包协议类型； 
-s：指定要匹配的数据包源ip地址； 
-j<目标>：指定要跳转的目标； 
-i<网络接口>：指定数据包进入本机的网络接口； 
-o<网络接口>：指定数据包要离开本机所使用的网络接口。


类别        选项                        用途
添加规则     -A               在链的末尾追加一条规则
          -I               在链的开头(或指定序号)插入一条规则
查看规则     -L               列出所有的规则条目
          -n               以数字形式显示地址 端口等信息
          --line-numbers   查看规则是,显示规则的序号
删除规则     -D               删除链内指定序号(或内容)的条规则
          -F               清空所有的规则
默认策略     -P               为指定的链设置默认规则


添加新的规则
 -A追加  -I插入
[root@web481 ~]# iptables -t filter -A INPUT -p tcp -j ACCEPT
[root@web481 ~]# iptables -t filter -nL INPUT --line-numbers  #列出添加的规则
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
1    ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0 
[root@web481 ~]# iptables -I INPUT -p udp -j ACCEPT           #插入新规则(查在开头)
[root@web481 ~]# iptables -t filter -nL INPUT --line-numbers  #列出添加的规则(所有)
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
1    ACCEPT     udp  --  0.0.0.0/0            0.0.0.0/0           
2    ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0
[root@web481 ~]# iptables -I INPUT 2 -p icmp -j ACCEPT  #在插在第二行前
[root@web481 ~]# iptables -nL INPUT --line-numbers      #列出添加的规则(所有)
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
1    ACCEPT     udp  --  0.0.0.0/0            0.0.0.0/0           
2    ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           
3    ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0 


查看列表规则
-L 查看
[root@web481 ~]# iptables -nL INPUT
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     udp  --  0.0.0.0/0            0.0.0.0/0           
ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0  
[root@web481 ~]# iptables -nL INPUT --line-numbers
Chain INPUT (policy ACCEPT)
num  target     prot opt source              destination         
1    ACCEPT     udp  --  0.0.0.0/0           0.0.0.0/0           
2    ACCEPT     icmp --  0.0.0.0/0           0.0.0.0/0           
3    ACCEPT     tcp  --  0.0.0.0/0           0.0.0.0/0  


步骤三：iptables命令的基本使用方法
1）iptabels语法格式
[root@proxy ~]# iptables  [-t 表名]  选项  [链名]  [条件]  [-j 目标操作]
[root@proxy ~]# iptables  -t  filter  -I  INPUT -p  icmp  -j  REJECT
[root@proxy ~]# iptables -t filter -I  INPUT   -p  icmp  -j  ACCEPT
[root@proxy ~]# iptables  -I  INPUT  -p  icmp  -j  REJECT

[root@proxy ~]# cp -a /etc/sysconfig/iptables /etc/sysconfig/iptables.bak  #如之前已经设置过规则策略的，将原有的 iptables 文件保存一份,，避免之前设置的策略丢失
#注意事项与规律：
#可以不指定表，默认为filter表
#可以不指定链，默认为对应表的所有链
#如果没有找到匹配条件，则执行防火墙默认规则
#选项/链名/目标操作用大写字母，其余都小写

########################################################################
#目标操作：
# ACCEPT：允许通过/放行
# DROP：直接丢弃，不给出任何回应
# REJECT：拒绝通过，必要时会给出提示
# LOG：记录日志，然后传给下一条规则
例:
[root@porxy80 ~]# iptables -t filter -L   #查看iptables所有规则
[root@porxy80 ~]# iptables -t filter -nL  #n表示以数字形式显示地址 端口等信息
[root@porxy80 ~]# iptables -t filter -nL --line-numbers
[root@porxy80 ~]# iptables -t nat -nL --line-numbers
[root@porxy80 ~]# iptables -t raw -nL --line-numbers
[root@porxy80 ~]# iptables -t filter -nL INPUT --line-numbers
[root@porxy80 ~]# iptables -t filter -D INPUT 5                #删除第5条规则
[root@porxy80 ~]# iptables -t filter -nL INPUT --line-numbers  #查看删除后规则
[root@porxy80 ~]# iptables -t filter -F 
[root@porxy80 ~]# iptables -t filter -L
[root@porxy80 ~]# iptables-save
[root@porxy80 ~]# cat /etc/sysconfig/iptables
[root@porxy80 ~]# systemctl restart iptables
[root@porxy80 ~]# iptables -t filter -F
[root@porxy80 ~]# iptables -t nat -F
[root@porxy80 ~]# iptables -t mangle -F
[root@porxy80 ~]# iptables -t raw -F
[root@porxy80 ~]# iptables-save > /etc/sysconfig/iptabes
[root@porxy80 ~]# cat /etc/sysconfig/iptabes
[root@porxy80 ~]# systemctl restart iptables
[root@porxy80 ~]# iptables -t filter -L


2）iptables命令的使用案例
创建规则的案例：
[root@proxy ~]# iptables -t filter -A INPUT -p tcp -j ACCEPT  #追加规则至filter表中的INPUT链的末尾，允许任何人使用TCP协议访问本机
[root@proxy ~]# iptables -I INPUT -p udp -j ACCEPT            #插入规则至filter表中的INPUT链的开头，允许任何人使用UDP协议访问本机
[root@proxy ~]# iptables -I INPUT 2 -p icmp -j ACCEPT         #插入规则至filter表中的INPUT链的第2行，允许任何人使用ICMP协议访问本机
例:
root@porxy480 ~]# iptables -t filter -A INPUT -p tcp -j  ACCEPT  #追加规则至filter表中的INPUT链的末尾，允许任何人使用TCP协议访问本机
[root@client281 ~]# ping 192.168.4.80                            #测试
PING 192.168.4.80 (192.168.4.80) 56(84) bytes of data.
64 bytes from 192.168.4.80: icmp_seq=1 ttl=255 time=0.227 ms
64 bytes from 192.168.4.80: icmp_seq=2 ttl=255 time=0.598 ms
[root@porxy480 ~]# iptables -I INPUT -p udp -j ACCEPT     #插入规则至filter表中的INPUT链的开头，允许任何人使用UDP协议访问本机
[root@porxy480 ~]# iptables -I INPUT 2 -p icmp -j ACCEPT  #插入规则至filter表中的INPUT链的第2行，允许任何人使用ICMP协议访问本机
[root@porxy480 ~]# iptables -t filter -I INPUT -p icmp -s 192.168.2.81 -j DROP  #不允许192.168.2.81ping通
[root@client281 ~]# ping 192.168.4.80  #测试
PING 192.168.4.80 (192.168.4.80) 56(84) bytes of data.
[root@porxy480 ~]# iptables -t filter -nL INPUT  #列出规则
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
DROP       icmp --  192.168.2.81         0.0.0.0/0           
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED
ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            state NEW tcp dpt:22
REJECT     all  --  0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:22
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:22
[root@porxy480 ~]# iptables -t filter -D INPUT 1  #删除第一行规则
[root@porxy480 ~]# iptables -t filter -nL INPUT   #列出规则
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED
ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           
ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            state NEW tcp dpt:22
REJECT     all  --  0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:22
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:22
[root@client281 ~]# iptables-save > /etc/sysconfig/iptables  #保存规则
[root@client281 ~]# systemctl restart iptables               #重启动服务
[root@client281 ~]# ping 192.168.4.80                        #这时可以ping通
PING 192.168.4.80 (192.168.4.80) 56(84) bytes of data.
64 bytes from 192.168.4.80: icmp_seq=1 ttl=255 time=0.194 ms


查看iptables防火墙规则
[root@proxy ~]# iptables  -nL  INPUT  #仅查看INPUT链的规则
target     prot opt source               destination
ACCEPT     udp  --  0.0.0.0/0            0.0.0.0/0
ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0
ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0
[root@proxy ~]# iptables  -L  INPUT  --line-numbers  #查看规则，显示行号
num  target     prot opt source         destination
1    ACCEPT     udp   --  anywhere     anywhere
2    ACCEPT     icmp --   anywhere     anywhere
3    ACCEPT     tcp  --   anywhere     anywhere
例:
[root@porxy480 ~]# iptables -nL INPUT                #仅查看INPUT链的规则
[root@porxy480 ~]# iptables -L INPUT --line-numbers  #查看规则，显示行号

删除规则，清空所有规则
[root@proxy ~]# iptables -D INPUT 3    #删除filter表中INPUT链的第3条规则
[root@proxy ~]# iptables -nL INPUT     #查看规则，确认是否删除
[root@proxy ~]# iptables -F            #清空filter表中所有链的防火墙规则
[root@proxy ~]# iptables -t nat -F     #清空nat表中所有链的防火墙规则
[root@proxy ~]# iptables -t mangle -F  #清空mangle表中所有链的防火墙规则
[root@proxy ~]# iptables -t raw -F     #清空raw表中所有链的防火墙规则
例:
[root@porxy480 ~]# iptables  -nL INPUT --line-numbers  #查看规则
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
1    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED
2    ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           
3    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           
4    ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            state NEW tcp dpt:22
5    REJECT     all  --  0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited
6    ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:22
7    ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:22
[root@porxy480 ~]# iptables -D INPUT 4                 #删除filter表中INPUT链的第4条规则
[root@porxy480 ~]# iptables  -nL INPUT --line-numbers  #查看规则，确认是否删除
Chain INPUT (policy ACCEPT)
num  target     prot opt source               destination         
1    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0            state RELATED,ESTABLISHED
2    ACCEPT     icmp --  0.0.0.0/0            0.0.0.0/0           
3    ACCEPT     all  --  0.0.0.0/0            0.0.0.0/0           
4    REJECT     all  --  0.0.0.0/0            0.0.0.0/0            reject-with icmp-host-prohibited
5    ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:22
6    ACCEPT     tcp  --  0.0.0.0/0            0.0.0.0/0            tcp dpt:22
[root@porxy480 ~]# iptables -F            #清空filter表中所有链的防火墙规则
[root@porxy480 ~]# iptables -t nat -F     #清空nat表中所有链的防火墙规则
[root@porxy480 ~]# iptables -t mangle -F  #清空mangle表中所有链的防火墙规则
[root@porxy480 ~]# iptables -t raw -F     #清空raw表中所有链的防火墙规则


设置防火墙默认规则
[root@proxy ~]# iptables  -t  filter  -P  INPUT  DROP
[root@proxy ~]# iptables  -nL
Chain INPUT (policy DROP)
… …
例:
[root@porxy480 ~]# iptables -t filter -P INPUT DROP
[root@porxy480 ~]# iptables  -nL  #查看所有规则


===========================================================================
filter过滤和转发控制


2.1 问题
本案例要求创建常用主机防火墙规则以及网络防火墙规则：
   1.针对Linux主机进行出站、入站控制
   2.利用ip_forward机制实现Linux路由/网关功能
   3.在Linux网关上实现数据包转发访问控制

2.2 方案
根据防火墙保护的对象不同，防火墙可以分为主机型防火墙与网络型防火墙，如图-1所示。
主机型防火墙，主要保护的是服务器本机（过滤威胁本机的数据包）。
网络防火墙，主要保护的是防火墙后面的其他服务器，如web服务器、FTP服务器等。


2.3 步骤
实现此案例需要按照如下步骤进行。
步骤一：iptables防火墙规则的条件
iptables防火墙可以根据很多很灵活的规则进行过滤行为，具体常用的过滤条件

基本的配置条件
  通用匹配
     可直接使用,不依赖于1其他条件或扩展
     包括网络协议 IP地址 网络接口等条件
  隐含匹配
     要求以特定的协议匹配作为前提
     包括端口 TCP标记 ICMP类型等条件
               

封禁IP地址/网段
  主机防护,针对入站访问的原地址
  网络防护,针对转发访问的原地址


类型         选项             用法
通用匹配   协议匹配         -p 协议名
            地址匹配         -s 原地址        -d 目标地址
            接口匹配         -i 收数据的网卡  -o 发数据的网卡
            端口匹配         --sport 源端口   --dport 目标端口
隐含匹配   ICMP类型匹配    --icmp-type     ICMP类型
附加: 需要取反条件是,用叹号!  


1）主机型防火墙案例
[root@proxy ~]# iptables -I INPUT -p tcp --dport 80 -j REJECT
[root@proxy ~]# iptables -I INPUT -s 192.168.2.100 -j REJECT
[root@proxy ~]# iptables -I INPUT -d 192.168.2.5 -p tcp --dport 80 -j REJECT
[root@proxy ~]# iptables -I INPUT -i eth0 -p tcp --dport 80 -j REJECT
[root@proxy ~]# iptables  -A  INPUT  -s 192.168.4.100  -j  DROP                               #丢弃192.168.4.100发给本机的所有数据包
[root@proxy ~]# iptables  -A  INPUT -s  192.168.2.0/24  -j  DROP                             #丢弃192.168.2.0/24网络中所有主机发送给本机的所有数据包
[root@proxy ~]# iptables -A  INPUT -s  114.212.33.12  -p tcp --dport 22 -j  REJECT  #拒绝114.212.33.12使用tcp协议远程连接本机ssh（22端口）
例:
[root@nfs430 ~]# iptables -I INPUT -p tcp --dport 80 -j REJECT   #拒绝其它主机访问本机80端口的服务(包括本机),本机可以访问其它主机80端口的服务,
[root@nfs430 ~]# iptables -I INPUT -p tcp --sport 80 -j REJECT   #本主机不能访问80端口的服务
[root@nfs430 ~]# iptables -I INPUT -s 192.168.4.11 -j REJECT      #拒绝192.168.4.11主机访问本机所有服务
[root@nfs430 ~]# iptables -I INPUT -d 192.168.4.77 -p tcp --dport 80 -j REJECT
[root@nfs430 ~]# iptables -A INPUT -i eth0 -p tcp --dport 80 -j REJECT               #拒绝其它主机访问eth0网卡的80端口服务
[root@nfs430 ~]# iptables -A INPUT -s 192.168.4.11 -j DROP                               #丢弃192.168.4.11主机发给本机的所有数据包(包括本机)
[root@nfs430 ~]# iptables -I INPUT -s 192.168.4.0/24 -j DROP                             #丢弃192.168.4.0/24网络中所有主机发送给本机的所有数据包(包括本机)
[root@nfs430 ~]# iptables -A INPUT -s 192.168.4.11 -p tcp --dport 22 -j REJECT  #拒绝192.168.4.11使用tcp协议远程连接本机ssh（22端口）


步骤二：开启Linux的路由转发功能
1）Linux内核默认支持软路由功能，通过修改内核参数即可开启或关闭路由转发功能。
[root@proxy ~]# echo 0 > /proc/sys/net/ipv4/ip_forward  #关闭路由转发
[root@proxy ~]# echo 1 > /proc/sys/net/ipv4/ip_forward  #开启路由转发
#注意: 以上操作仅当前有效，计算机重启后无效
[root@proxy ~]# echo 'net.ipv4.ip_forward=1' >> /etc/sysctl.conf  #修改/etc/sysctl.conf配置文件，可以实现永久有效规则
例:
[root@nfs430 ~]# echo 0 > /proc/sys/net/ipv4/ip_forward  #关闭路由转发
[root@nfs430 ~]# echo 1 > /proc/sys/net/ipv4/ip_forward  #开启路由转发
#注意以上操作仅当前有效，计算机重启后无效(当前有效)
[root@nfs430 ~]# echo "net.ipv4.ip_forward=1" >> /etc/sysctl.conf  #修改/etc/sysctl.conf配置文件，可以实现永久有效规则


步骤四：网络型防火墙案例
1）网络型防火墙案例
部署如表-3所示的网络拓扑，一定要把proxy主机的路由转发功能打开。

主机要求     网卡 IP地址以及网关设置要求
client    ech0:192.168.4.100
             网关: 192.168.4.5
proxy     ech0:192.168.4.5
             网关: 192.168.2.5
web1      eth1: 192.168.2.100
             网关: 192.168.2.5

添加网关的命令
[root@client ~]# nmcli connection modify eth0 ipv4.gateway 192.168.4.5
[root@client ~]# nmcli connection up eth0
[root@web1 ~]# nmcli connection modify eth1 ipv4.gateway 192.168.2.5
[root@web1 ~]# nmcli connection up eth1

确认不同网络的联通性
[root@client ~]# ping 192.168.2.100
[root@web1 ~]# ping 192.168.4.100

在web1主机上启动http服务
[root@web1 ~]# yum -y install httpd
[root@web1 ~]# echo "test page" > /var/www/html/index.html
[root@web1 ~]# systemctl restart httpd

没有防火墙的情况下client访问web服务
[root@client ~]# curl http://192.168.2.100  #成功

设置proxy主机的防火墙规则，保护防火墙后面的Web服务器
[root@proxy ~]# iptables -I FORWARD -s 192.168.4.100 -p tcp --dport 80 -j DROP

设置完防火墙规则后，再次使用client客户端访问测试效果
[root@client ~]# curl http://192.168.2.100  #失败

步骤三：禁ping的相关策略
1）默认直接禁ping的问题？
[root@proxy ~]# iptables -I INPUT -p icmp -j DROP
#设置完上面的规则后，其他主机确实无法ping本机，但本机也无法ping其他主机
#当本机ping其他主机，其他主机回应也是使用icmp，对方的回应被丢弃

2）禁止其他主机ping本机，允许本机ping其他主机
[root@proxy ~]# iptables  -A  INPUT  -p icmp  \
> --icmp-type echo-request  -j  DROP
#仅禁止入站的ping请求，不拒绝入站的ping回应包

注意：关于ICMP的类型，可以参考help帮助，参考命令如下：
[root@proxy ~]# iptables -p icmp --help


==============================================================================
防火墙扩展规则

本案例要求熟悉使用iptables的扩展规则，实现更丰富的过滤功能，完成以下任务：
   1.根据MAC地址封锁主机
   2.在一条规则中开放多个TCP服务
   3.根据IP范围设置封锁规则

3.2 方案
  iptables在基本过滤条件的基础上还扩展了很多其他条件，在使用时需要使用-m参数来启动这些扩展功能，语法如下：
  iptables 选项 链名称 -m 扩展模块 --具体扩展条件 -j 动作


3.3 步骤
实现此案例需要按照如下步骤进行。
步骤一：根据MAC地址过滤
1）根据IP过滤的规则，当对方修改IP后，防火墙会失效
[root@proxy ~]# iptables -F
[root@proxy ~]# iptables -I INPUT -s 192.168.4.100 -p tcp --dport 22 -j DROP  #设置规则禁止192.168.4.100使用ssh远程本机
例:
[root@nfs430 ~]# iptables -I INPUT -s 192.168.4.12 -p tcp --dport 22 -j DROP  #设置规则禁止192.168.4.12使用ssh远程本机
或
[root@nfs430 ~]# iptables -I INPUT -s 192.168.4.12 -p tcp  -j DROP            #设置规则禁止192.168.4.12使用ssh远程本机
[root@nfs430 ~]# iptables -I INPUT -s 192.168.4.0/24 -p tcp  -j DROP          #设置规则禁止192.168.4.0/24网段内的使用ssh远程本机
[root@nfs430 ~]# iptables -nL         #查看所有规则
[root@nfs430 ~]# iptables -D INPUT 1  #删除INPUT的第一条规则
[root@nfs430 ~]# iptables -F          #清空所有规则

但是，当client主机修改IP地址后，该规则就会失效，注意因为修改了IP，对client主机的远程连接会断开，需要使用virt-manager开启虚拟机操作：
[root@client ~]# ifconfig eth0  192.168.4.101
[root@client ~]# ssh 192.168.4.5  #依然成功
例;
[root@nfs430 ~]# iptables -I INPUT -s 192.168.4.12 -p tcp -j REJECT  #设置规则禁止192.168.4.12使用ssh远程本机
[root@mysql412 ~]# ssh -X root@192.168.4.30
ssh: connect to host 192.168.4.30 port 22: Connection refused
[root@mysql412 ~]# nmcli connection modify $name ipv4.method manual ipv4.addresses "192.168.4.10/24" ipv4.gateway $gw connection.autoconnect yes  #修改IP
[root@mysql412 ~]# nmcli connection up eth0
[root@mysql412 ~]# ssh -X root@192.168.4.30
root@192.168.4.30's password: 

根据MAC地址过滤，可以防止这种情况的发生
[root@client ~]# ip link show eth0   #查看client的MAC地址
eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT qlen 1000
link/ether 52:54:00:00:00:0b brd ff:ff:ff:ff:ff:ff
[root@proxy ~]# iptables -A INPUT -p tcp --dport 22 -m mac --mac-source 52:54:00:00:00:0b -j DROP  #拒绝52:54:00:00:00:0b这台主机远程本机
例:
[root@mysql412 ~]# ip link show eth0  #查看msyql412网卡eth0的MAC地址
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP mode DEFAULT group default qlen 1000
    link/ether 52:54:00:3d:ff:76 brd ff:ff:ff:ff:ff:ff
[root@nfs430 ~]# iptables -A INPUT -p tcp --dport 22 -m mac --mac-source 52:54:00:3d:ff:76 -j DROP  #52:54:00:3d:ff:76这台主机远程本机
或
[root@nfs430 ~]# iptables -A INPUT -p tcp -m mac --mac-source 52:54:00:3d:ff:76 -j DROP  #52:54:00:3d:ff:76这台主机远程本机
[root@mysql412 ~]# ssh -X root@192.168.4.30  #测试
ssh: connect to host 192.168.4.30 port 22: Connection refused


步骤二：基于多端口设置过滤规则
1）一次需要过滤或放行很多端口时会比较方便
[root@proxy ~]# iptables  -A  INPUT  -p tcp   \
> -m  multiport --dports 20:22,25,80,110,143,16501:16800 -j  ACCEPT  #一次性开启20,21,22,25,80,110,143,16501到16800所有的端口

步骤三：根据IP地址范围设置规则

1）允许从 192.168.4.10-192.168.4.20 登录
[root@proxy ~]# iptables  -A  INPUT  -p tcp  --dport  22  -m  iprange  --src-range  192.168.4.10-192.168.4.20 -j ACCEPT

注意，这里也可以限制多个目标IP的范围，参数是--dst-range,用法与--src-range一致。
2）禁止从 192.168.4.0/24 网段其它的主机登录
[root@proxy ~]# iptables -A INPUT -p tcp --dport 22 -s 192.168.4.0/24  -j  DROP

==============================================================================
配置SNAT实现共享上网


4.1 问题
本案例要求设置防火墙规则，允许位于局域网中的主机可以访问外网，主要包括下列服务：
   1.搭建内外网案例环境
   2.配置SNAT策略实现共享上网访问

4.2 步骤
   实现此案例需要按照如下步骤进行。
   步骤一：搭建内外网案例环境

主机名要求    网卡 IP地址以及网关设置要求
client      ech0: 192.168.4.4.100 
               网关: 192.168.4.5
proxy       eth0: 192.168.4.5
            eth1: 192.168.4.2.5
web1        eth1: 192.168.2.100
               网关: 192.168.2.5

这里，我们设定192.168.2.0/24网络为外部网络，192.168.4.0/24为内部网络。
现在，在外部网络中有一台web服务器192.168.2.100，因为设置了网关，client已经可以访问此web服务器了。但，如果查看web1的日志就会发现，日志里记录的是192.168.4.100在访问网页。
我们需要实现的效果是，client可以访问web服务器，但要伪装为192.168.2.5后再访问web服务器(模拟所有位于公司内部的电脑都使用的是私有IP，希望访问外网，就需要伪装为公司的外网IP后才可以)。

步骤二：设置防火墙规则，实现IP地址的伪装（SNAT源地址转换）
1）确保proxy主机开启了路由转发功能
[root@proxy ~]# echo 1 > /proc/sys/net/ipv4/ip_forward  #开启路由转发

2）设置防火墙规则，实现SNAT地址转换
[root@proxy ~]# iptables -t nat -A POSTROUTING -s 192.168.4.0/24 -p tcp --dport 80 -j SNAT --to-source 192.168.2.5

3）登陆web主机查看日志
[root@proxy ~]# tail  /var/log/httpd/access_log
.. ..
192.168.2.5 - - [12/Aug/2018:17:57:10 +0800] "GET / HTTP/1.1" 200 27 "-" "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
通过日志会发现，客户端是先伪装为了192.168.2.5之后再访问的web服务器！

4）扩展知识，对于proxy外网IP不固定的情况可以执行下面的地址伪装，动态伪装IP。
[root@proxy ~]# iptables  -t  nat  -A POSTROUTING -s  192.168.4.0/24 -p tcp --dport 80 -j MASQUERADE

最后，所有iptables规则都是临时规则，如果需要永久保留规则需要执行如下命令:
[root@proxy ~]# service iptables save


13.cloud========================================================================================================================

cloud_day01=====================================================================================================================

环境介绍

第四阶段专用虚拟机模板
·修改文件/ect/clone.conf
[student @room9pc01 - ]$ vim /etc/clone.conf
name=pase
[studente@room9pc01~]$ clone-vm7  #行脚本克隆虚拟机
例:
[root@room9pc01 ~]# vim /etc/clone.conf
name=base


虚拟化概念
virtualization 资源管理
x个物理资源-->y个逻辑资源
实现程度：完全、部分、硬件辅助(CPU)

虚拟化概念
虚拟化主要厂商及产品
系列            PC/服务器版代表
VMware       VMware Workstation、VSphere
Microsoft    VirtualPC、Hyper-V
RedHat       KVM、RHE
Citrix        Xen
Oracle       Oracle Vm virtualBox


安装虚拟化服务器平台
KVM/QEMU/LIBVIRTD
  KⅥM是linuⅨ内核的模块，它需要CPU的支持，采用
  硬件辅助虚拟化技术 Intel-VT，AMD-V，内存的相关
  如Inte的EPT和AMD的RⅥ技术
  QEMU是一个虚拟化的仿真工具，通过ioct与内核
  kwm交互完成对硬件的虚拟化支持
  Libvirt是—个对虚拟化管理的接口和工具，提供用户
  端程序ⅵirsh，virt-install，virt-manager，virt-view与用户交互


安装虚拟化服务器平台
必备软件
gemu-kvm
  为kwm提供底层仿真支持
libvirt-daemon
  libvirtd守护进程，管理虚拟机
bvirt-client
  用户端软件，提供客户端管理命令
libvirt-daemon-driver-gemu
  libvirtd连接qemu的驱动


安装虚拟化服务器平台
可选功能
virt-install  #系统安装工具
vit-manager   #图形管理工具
virt-V2v      #虚拟机迁移工具
virt-p2V      #物理机迁移工具
虚拟化平台的安装
 yum install -y qemu-kvm libvirt-daemon libvirt-client libvirt-daemon-driver-qemu
 systemctl start libvirtd
例:
[root@room9pc01 ~]# yum -y install  qemu-kvm libvirt-daemon libvirt-client libvirt-daemon-driver-qemu
[root@room9pc01 ~]# systemctl start libvirtd

KVM虚拟机的组成
虚拟机的组成
  内核虚拟化模块(KVM)
  系统设备仿真(QEMU)
  虚拟机管理程序( LIBVIRT)
  一个XML文件(虚拟机配置声明文件)
  位置/etc/libvirt/qemu/
  个磁盘镜像文件(虚拟机的硬盘)
  位置/var/lib/libvirt/images/


==============================================================
管理KvM平台


vish命令工具介绍
提供管理各虚拟机的命令接口
  支持交互模式，查看/创建/停止/关闭
  格式： hirsh控制指令[虛拟机名称][参数]
[root@nova01-# virsh
Welcome to virsh, the virtualization interactive terminal
Type: help' for help with commands
quit to quit
virsh #
例:
[root@room9pc01 ~]# virsh
欢迎使用 virsh，虚拟化的交互式终端。

输入：'help' 来获得命令的帮助信息
       'quit' 退出
virsh # 
virsh # list  #列出正在运行的虚拟机
 Id    名称                         状态
----------------------------------------------------
 1     openstack02                    running
 2     node01                         running
 3     node02                         running
 4     docker31                       running
 7     tedu_node55                    running
 9     centos7.0                      running


virsh命令工具介绍
virsh虚拟机管理
  list[--all] 列出虚拟机
  start|shutdown|reboot 虚拟机启动，停止，重启
  destroy 强制停止虚拟机
  define undefine 根据xml文件 创建/删除 虚拟机
  console 连接虚拟机的 console
例:
[root@room9pc01 ~]# virsh list        #列出正在运行的虚拟机
[root@room9pc01 ~]# virsh list --all  #列出所有虚拟机
[root@room9pc01 ~]# virsh destroy node01  #强制停止虚拟机\
[root@room9pc01 ~]# virsh start node01 #虚拟机启动
[root@room9pc01 ~]# virsh shutdown node01 #停止
[root@room9pc01 ~]# virsh reboot node02  #重启
[root@room9pc01 ~]# virsh domblklist node01


virsh命令工具介绍
virsh虚拟机管理
edit        修改虚拟机的配置
autostart   设置虚拟机自启动
domiflist   查看虚拟机网卡信息
domblklist  查看虚拟机硬盘信息

virsh 虚拟网络管理
net-ist [--all]  列出虚拟网络
net-start        启动虚拟交换机
net-destroy      强制停止虚拟交换机
net-define       根据xm文件创建虚拟网络
net-undefine     删除一个虚拟网络设备
net-edit         修改虚拟交换机的配置
net- autostart   设置虚拟交换机机自启动


案例1：virsh基本管理操作
1.列出当前正在运行的虚拟机
2.查看虚拟机的信息
3.管理虚拟机

=================================================================
virsh基本管理操作


git 软件安装
[root@room9pc01 ~]# yum -y install git
[root@room9pc01 ~]# git clone git://43.254.90.134/nsd1903.git  #外地校区

1.1 问题
本案例要求熟悉virsh的基本操作，可以熟练运用：
   1.列出当前正在运行的虚拟机
   2.查看虚拟机的信息
   3.管理虚拟机
   4.设置虚拟机开机自动运行

1.2 步骤
实现此案例需要按照如下步骤进行。
步骤一：virsh基本操作

1）列出当前正在运行的虚拟机
   [root@room9pc01 ~]# virsh list 
   Id    Name                           State
    ----------------------------------------------------
   1     node1                          running
例:
[root@room9pc01 ~]# virsh list  #列出当前正在运行的虚拟机
 Id    名称                         状态
----------------------------------------------------
 2     centos7.0                      running
 4     redis58                        running
 6     tedu_node26                    running
 8     node1                          running


步骤二：查看虚拟机的信息
[root@room9pc01 ~]# virsh dominfo nova
例;
[root@room9pc01 ~]# virsh dominfo node1  #查看虚拟机的信息
Id:             15
名称：       node1
UUID:           742754b7-177c-474d-b8ce-46b2b181358a
OS 类型：    hvm
状态：       running
CPU：          2
CPU 时间：   17.6s
最大内存： 1488896 KiB
使用的内存： 1488284 KiB
持久：       是
自动启动： 禁用
管理的保存： 否
安全性模式： none
安全性 DOI： 0


步骤三：管理虚拟机
1）启动虚拟机
[root@room9pc01 ~]# virsh start node1

2）重启虚拟机virsh domiflist zyq
[root@room9pc01 ~]# virsh reboot node1

3）强制关闭虚拟机
[root@room9pc01 ~]# virsh destroy node1

4）设置虚拟机开机自动运行
[root@room9pc01 ~]# virsh autostart node1

5）查看虚拟机网卡信息
[root@room9pc01 ~]# virsh domiflist  node1
接口     类型     源        型号      MAC
-------------------------------------------------------
vnet0      bridge     vbr        virtio      52:54:00:5f:8b:11
vnet1      bridge     private1   virtio      52:54:00:19:a4:f3

6）查看虚拟机硬盘信息
[root@room9pc01 ~]# virsh domblklist  node1
目标     源
------------------------------------------------
vda        /var/lib/libvirt/images/node1.img
vdb        /var/lib/libvirt/images/disk.img


==================================================================
2.1 问题

本案例要求：
   1.创建一个新的镜像盘文件
   2.使用后端模板文件创建一个新的镜像盘文件
   3.查看镜像盘文件的信息


2.2 步骤
实现此案例需要按照如下步骤进行。
步骤一：创建一个新的镜像盘文件
qemu-img命令格式：qemu-img 命令 参数 块文件名称 大小
[root@room9pc01 ~]# qemu-img create -f qcow2 disk.img 50G  #qcow2为创建的格式
Formatting 'disk.img', fmt=qcow2 size=53687091200 encryption=off cluster_size=65536 lazy_refcounts=off
例:

====================================================================================
Virsh管理(创建虚拟机)

xml管理

克隆脚步命令
命令参数
1.创建虚拟机
  cd /var/lib/libvirt/images/
  qemu-img create -f qcow2 -b .node_tedu.qcow2 nsd1903.img 50G
例:
[root@room9pc01 ~]# cd /var/lib/libvirt/images/
[root@room9pc01 images]# ls -a
.node_tedu.qcow2
[root@room9pc01 images]# qemu-img create -f qcow2 -b .node_tedu.qcow2 nsd1903.img 50G  #.node_tedu.qcow2是后端盘, nsd1903.img是自定义

2. 修改xml文件
sed 's.node,node1,' node.xml > /etc/libvirt/qemu/node1.xml
例:
[root@room9pc01 ~]# cd /var/lib/libvirt/images/
[root@room9pc01 images]# cp .node_tedu.xml /etc/libvirt/qemu/nsd1903.xml
[root@room9pc01 ~]# vim /etc/libvirt/qemu/nsd1903.xml
2   <name>nsd1903</name>
26       <source file='/var/lib/libvirt/images/nsd1903.img'/>

3.定义xml文件
virsh define /etc/libvirt/qemu/node1.xml
例:
[root@room9pc01 ~]# virsh define /etc/libvirt/qemu/nsd1903.xml  #创建虚拟机

4.开启虚拟机
virsh start node1
例:
[root@room9pc01 ~]# virsh start nsd1903

=======================================================================
virsh扩容磁盘

1. virsh虚拟机管理
domblklist   #查看虚拟机硬盘信息
blockresize --path [绝对路径] --size 50G openstack
例:
[root@room9pc01 ~]# virsh domblklist nsd1903  #查看虚拟机硬盘信息(在真机操作)
目标     源
------------------------------------------------
vda        /var/lib/libvirt/images/nsd1903.img
[root@room9pc01 ~]# virsh blockresize --path /var/lib/libvirt/images/nsd1903.img --size 80G nsd1903  #nsd1903是虚拟机名称,扩容虚拟机磁盘
                                                               是虚拟机磁盘路径                               扩容到80G
扩容思路:
  首先是硬盘
  其次是分区
  再次是文件系统


2. 根分区扩容
1).语音必须设置为英文
  LANG=C
例:
[root@localhost ~]# LANG=C  #在虚拟机操作

2).插卡硬盘设是否有多余空间
lsblk
例:
[root@localhost ~]# lsblk  #在虚拟机查看磁盘大小信息(扩容前)(在虚拟机操作)
NAME   MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
vda    253:0    0  50G  0 disk 
└─vda1 253:1    0  50G  0 part /

3).扩容文件系统
/usr/sbin/xfs_growfs /
例:
[root@localhost ~]# xfs_growfs /dev/vda1  #在虚拟机扩容文件系统

4).检查扩容结果
df -h
例:
[root@localhost ~]# df -h
[root@localhost ~]# lsblk
NAME   MAJ:MIN RM SIZE RO TYPE MOUNTPOINT  #在虚拟机查看磁盘大小信息(扩容后)
vda    253:0    0  80G  0 disk 
└─vda1 253:1    0  50G  0 part /


=======================================================================
常用镜像盘类型


虚拟机的磁盘镜像文件格式
特点类型     RAW        QCOW2
KVM默认      否             是
I/O效率      高             较高
占月空间      大            小
压缩          不支持        支持
后端盘复用    不支持        支持
快照          不支持        支持

qemu-img命令
   qemu-img是虚拟机的磁盘管理命令，支持非常多的磁盘格式，例如raw、qcow2、vdi、wmdk等等
qemu-img 命令格式
   qemu-img 命令 参数 块文件名称 大小
常用的命令有
  create   创建一个磁盘
  convert  转换磁盘格式
  info     查看磁盘信息
  resize   扩容磁盘空间

qemu-img命令
创建新的镜像盘文件
  qemu-img create -f 格式磁盘路径 
大小
  qemu-img create -f qcow2 disk.img 50G
査询镜像盘文件的信息
  qemu-img info磁盘路径
  qemu-img info disk.img
-b使用后端模板文件
  qemu-img create -b disk.img -f qcow2 disk1.img


coW技术原理
Copy On Write，写时复制
   直接映射原始盘的数据内容
   当数据有修改要求时，在修改之前自动将I旧数据拷贝存入前端盘后，对前端盘进行修改


案例2：qemu-img基本操作管理
1.创建一个新的镜像盘文件
2.使用后端模板文件创建一个新的镜像盘文件
3.查看镜像盘文件的信息


=================================================================
xml管理


创建xml文件
对虚拟机的配置迸行调整
  编辑： virsh edit 虛拟机名
  若修改cpu、memory
root@kvmsvr-]# virsh edit node0
 <domain type='kvm'>
  <name >node0</name>
   <uuid>7ecOlab09-d9cb-4b19-ad26-813381420260</uuid>
  <memory unit=KiB>1488282</memory>
  <currentMemory unit=KiB>1488282</currentMemory>
  <vcpu placement='static>2</vcpu>
......
例：
[root@zyq ~]# virsh edit es01
<domain type='kvm'>
  <name>es01</name>
  <uuid>92754ab9-2bfb-4f5e-831c-8f9b478632ad</uuid>
  <memory unit='KiB'>2097152</memory>
  <currentMemory unit='KiB'>2097152</currentMemory>
  <vcpu placement='static'>1</vcpu>
......

创建xml文件
对虚拟机的配置进行调整
  编辑：virsh edit 虚拟机名
  若修改磁盘
[root@kvmsvr ~]# virsh edit node0
  ....
   <disk type= file device='disk>
     <driver name='qemu' type='qcow2/>
       <source file=/var/lib/libvirt/images/node0.img>
       <target dev='vda' bus='virtio/>
   </disk>
  .....
例：
[root@zyq images]# virsh edit es01  #es01是虚拟机名称
......
32     <disk type='file' device='disk'>
33       <driver name='qemu' type='qcow2'/>
34       <source file='/var/lib/libvirt/images/centos7.0-clone.qcow2'/>
35       <target dev='vda' bus='virtio'/>
36       <address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x0'/>
37     </disk>
......


创建xml文件
对虚拟机的配置进行调整
  编辑： virsh edit 虚拟机名
  若修改 网络
[root@kvmsvr ] virsh edit node0
  <interface type=bridge>
   <source bridge='vbr/'>
     <model type='virtio'/>
  </interface>
例：
[root@zyq ~]# virsh edit es01



===============================================================
批量创建虚拟机


克隆脚本命令
命令参数
  创建虚拟机
    cd /var/lib/libvirt/images/
    qemu-img create -f qcow2 -b node qcow2 node1.img 20G
  修改xml文件
    sed 's,node,node1,' node.xml > /etc/libvirt/qemu/node1.xml
  定义xm文件
    virsh define /etc/libvirt/qemu/node1.xml
  开启虚拟
    virsh start node1
例：


网卡及配置文件

网络配置文件说明
  /etc/sysconfig/network-scripts/ifcfg-eth0
     #Generated by dracut initrd 注释
     DEVICE="eth0"            #驱动名称，与ifconfig看到的名称一致
     ONBOOT="yes"             #开机启动
     NM_CONTROLLED="no"       #不接受NetworkManager控制
     TYPE="Ethernet"          #类型
     BOOTPROTO= "static"      #协议( dhcplstaticnone
     IPADDR="192.168.1.10     #IP地址
     NETMASK="255.255.255.0″  #子网掩码
     GATEWAY=192168.1.254     #默认网关

virsh扩容磁盘
virsh虚拟机管理
  domblklist查看虚拟机硬盘信息
  blocksize-path [绝对路径] --size 50G openstack

扩容思路
  首先是硬盘
  其次是分区
  再次是文件系统


根分区扩容
  语言必须设置为英文
    LANG=C
  查看硬盘设备是否有多余空间
    lsblk
  扩容第一个分区
    /usr/bin/growpart /dev/vda 1
  扩容文件系统
    /usr/sbin/xfs_ grows  /
  检查扩容结果
    df -h

==============================================================
云平台

云计算基础

什么是云计算
基于互联网的相关服


cloud_day02====================================================================================================================

云计算简介

什么是云计算
   基于互联网的相关服务的增加、使用和交付模式
   这种模式提供可用的、便捷的、按需的网络访问,进入可配置的计算资源共享池
   这些资源能够被快速提供，只需投入很少的管理工作或与服务供应商进行很少的交互
   通常涉及通过互联网来提供动态易扩展且经常是虚拟化的资源

IaaS( Infrastructure as a service)，即基础设施即服务
  提供给消费者的服务是对所有计算基础设施的利用
  包括处理CPU、内存、存储、网络和其它基本的计算
  资源，用户能够部署和运行任意软件，包括操作系统和应用程序
  IaaS通常分为三种用法：公有云、私有云和混合云

PaaS
  PaaS( Platform-as-a- Service)，意思是平台即服务
  以服务器平台或者开发环境作为服务进行提供就成为了PaS
  PaaS运营商所需提供的服务，不仅仅是单纯的基础平台，还针对该平台的技术支持服务，甚至针对该平
   台而进行的应用系统开发、优化等服务
   简单地说，PaS平台是指云环境中的应用基础设施服务，也可以说是中间件即服务

SaaS
  SaaS( Software-as-a- Service)软件即服务，是种通过 Internet提供软件的模式，厂商将应用软件统-部
  署在自己的服务器上，客户可以根据自己实际需求，通过互联网向厂商定购所需的应用软件服务
  用户不用再购买软件，而是向提供商租用基于Web的软件，来管理企业经营活动，不用对软件进行维护，提供
  商会全权管理和维护软件，同时也提供软件的离线操作和本地数据存储

Openstack简介
什么是 Openstack
  OpenStack是一个由NASA(美国国家航空航天局)和Rackspace合作研发并发起的项目
  OpenStack是一套laS解决方案
  Open Stack是一个开源的云计算管理平台
  以 Apache许可证为授权


Openstack主要组件

Horizon
   用于管理 Openstack各种服务的、基于web的管理接口
   通过图形界面实现创建用户、管理网络、启动实例等操作

Openstack主要组件
Keystone
   为其他服务提供认证和授权的集中身份管理服务
  也提供了集中的目录服务
  支持多种身份认证模式，如密码认证、令牌认证及AWS(亚马逊Web服务)登陆
  为用户和其他服务提供了SSO认证服务

Openstack主要组件
Neutron
  一种软件定义网络服务
  用于创建网络、子网、路由器、管理浮动IP地址
  可以实现虚拟交换机、虚拟路由器
  可用于在项目中创建VPN

openstack主要组件
Cinder
  为虚拟机管理存储卷的服务
  为运行在Nova中的实例提供永久的块存储
  可以通过快照进行数据备份
  经常应用在实例存储环境中，如数据库文件

penstock主要组件
达内教育
Glance
  扮演虚拟机镜像注册的角色
  允许用户为直接存储拷贝服务器镜像
  这些镜像可以用于新建虚拟机的模板

Openstack主要组件
Nova
  在节点上用于管理虚拟机的服务
  Noa是一个分布式的服务，能够与 Keystone交互实现认证，与 Glance交互实现镜像管理
  Nova被设计成在标准硬件上能够进行水平扩展
  启动实例时，如果有则需要下载镱像

===============================================================================
部署安装环境


案例1：配置虚拟机

1.配置三台虚拟析
  2CPU,6G内存,50G硬盘
  2CPU,4.5G内存,100G硬盘
2.配置静态 IP iffy-eth0
  openstack: 192.168.1.10
  nova:192.168.1.11,192.168.1.12
3.配置主机名 /etc/hosts
4.能够相互ping通
5.配置dns服务器/etc/ resolv。 conf


虚拟机准备

虚拟机配置
准备虚拟机3台
云数据中心
openstack管理 : nova01 nova02
nova计算节点集群


虚拟机配置

准备虚拟机3台，配置入下
openstack 管理主机
  2CPU,6G内存,50G硬盘
  配置静态IP:192.168.1.10
nova01，nova02计算节点*2
  2CPU,4.5G内存,100G硬盘
  配置静态IP:192.168.1.11(12)


配置DNS
 系统环境准备
   openstack安装时候需要使用外部dns来解析域名
   vim /etc/resolv.conf
   # Generated by NetworkManager
   nameserver 114.114.114.114 设置真机DNS地址
   注：去掉 search开头的所有行
将 openstack.tedu.cn域名对应的IP解析到我们安装的
  openstack服务器
   vim /etc/hosts
   192.168.1.10 openstack
   192.168.1.11 nova01
   192.168.1.12 nova02
注：DNS服务器不能与 openstack安装在同一台主机上


=======================================================================
NTP服务


案例2：测试NTP服务器
1.修改 openstack，nova01，nova02的时间服务器
2.重启服务后验证配置


时间服务
 nova服务器之间的时间必须保持致
 编辑配置文件/etc/ chrony.conf
 server 192.168.1.254 iburst
 重启服务
 systemctl restart chronyd
测试服务
[student@ openstack]# chronic sources -V  #出现*号代表NTP时间可用
61762-753us[-7003u]+/-24ms
例:
[root@openstack ~]# vim /etc/chrony.conf  #在3台主机都操作
server 192.168.2.254 iburst


案例3：配置yum仓库
达内教育
1.配置yum源，软件仓库一共4个
 Croot@openstack yum repol ist
  repo ist: 10, 670
  软件包共有
  repolist: 10,670


配置yum仓库

Centos7-1804.iso 系统软件
RHEL7-extras.iso 提供Python依赖软件包
RHEL7OSP-10.iso 光盘拥有众多目录，每个目录都
是一个软件仓库，我们配置其中2个软件仓库
  openstack主要软件仓库
    hel-7-server-openstack-10-rpms
  packsack软件仓库
    rhel-7-server-openstack-10-devtools-rpms

在真机操作
[root@room9pc01 ~]# cd /root/桌面/linux-soft/04/openstack/
[root@room9pc01 ~]# mkdir -p /var/ftp/{openstack,openstack2}  
[root@room9pc01 ~]# cp /root/桌面/linux-soft/04/openstack/RHEL7-extras.iso /var/lib/libvirt/images/openstack/
[root@room9pc01 ~]# cp /root/桌面/linux-soft/04/openstack/RHEL7OSP-10.iso /var/lib/libvirt/images/openstack2/
[root@room9pc01 ~]# vim /etc/fstab
/var/lib/libvirt/images/iso/CentOS7-1804.iso  /var/ftp/centos-1804 iso9660 defaults 0 0
/var/lib/libvirt/images/openstack/RHEL7-extras.iso /var/ftp/RHEL7-extras iso9660 defaults 0 0
/var/lib/libvirt/images/openstack2/RHEL7OSP-10.iso /var/ftp/RHEL7OSP-10 iso9660 defaults 0 0
在虚拟机操作(此步3台虚拟机相同操作)
[root@node01 ~]# vim /etc/yum.repos.d/local.repo 
[local_repo]
name=CentOS-$releasever - Base
baseurl="ftp://192.168.1.254/centos-1804"
enabled=1
gpgcheck=0

[RHEL7-extras]
name=RHEL7-extras
baseurl="ftp://192.168.1.254/RHEL7-extras"
enabled=1
gpgcheck=0

[RHEL7OSP-package]
name=RHEL7OSP-package
baseurl="ftp://192.168.1.254/RHEL7OSP-10/rhel-7-server-openstack-10-rpms"
enabled=1
gpgcheck=0

[RHEL7OSP-devtools]
name=RHEL7OSP-devtools
baseurl="ftp://192.168.1.254/RHEL7OSP-10/rhel-7-server-openstack-10-devtools-rpms"
enabled=1
gpgcheck=0
[root@node01 ~]# yum clean all
[root@node01 ~]# yum repolist


=====================================================================
部署Openstock

基础环境准备


安装 openstack期间，有些软件包所依赖的软件包，
并没有在安装过程中安装，这些软件包需提前安装
  gemu-kvm
  libvirt-daemon
  libvirt-daemon-driver-gemu
  libvirt-client
  python-setuptools
软件包安装

1)安装额外软件包（三台机器操作，这里以一台为例）
[root @room9pc01"]# yum install -y gemu-kvm libvirt-client libvirt-daemon libvirt-daemon-driver-qemu python-setuptools
例:
[root@openstack ~]# yum install -y qemu-kvm libvirt-client libvirt-daemon libvirt-daemon-driver-qemu python-setuptools

2）是否卸载firewalld 和 NetworkManager （三台机器操作，这里以一台为例）
[root@openstack ~]# rpm -qa  | grep NetworkManager*
[root@openstack ~]# rpm -qa  | grep firewalld*   
例:
[root@openstack ~]# rpm -e --nodeps NetworkManager-libnm-1.10.2-13.el7.x86_64
[root@openstack ~]# rpm -e --nodeps NetworkManager-libnm-1.10.2-13.el7.x86_64
[root@openstack ~]# rpm -e --nodeps NetworkManager-tui-1.10.2-13.el7.x86_64
[root@openstack ~]# rpm -e --nodeps NetworkManager-1.10.2-13.el7.x86_64
[root@openstack ~]# rpm -qa  | grep NetworkManager*
[root@openstack ~]# killall -9 NetworkManager

3）检查配置主机网络参数
[root@openstack ~]# cat /etc/sysconfig/network-scripts/ifcfg-eth0 
# Generated by dracut initrd
DEVICE="eth0"
ONBOOT="yes"
NM_CONTROLLED="no"
TYPE="Ethernet"
BOOTPROTO="static"
PERSISTENT_DHCLIENT="yes"
IPADDR=192.168.1.10
NEMASK=255.255.255.0
GATEWAY=192.168.1.254

4）验证主机名是否互通
[root@openstack ~]# ping openstack
64 bytes from openstack (192.168.1.10): icmp_seq=1 ttl=255 time=0.023 ms
64 bytes from openstack (192.168.1.10): icmp_seq=2 ttl=255 time=0.027 ms
[root@openstack ~]# ping nova01
PING nova01 (192.168.1.11) 56(84) bytes of data.
64 bytes from nova01 (192.168.1.11): icmp_seq=1 ttl=255 time=0.139 ms
[root@openstack ~]# ping nova02
PING nova02 (192.168.1.12) 56(84) bytes of data.
64 bytes from nova02 (192.168.1.12): icmp_seq=1 ttl=255 time=0.251 ms


案例4：检查基础环境
1.是否卸载firewall和NetworkManager
2.检查配置主机网络参数(静态IP)
3.主机名必须能够相互ping通
4.检查配置主机yum源(4个,10670)
5.依赖软件包是否安装
6.检查NTP服务器是否可用
7.检查/etc/resolv.conf不能有search开头的行
8.安装 Openstack


cloud_day03=====================================================================================================================
项目管理


基本概念
  项目：一组隔离的资源和对象。由一组关联的用户进行管理
  在旧版本里，也用租户( tenant)来表示
  根据配置的需求，项目对应一个组织公司或是一个使用客户等
  项目中可以有多个用户，项目中的用户可以在该项目创建、管理虚拟资源
  具有admin角色的用户可以创建项目
  项目相关信息保存到 MariaDB中

基本概念(续1)
缺省情况下， packsack安装的openstack中有两个
  admin：为 admin账户创建的项目
  services：与安装的各个服务相关联


在Horizon中管理项目
通过 Horizon可以进行项目的创建和删除


通过命令行管理项目
1).创建名为 myproject项目
[root@openstack (keystone admin)]# openstack project create myproject
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack project create zhai02
2).列出所有项目
[root@openstack (keystone admin)]# openstack project list
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack project list
3)查看myprojec详细信息
[root@openstack (keystone admin )] openstack project show myproject
例:
[root@openstack02 ~]# source keystonerc_admin 
[root@openstack02 ~(keystone_admin)]#  openstack project show zhai02
4).禁用与激活项目
[root@openstack (keystone admin)]# openstack project set --disable myproject
[root@openstack(keystone admin )]# openstack project set --enable myproject
例:
[root@openstack02 ~]# source keystonerc_admin 
[root@openstack02 ~(keystone_admin)]# openstack project create zhai01
[root@openstack02 ~(keystone_admin)]# openstack project set --disable zhai01  #禁用项目
[root@openstack02 ~(keystone_admin)]# openstack project set --enable zhai01   #激活项目
5).查看项目配额
[root@openstack(keystone admin)# nova quota-show --tenant myproject
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# nova quota-show --tenant zhai01
6).更新可用vcpu数目为30
[root@openstack"(keystone admin)# nova quota-update --cores 30
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# nova quota-update --cores 30

myproject
删除 myproject
[root@openstack(keystone admin)] openstack project delete myproject


基本概念
   用户在 openstack中用于身份认证
   管理员用户 admin一般在 packsack安装过程中创建
   其他用户由管理员用户创建，并指定可以访问的项目
   非管理员用户创建后，保存到 Maria DB中

基本概念(续1)
非管理员用户具有以下权限
  创建卷和快照
  创建镜像
  分配浮动IP
  创建网络和路由器
  创建防火墙以及规则、规则策略
  查看网络拓扑、项目使用概况等


案例1：管理项目
通过 Horizon完成以下操作
  1.创建名为tedu的项目
  2.创建用户uu来管理这个项目


通过Horizon管理用户
  首先，创建名为 myproject项目，保持默认配置
  创建user1用户，指定项目为 myproject

通过命令行管理用户
1).创建user2用户，指定密码为 tedu.cn
[root @openstack ( keystone admin)] openstack user create --password tedu.cn user2
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack user create --password 123456 user01  #创建user用户，指定密码为123456

2).设置user2的ema地址
root@openstack(keystone admin)]# openstack user set --email user2@tedu.cn user2
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack user set --email user01@tedu.cn user01  #设置user01的email地址

3).列出所有用户
[root @openstack"(keystone admin)]t openstack user list
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack user list  #列出所有用户

4).查看user2信息
[root @openstack(keystone admin)]# openstack user show user2
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack user show user01  #查看user01信息

5).指定uer2可以访问 myproject，角色为_member_
[root @openstack(keystone admin)]# openstack role add --user user2 --project myproject member
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack role add --user user01 --project zhai01 _member_  #指定uer01可以访问zhai01，角色为 member
+-----------+----------------------------------+
| Field     | Value                            |
+-----------+----------------------------------+
| domain_id | None                             |
| id        | 9fe2ff9ee4384b1894a90878d3e92bab |
| name      | _member_                         |
+-----------+----------------------------------+

6).查看user2在 myproject中的角色
[root @openstack"(keystone admin)]# openstack role list--project myproject --user user2
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack role list --project zhai01 --user user01
Listing assignments using role list is deprecated as of the Newton release. Use role assignment list --user <user-name> --project <project-name> --names instead.
+----------------------------------+----------+---------+--------+
| ID                               | Name     | Project | User   |
+----------------------------------+----------+---------+--------+
| 9fe2ff9ee4384b1894a90878d3e92bab | _member_ | zhai01  | user01 |
+----------------------------------+----------+---------+--------+

7).禁用用户
[root@openstack (keystone admin)]# openstack user set --disable user2
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack user set --disable user01  #禁用用户

8).激活用户
[root @openstack(keystone admin )] openstack user set --enable user2
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack user set --enable user01  #激活用户

9).修改user2的密码为 Redhat
[root@openstack(keystone admin )# openstack user set --password redhat user 2
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack user set --password 123456 user01  #修改user01的密码为123456

10).将user2从myproject中移除
[root @openstack (keystone admin)]# openstack role remove project myproject --user user 2 member
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack role remove --project zhai01 --user user01 _member_  #将user01从zhai01中移除

11).删除user2用户
[root@openstack"(keystone admin)]# openstack user delete user2
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack user delete user01

========================================================================================
配额管理


配额管理
 1.管理员可以通过配额限制，防止资源的过度使用 
 2.配额基本项目，限制每个项目可以使用多少资源
 3.这些操作上的功能限制，赋予了管理员对每个项目的精准控制

资源参数
  安全组规则：指定每个项目可用的规则数
  核心：指定每个项可用的VCPU核心数
  固定地址：指定每个项目可用的固定P数
  浮动P地址：指定每个项目可用的浮动P数
  注入文件大小：指定每个项目内容大小
  注入文件路径：指定每个项目注入的文件路径长度


资源参数(续1)
  注入文件：指定每个项目允许注入的文件数目
  实例：指定每个项目可创建的虚拟机实例数目
  密钥对：指定每个项可创建的密钥数
  元数据：指定每个项目可用的元数据数目
  内存：指定每个项目可用的最大内存
  安全组：指定每个项目可创建的安全组数目

通过 Horizon管理配额


通过命令行管理配额
1).列出项目的缺省配额
[root@openstack (keystone admin)]# nova quota-defaults
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# nova quota-defaults  #列出项目的缺省配额

2)列出 myproject的配额
[root@openstack (keystone admin)]# nova quota-show-tenant
例:
[root@openstack02 ~]# source keystonerc_admin

myproject
3).修改浮动IP地址配额
[root@openstack(keystone admin)]# nova quota-update-floating-ips 20 myproject


========================================================================
云主机类型管理

云主机类型

基本概念
  云主机类型就是资源的模板
  它定义了一台云主机可以使用的资源，如内存大小磁盘容量和CPU核心数等
  Openstack提供了几个默认的云主机类型
  管理员还可以自定义云主机类型

云主机类型参数
  Name：云主机类型名称
  ID：云主机类型ID，系统自动生成一个UUID
  VCPUs：虚拟CPU数目
  RAM(MB)：内存大小
  Root disk(GB)：外围磁盘大小。如果希望使用本地磁盘，设置为0
  临时磁盘：第二个外围磁盘
  swap磁盘：交换磁盘大小


案例2：新建云主机类型

分别通过 Horizon和C练习创建云主机类型
  1.名字:m2tiny
  2.ID:自动
  3.虚拟内核:1个
  4.内存:512M
  5.根磁盘:10GB
  6.临时磁盘和sWap无要求


通过Horizon管理云主机类型

通过命令行管理云主机类型
1).列出所有的云主机类型
[root@openstack~(keystone admin)]# openstack flavor list
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack flavor list  #列出所有的云主机类型

2).创建一个云主机类
[root@openstack(keystone admin)]# openstack flavor create --public demo.tiny --id auto --ram 512 --disk 10 --vcpus 1
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack flavor create --public demo.tiny --id auto --ram 512 --vcpus 1

3).删除云主机类型
[root@openstack (keystone admin)]# openstack flavor delete demo.tiny
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack flavor delete demo.tiny


===================================================================================
镜像管理


镜像管理
  在红帽 Openstack平台中，镜像指的是虚拟磁盘文件磁盘文件中应该已经安装了可启动的操作系统
  镜像管理功能由 Glance服务提供
  它形成了创建虚拟机实例最底层的块结构
  镜像可以由用户上传，也可以通过红帽官方站点下载

Glance磁盘格式
  raw：非结构化磁盘镜像格式
  vhd: VMware、Xen、Microsoft、Virtua|Box等均支持的通用磁盘格式
  vmdk：是Vmware的虚拟磁盘格式
  vdi： VirtualBox虚拟机和QEMU支持磁盘格式
  iso：光盘数据內容的归档格式
  qoW2：QEMU支持的磁盘格式。空间自动扩展，并支持写时复制 copy-on- write


镜像服务
  镜像服务提供了服务器镜像的拷贝、快照功能，可以作为模板快速建立、起动服务器
  镜像服务维护了镜像的一致性
  课·当上传镜像时，容器格式必须指定
  容器格式指示磁盘文件格式是否包含了虚拟机元数据

镜像容器格式
  bare：镜像中没有容器或元数据封装
  ovf：种开源的文件规范，描述了一个开源、安全、有效、可拓展的便携式虚拟打包以及软件分布格式
  ova：OVA归档文件
  aki：亚马逊内核镜像
  ami：亚马逊主机镜像


============================================================================
镜像应用

案例3：上传镜像
  1.将本机上的rhe6磁盘镜像文件 small.img上传
  2.上传到 Openstack的名称为 small_rhel6
  3.设置镜像属性为public
  4.镜像最小磁盘大小为10GB，最小内存为512MB


通过Horizon管理镜像

通过命令行管理镜像
1).上传镜像
[root @openstack (keystone admin)]# openstack image create --disk-format qcow2 --min-disk 10 --min-ram 512 --file /root/small.img small_rhel6
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack image create --disk-format qcow2 --min-disk 10 --min-ram 512 --file /small.img  small_rhel6

2).列出镜像
[root@openstack"(keystone admin)]# openstack image list
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack image list  #列出镜像

3).查看镜像详情
[root@openstack ( keystone admin)]# openstack image show small_rhel6  
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack image show small_rhel6  #查看镜像详情

4).修改镜像属性
[root @openstack "(keystone admin)] openstack image set --public small_rhel6  
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack set --public small_rhel6  #修改镜像属性

5).另存镜像为本地文件
[root@openstack(keystone admin)]# openstack image save --file /tmp/small.img small_rhel6
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack image save --file /tmp/small.img small_rhel6  #另存镜像为本地文件

6).删除镜像
[root@openstack (keystone admin)]# openstack image delete small_rhel6
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack image delete small_rhel6


========================================================================================
网络管理

案例4：创建网络
1.在 myproject中创建两个网络，一个内网，用于连接实例，一个外网，用于对外通信
2.创建一个路由器，将两个网络连接起来

Openstack网络工作原理
   实例被分配到子网中，以实现网络连通性
   每个项目可以有一到多个子网
   在红帽的 Openstack平台中， Open StackI网络服务是缺省的网络选项，Nova网络服务作为备用
   管理员能够配置丰富的网络，将其他 Openstack服务连接到这些网络的接口上
   每个项目都能拥有多个私有网络，各个项目的私有网络互相不受干千扰

网络类型
  项目网络：由Neutron提供的项目内部网络，网络间可用VLAN隔离
  外部网络：可以让虚拟机接入外部网络，但需要配置浮动动IP地址
  提供商网络：将实例连接到现有网络，实现虚拟机实例与外部系统共享同一二层网络

通过命令行管理网络
1).创建网络
[root@openstack"(keystone admin ] openstack network create--project myproject --enable internal
例:
[root@openstack02 ~]# source keystonerc_admin
[root@openstack02 ~(keystone_admin)]# openstack network ceate --project zhaiproject --enable internal

2).创建子网
[root @openstack( keystone admin )] neutron subnet-create--name subnet3 --gateway 192 168.1.254 --allocation-pool start=192.168.1.100,end=192.168.1.200 --enable-dhcp internal 192168.10/24 --tenant-id ff87162978643f894cd01c98597160c
例:
[root@openstack02 ~]# source keystonerc_admin
neutron subnet-create--name subnet3 --gateway 192 168.1.254 --allocation-pool start=192.168.1.100,end=192.168.1.200 --enable-dhcp internal 192168.10/24 --tenant-id ff87162978643f894cd01c98497169c

3).查看网络详情
[root@openstack(keystone admin ] openstack network show internal
例:
[root@openstack02 ~]# source keystonerc_admin

4).新建路由器
[root @openstack(keystone admin)] neutron router-create --tenant-id
ff387162978643f894cdd1c98597160cr2
删除网络
[root @openstack(keystone admin)]# openstack network delete internal
[root@openstack(keystone admin) ]# neutron router-delete r2


浮动IP地址

案例5：管理浮动IP地址
1.通过 Horizon创建一个浮动P地址
2.通过命令行创建一个浮动P地址

浮动IP地址的作用
  浮动IP一般是花钱购买的
  浮动IP地址用于从外界访问虚拟机实例
  浮动P地址只能从现有浮动P地址池中分配
  创建外部网络时，浮动P地址池被定义
  虚拟机实例起动后，可以为其关联一个浮动IP地址
  虚拟机实例也可以解除IP地址绑定

通过命令行管理浮动IP地址
1).分配地址
[root @openstack"( keystone admin)]# neutron floatingip-create --tenant-id 1387162978643f894cdd1c98597160cWAN

2).查看地址
root@openstack(keystone admin]# neutron floatingip-list


=========================================================================
安全管理

安全组
  安全组用于控制对虚拟机实例的访问
  安全组在高层定义了哪些网络及哪些协议是被授权可以访问虚拟机实例的
  每个项目都可以定义自己的安全组
  项目成员可以编辑默认的安全规则，也可以添加新的安全规贝
  所有的项目都有一个默认的 default安全组

安全组规则
  安全组规则定义了如何处理网络访问
  规则基于网络或协议定义
  每个规则都有出和入两个方向
  规则也可以指定i协议版本
  默认的安全组规则，允许虚拟机实例对外访问，但是阻止所有对虛拟机实例的访问


案例6：创建安全组及规则
  1.新建一个安全组
  2.添加规则，允许任意主机可以通过SSH访问虚拟机实例
  3.添加规则，允许任意主机可以通过 Https访问虚拟机实
  4.添加规则，只允许本组内的主机可以通过HTTP访问到虚拟机实例


云主机实例要求
  使用m2.tny云主机类型
  云主机处于新建的安全组中
  将云主机接入到内部网络

 
案例7：创建云主机
  1.使用m2tiny云主机类型
  2.将云主机加入到内部网络
  3.设置安全规则，允许外界png通云主机
  4.设置外界可以h到云主机


环境准备

基础环境准备
扩容 openstack计算节点
  参考nova01配置过程
  配置静态ip:192.168.1.12，及主机名
  保证与 openstack，和nova01能相互ping通
  配置/etc/resolv.conf，删除 search开头行
  配置时间同步/etc/chrony.conf
  配置yum源，软仓库一共4个(10670)
  安装依赖软件包qemu-kym libvirt-client libvirt-daemon libvirt-daemon-driver-gemu python-setuptools

==================================================================================
安装计算节点


修改应答文件
openstack计算节点采用远程安装
  即在 openstack上执行指令，远程安装nova02
  远程安装使用ssh指令，从 openstack上必须能够通过ssh命令登录nova02
在openstack上修改配置文件
[root@openstack]# vim answer. ini 98:CONFIG_COMPUTE HOST=192.168.1.11,192.168.1.12
102: CONFIG NETWORK HOSTS=192.168.1.10,192.168.1.11,192.168.1.12


安装节点
在openstack上重新执行安装命令
 [root @openstack]# packstack--answer-file answer ini
按提示，输入远程主机root密码
本机已安裝服务，不会被覆盖，只有改动后的选项才需要重新配置
安装后， apache配置已被还原，需要重新添加
  WSGIApplication Group %GLOBAL]


查看节点状态
达内教育

案例8：安装额外计算节点
nova02请参考nova01的配置步骤
迁移云主机
  有多个nova计算节点的时候，我们可以选择性的把某一个云主机从某台机器上迁移到另外一台机器上
迁移条件
  nova计算节点与 openstack管理节点都能相互ping通，主机名称也要能png通
  所有计算节点安装qemu- mg-rhev， gemu- kym-rhev
  如未安装，在安装以后需要重启 libvirto服务


无法配置外部网络
问题现象
在 Horizon界面中，希望将网络WAN设置为“外部网络络”，可是找不到设置外部网络的入口


故障分析及排除
原因分析
  外部网络只有管理员才能设置
解决办法
  注销当前用户，使用管理员 admin设置外部网络


云主机无法PNG通
问题现象
  已经为云主机分配了浮动IP地址
  可以通过SSH连接到云主机
  远程PING云主机时，却请求超时


故障分析及排除
原因分析
  能够通过SSH通信，证明网络是通畅的
  PING不通需要检查安全配置
解决办法
  设置安全组规则，允许ICMP协议进入


cloud_day04=====================================================================================================================

Docker概述

什么是容器
  容器技术已经成为应用程序封装和交付的核心技术
  容器技术的核心有以下几个内核技术组成
    Groups( Control Groups)资源管理
    Name space-进程隔离
    SELinux安全
   由于是在物理机上实施隔离，启动一个容器，可以像启动一个进程一样快速

什么是Docker
  Docker是完整的一套容器管理系统
  Docker提供了一组命令，让用户更加方便直接地使用容器技术，而不需要过多关心底层内核技术


Docker特性

Docker优点
  相比于传统的虚拟化技术，容器更加简洁高效
  传统虚拟机需要给每个ⅧM安装操作系统
  容器使用的共享公共库和程序

Docke缺点
  容器的隔离性没有虚拟化强
  共用 Linux内核，安全性有先天缺陷
  SeLinux难以驾驭
  监控容器和容器排错是挑战


======================================================
部署 Docker

案例1：安装 Docker
  1.准备两台虚拟机，IP为1921681.31和192.168132
  2.安装 docker
  3.关闭防火墙

安装软件

安装前准备
  需要64位操作系统
  至少RHEL65以上的版本，强烈推荐RHEL7
  关闭防火墙(不是必须)

安装 Docker
配置yum源
 docker软件包位于光盘RHEL7-extras.iso中
  在物理机的ftp目录下创建文件夹extras
    mkdir /var/ftp/extras
  把光盘挂到这个目录下
    mount-t iso9660 -o ro,loop RHEL7OSP-extras iso /var/ftp/rhelosp
例:
在真机操作
[root@room9pc01 ~]# mkdir /var/ftp/extras 
[root@room9pc01 ~]# cp RHEL7-extras.iso /var/ftp/extras
[root@room9pc01 ~]# mount-t iso9660 -o ro,loop RHEL7OSP-extras iso /var/ftp/rhelosp  #把光盘挂到这个目录下

安装 Docker
在虚拟机中配置yum源，指向刚刚创建的目录
  [extras]
  name=CentoS-Sreleasever -Extras
  baseurl=ftp: //192. 168.1.254/extras
  enabled=1
  gpgcheck=0
软件包安装
  [root@docker31 ]# yum -y install docker
  [root@docker31 ]# systemctI restart docker
  [root@docker31 ]# systemctl enable docker
例:
在虚拟机操作(此过程两台虚拟机都操作,一台为例)
[root@docker31 ~]# vim /etc/yum.repos.d/local.repo  #在虚拟机中配置yum源，指向刚刚创建的目录
  [extras]
  name=CentoS-Sreleasever -Extras
  baseurl=ftp: //192. 168.1.254/extras
  enabled=1
  gpgcheck=0
[root@docker31 ~]# yum -y install docker
[root@docker31 ~]# systemctl restart docker
[root@docker31 ~]# systemctl enable docker


===============================================================================
Docker镜像


什么是镜像
  在 Docker中容器是基于镜像启动的
  镜像是启动容器的核心
  镜像采用分层设计
  使用快照的COW技术，确保底层数据不丢失

Docker hub镜像仓库
  https://hub.docker.com
  Docker官方提供公共镜像的仓库( Registry)
[root@docker31 ~]# docker image
[root@docker1 ~]# docker search busybox
[root@docker1 ~]# docker search centos
[root@docker1 -]# docker search nginx
例:
此过程两台虚拟机都操作,一台为例
[root@docker31 ~]# docker pull docker.io/busybox
[root@docker31 ~]# docker search busybox
[root@docker31 ~]# docker search centos
[root@docker31 ~]# docker pull docker.io/centos
[root@docker31 ~]# docker search nginx
[root@docker31 ~]# docker pull docker.io/nginx
[root@docker31 ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
docker.io/nginx     latest              f68d6e55e065        8 days ago          109.3 MB
docker.io/busybox   latest              e4db68de4ff2        3 weeks ago         1.224 MB
docker.io/centos    latest              9f38484d220f        3 months ago        201.8 MB


案例2：镜像基本操作
1.导入镜像
2.导出镜像
3.启动镜像

镜像操作

下载、上传镜像

  下载镜像(从镜像仓库中下载煷像)
  [root@docker1 ~] docker help pull
     docker pull [OPTIONS] NAME[:TAG@DIGEST
  [root@docker1 ~] docker pull docker.io/busybox
上传镜像(上传镜像到仓库)
  [root@docker1 -] docdocker help push
    Usage: docker push [OPTIONS] NAMEE: TAG
  [root@docker1 -] docker push docker.io/busybox


导入、导出镜像

1).导出镜像(将本地镜像导出为tar文件)
  [root@docker1 ~]# docker save docker.io/busybox: latest -o busybox.tar  #导出镜像
  [root@docker1 ~]# ls
  [root@docker31 ~]# rsync busybox.tar root@192.168.1.167:/  #将tar上传包给192.168.1.167
例:
[root@docker31 ~]# docker save docker.io/busybox:latest -o busybox.tar
[root@docker31 ~]# ls
busybox.tar  f1  setip

2)导入镜像(通过tar包文件导入镜像)
[root@docker1 ~]# scp nginx tar root @192.168 1.31:/root
[root@docker2 ~]# ls
nginx.tar
[root@docker 2 ~]# docker load -i nginx.tar
[root@docker 2 ~]# docker images
例:
[root@docker32 ~]# docker load -i /busybox.tar  #导入镜像


启动镜像
1).启动centos镜像生成一个容器
[root @docker1] docker images
[root @docker1 ] docker run -it docker.io/ centos:latest /bin/bash  
例:
[root@docker31 ~]# docker images
[root@docker31 ~]# docker run -it docker.io/centos:latest /bin/bash  #启动centos镜像生成一个容器
root@fa56cf246b7b:/# rm -rf /*  #删除容器根

2).开启另一个终端(查看容器信息)
[root@docker1]# docker ps
例:
[root@docker31 ~]# docker ps  #查看容器信息

==============================================================================
Docker基本命令

命令列表

命令列表
docker images   #查看镜像列表
docker history  #查看镜像制作历史
docker inspect  #查看镜像底层信息
docker pul      #下载镜像
docker push     #上传镜像
例:
[root@docker31 ~]# docker images  #查看镜像列表
[root@docker31 ~]# docker history docker.io/busybox
[root@docker31 ~]# docker history docker.io/nginx
[root@docker31 ~]# docker inspect docker.io/busybox

命令列表(续1)
命令列表
docker rmi     #删除本地镜像
docker save    #镜像另存为tar包
docker load    #使用ta包导入镜像
docker search  #搜索镜像
docker tag     #修改镜像名称和标签
例:
[root@docker31 ~]# docker tag docker.io/nginx nsd:1903         #修改镜像名称和标签
[root@docker1 ~]# docker rm $(docker ps -aq)  
[root@docker31 ~]# docker rmi nsd:1903                         #删除本地镜像
[root@docker32 ~]# docker load -i /busybox.tar                 #使用ta包导入镜像
[root@docker31 ~]# docker search docker.io/busybox             #搜索镜像
[root@docker31 ~]# docker save docker.io/centos -o centos.tar  #镜像另存为tar包


1).docker images
查看镜像列表
  镜像仓库名称
  镜像标签
  镜像ID
  创建时间
  大小
[root@docker1]# docker images  #查看镜像列表

2).docker history
查看镜像历史
   了解镜像制作过程
   详细参考后面的 dockerfile内容
[root@docker1 ~]# docker history docker.io/centos

3).docker inspect
查看镜像底层信息
  了解镜像环境变量、存储卷、标签等信息
[root@docker1]# docker inspect docker.io/centos

4).docker rmi

删除本地镜像
  注意：启动容器时删除镜像会提示错误
[root(@docker1 -]# docker rmi docker.io/centos

5).docker save | load
保存本地镜像另存为tar文件
   方便其他人使用tar包导入镜像
[root@docker1 -]# docker save docker.io /busybox:latest-o busybox tar
[root(@docker1-]# ls busybox.tar
busybox.tar
使用tar包文件导入镜像
[root@docker1]# docker load -i busybox tar

6).docker tag
重命名镜像名称(复制)
[root@docker1 ~]# docker images  #查看镜像列表
[root@docker1 ~]# docker tag docker. o/centos: latest cen: v1
[root@docker1 ~]# docker images


容器常用命令

命令列表
docker run          #运行容器
docker ps           #查看容器列表
docker stop         #关闭容器
docker start        #启动容器
docker restart      #重启容器
docker attach|exec  #进入容器
docker inspect      #查看容器底层信息
docker top          #查看容器进程列表
docker rm           #删除容器
例:
[root@docker32 ~]# docker run -it docker.io/nginx:latest  #运行容器


镜像与容器常用指令

1）查看后台运行的容器
[root@docker1 docker]# docker run -d docker.io/nginx   #启动nginx的镜像
[root@docker1 docker]# docker ps                       #查看后台运行的容器
例: 
[root@docker31 ~]# docker run -d docker.io/redis  #启动nginx的镜像(放在后台)
[root@docker31 ~]# docker ps                      #查看后台运行的容器

2）只显示容器ID
[root@docker1 docker]# docker ps -q
例:
[root@docker31 ~]# docker ps -q  #只显示容器ID
0005916a2fbb

3）显示所有的容器,包括没有启动的
[root@docker1 docker]# docker ps -a  #显示所有的容器,包括没有启动的
例:
[root@docker31 ~]# docker ps -a  #显示所有的容器,包括没有启动的

4）显示所有的容器ID
[root@docker1 docker]# docker ps -qa
81458156f6e8
3656f1978967
例:
[root@docker31 ~]# docker ps -qa  #显示所有的容器ID

5）查看centos镜像历史（制作过程)
[root@docker1 docker_images]# docker history docker.io/centos
例:
[root@docker31 ~]# docker history docker.io/centos  #查看centos镜像历史（制作过程)
IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
76d6bc25b8a5        9 months ago        /bin/sh -c #(nop)  CMD ["/bin/bash"]            0 B                 
<missing>           9 months ago        /bin/sh -c #(nop)  LABEL org.label-schema.sch   0 B                 
<missing>           9 months ago        /bin/sh -c #(nop) ADD file:8f4b3be0c1427b158f   199.7 MB 

6）删除镜像，启动容器时删除镜像会失败，先删除容器,再删除镜像
格式：docker rmi镜像名
[root@docker31 ~]# docker ps -qa         #显示所有的容器ID
[root@docker1 docker]# docker rmi nginx  #nginx为镜像名
Error response from daemon: conflict: unable to remove repository reference "nginx" (must force) - container 81458156f6e8 is using its referenced image 42b4762643dc  #删除时报错
[root@docker1 docker]# docker stop 81
81
[root@docker1 docker]# docker rm 81
81
[root@docker2 ~]# docker rmi docker.io/nginx  #删除nginx镜像
Untagged: docker.io/nginx:latest
Deleted: sha256:42b4762643dcc9bf492b08064b55fef64942f055f0da91289a8abf93c6d6b43c
Deleted: sha256:e0e55dd2303b3e3ec852acae267d1f8a3eea27a22c64a5829304ecee4d3f559c
Deleted: sha256:4062cf272cdd99e83b1c21f712e5e1359c91ecf92925e56c62133c3324b84e45
Deleted: sha256:3c816b4ead84066ec2cadec2b943993aaacc3fe35fcd77ada3d09dc4f3937313 
例:
[root@docker31 ~]# docker ps            #查看后台运行的容器
[root@docker31 ~]# docker rmi registry  #registry为镜像名,
rror response from daemon: conflict: unable to remove repository reference "registry" (must force) - container b88bd537842d is using its referenced image 116995fd6624  #删除时报错
[root@docker31 ~]# docker stop b88bd537842d              #b88bd537842d是registry镜像ID,停止镜像
[root@docker31 ~]# docker rmi docker.io/registry         #删除registry镜像

7）修改镜像的名称和标签,默认标签为latest
[root@docker1 docker_images]# docker tag  docker.io/centos:latest docker.io/cen:v1
[root@docker2 ~]# docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
docker.io/centos     latest              42b4762643dc        4 weeks ago         109.2 MB
docker.io/cen     v1                  42b4762643dc        4 weeks ago         109.2 MB
例:
[root@docker31 ~]# docker images  #查看镜像
docker.io/justinribeiro/chrome-headless   latest              2a0918a52266        5 weeks ago         694.8 MB
[root@docker31 ~]# docker tag docker.io/justinribeiro/chrome-headless:latest zhaiyanqan:zhai 
[root@docker31 ~]# docker images  #查看镜像
docker.io/justinribeiro/chrome-headless   latest              2a0918a52266        5 weeks ago         694.8 MB
zhaiyanqan                                zhai                2a0918a52266        5 weeks ago         694.8 MB

8）查看镜像的底层信息，如图-3所示：
[root@docker1 docker_images]# docker inspect docker.io/centos
例:
[root@docker31 ~]# docker images                    #查看镜像
[root@docker31 ~]# docker inspect docker.io/centos  #查看镜像的底层信息

9）修改镜像的标签
[root@docker1 docker_images]# docker tag  docker.io/centos:latest docker.io/cen:v1 
[root@docker1 docker_images]# docker images
REPOSITORY   TAG            IMAGE ID          CREATED          SIZE
    docker.io/cen        v1             e934aafc2206   5 months ago    198.6 MB 
[root@docker1 docker_images]# docker rmi docker.io/centos  #删除centos
[root@localhost ~]# docker run -it centos                  #启动的时候，因为是用标签标签启动的，所以会重新通过ID下载
[root@docker1 docker]# docker run -it docker.io/centos
Unable to find image 'centos:latest' locally
Trying to pull repository registry.access.redhat.com/centos ... 
Trying to pull repository docker.io/library/centos ... 
latest: Pulling from docker.io/library/centos
a02a4930cb5d: Pull complete 
Digest: sha256:184e5f35598e333bfa7de10d8fb1cebb5ee4df5bc0f970bf2b1e7c7345136426
[root@b6c5f16461f5 /]#
[root@localhost ~]# docker run -it docker.io/cen:v1  #通过新建的标签启动docker.io/cen:v1
例:
[root@docker31 ~]# docker images  #查看镜像
docker.io/nginx      latest        42b4762643dc        5 months ago        109.2 MB
[root@docker31 ~]# docker tag docker.io/nginx:latest docker.io/nginx:nginx  #修改镜像的标签
[root@docker31 ~]# docker images                                            #查看镜像
docker.io/nginx      nginx          42b4762643dc        5 months ago        109.2 MB
[root@docker31 ~]# docker rmi docker.io/nginx  #删除nginx
[root@docker31 ~]# docker run -it nginx        #启动的时候，因为是用标签标签启动的，所以会重新通过ID下载(用标签启动)


容器命令
1）关闭容器
命令：docker stop 容器ID
[root@docker1 docker]# docker stop 0f  #0f为容器ID
0f
例:
[root@docker31 ~]# docker ps  #查看后台运行的容器
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
1ff91d4107f7        nginx               "nginx -g 'daemon off"   2 minutes ago       Up 2 minutes        80/tcp              agitated_bhaskara
dd404faba303        42b4762643dc        "nginx -g 'daemon off"   34 minutes ago      Up 34 minutes       80/tcp              agitated_swanson
0005916a2fbb        docker.io/redis     "docker-entrypoint.sh"   45 minutes ago      Up 45 minutes       6379/tcp 
[root@docker31 ~]# docker stop 0005916a2fbb  #0005916a2fbb为容器ID
[root@docker31 ~]# docker ps                 #查看后台运行的容器
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
1ff91d4107f7        nginx               "nginx -g 'daemon off"   3 minutes ago       Up 3 minutes        80/tcp              agitated_bhaskara
dd404faba303        42b4762643dc        "nginx -g 'daemon off"   35 minutes ago      Up 35 minutes       80/tcp 

2）启动容器
[root@docker1 docker]# docker start 0f
0f
例:
[root@docker31 ~]# docker start 0005916a2fbb  #启动容器,0005916a2fbb为容器ID
[root@docker31 ~]# docker ps                  #查看后台运行的容器
\CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
1ff91d4107f7        nginx               "nginx -g 'daemon off"   6 minutes ago       Up 6 minutes        80/tcp              agitated_bhaskara
dd404faba303        42b4762643dc        "nginx -g 'daemon off"   38 minutes ago      Up 38 minutes       80/tcp              agitated_swanson
0005916a2fbb        docker.io/redis     "docker-entrypoint.sh"   49 minutes ago      Up 33 seconds       6379/tcp

3）重启容器
 [root@docker1 docker]# docker restart 0f
0f
例:
[root@docker31 ~]# docker restart 0005916a2fbb  #重启容器,0005916a2fbb为容器ID

4）删除容器
运行中删除不掉，先关闭容器
[root@docker1 docker]# docker rm 0f  #删除失败
Error response from daemon: You cannot remove a running container 0f63706692e15134a8f07655a992771b312b8eb01554fc37e1a39b03b28dd05c. Stop the container before attempting removal or use -f
[root@docker1 docker]# docker stop 0f  #关闭容器
0f
[root@docker1 docker]# docker rm 0f    #删除成功
0f
[root@docker1 docker]#
例:
[root@docker31 ~]# docker ps                 #查看后台运行的容器
[root@docker31 ~]# docker rm 0005916a2fbb    #删除失败
[root@docker31 ~]# docker stop 0005916a2fbb  #关闭容器
[root@docker31 ~]# docker rm 0005916a2fbb    #删除成功

5）连接容器attach|exec
[root@docker1 docker]# docker attach  0f
[root@docker1 docker]# docker ps  #容器关闭
CONTAINER ID  IMAGE  COMMAND  CREATED  STATUS  PORTS  NAMES
[root@docker1 docker]#  docker exec -it 0f /bin/bash
[root@docker1 docker]# docker ps  #容器不会关闭
CONTAINER ID  IMAGE         COMMAND        CREATED          STATUS          PORTS     NAMES
0b3c50284a1c  docker.io/centos      "/bin/bash"   15 minutes ago   Up 15 minutes      tiny_lamarr
[root@docker1 docker]# docker top f7  #查看容器进程列表 
[root@docker1 docker]# docker run -itd docker.io/centos:latest
76e7577cff5d8a3ec877d3ea564fed2fb502bd4a0447705bec269a646d414d07
[root@docker1 docker]# ps
  PID TTY          TIME CMD
 5552 pts/0    00:00:00 bash
 6739 pts/0    00:00:00 ps
[root@docker1 docker]# docker exec -it 76 /bin/bash
[root@76e7577cff5d /]# sleep 50 &
[1] 30
[root@76e7577cff5d /]# exit
exit
[root@docker1 docker]# docker top 76
UID                 PID                 PPID                C               STIME               TTY                 TIME                CMD
root                6708                6691                0               17:00               pts/1               00:00:00            /bin/bash
UID    PID  PPID C   STIME     TTY         TIME      CMD
root  2744 2729  0   18:01    pts/4  00:00:00   /bin/bash
例:
[root@docker31 ~]# docker ps                   #查看后台运行的容器
[root@docker31 ~]# docker attach dd404faba303  #0005916a2fbb为容器ID,容器关闭
[root@docker31 ~]# docker ps                   #查看后台运行的容器
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
dd404faba303        42b4762643dc        "nginx -g 'daemon off"   46 minutes ago      Up 46 minutes       80/tcp              agitated_swanson

6）过滤查看mac和ip地址
[root@docker1 docker]# docker inspect -f '{{.NetworkSettings.MacAddress}}' 76
02:42:ac:11:00:04
[root@docker1 docker]# docker inspect -f '{{.NetworkSettings.IPAddress}}' 76
172.17.0.4
例:
[root@docker31 ~]# docker ps  #查看后台运行的容器
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS               NAMES
b4ae1042bdc4        docker.io/nginx     "nginx -g 'daemon off"   11 seconds ago      Up 9 seconds        80/tcp              stoic_golick
cb54ba641f87        docker.io/redis     "docker-entrypoint.sh"   24 seconds ago      Up 22 seconds 
[root@docker31 ~]# docker inspect -f '{{.NetworkSettings.MacAddress}}' b4ae1042bdc4  #过滤查看mac地址
02:42:ac:11:00:03
[root@docker31 ~]# docker inspect -f '{{.NetworkSettings.IPAddress}}' b4ae1042bdc4   #过滤查看ip地址
172.17.0.3

7）修改nginx的显示内容
[root@docker1 docker_images]# docker run -it docker.io/nginx:latest 
[root@docker1 docker_images]# docker exec -it 56 /bin/bash
root@56ec8154f8e0:/# nginx -T /usr/share/nginx/html/
nginx: invalid option: "/usr/share/nginx/html/"   #查找并显示结果
root@56ec8154f8e0:/# echo  aaa > /usr/share/nginx/html/index.html 
#修改主页显示的内容
root@56ec8154f8e0:/# nginx -T
root@56ec8154f8e0:/# cat /usr/share/nginx/html/index.html 
aaa
例:
[root@docker31 ~]# docker images  #查看镜像列表
[root@docker31 ~]# docker  run -it docker.io/nginx:latest  #

8）过滤查看nginx的ip地址
[root@docker1 docker]# docker inspect -f '{{.NetworkSettings.IPAddress}}' a6
172.17.0.3
[root@docker1 docker]# curl 172.17.0.3
aaa


cloud_day05=====================================================================================================================
制作自定义镜像
1.1 问题

本案例要求制作自定义镜像：
   基于centos镜像使用commit创建新的镜像文件
   基于centos镜像使用Dockerfile文件创建一个新的镜像文件

1.2 步骤
实现此案例需要按照如下步骤进行。
步骤一：使用镜像启动容器
1）在该容器基础上修改yum源
[root@docker1 docker_images]# docker run -it docker.io/centos
[root@8d07ecd7e345 /]# rm -rf /etc/yum.repos.d/*  
[root@8d07ecd7e345 /]# vi /etc/yum.repos.d/dvd.repo
[dvd]
name=dvd
baseurl=ftp://192.168.1.254/system
enabled=1
gpgcheck=0
[root@8d07ecd7e345 /]# yum clean all
[root@8d07ecd7e345 /]# yum repolist
例:
[root@abef7795ca3f /]# vim /etc/yum.repos.d/dvd.repo
[local_repo]
name=CentOS-$releasever - Base
baseurl="ftp://192.168.1.254/centos-1804"
enabled=1
gpgcheck=0

[RHEL7-extras]
name=RHEL7-extras
baseurl="ftp://192.168.1.254/RHEL7-extras"
enabled=1
gpgcheck=0
[root@abef7795ca3f /]# yum clean all
[root@abef7795ca3f /]# yum repolist

2）安装测试软件
[root@8d07ecd7e345 /]# yum -y install net-tools iproute psmisc vim-enhanced
例:
[root@abef7795ca3f /]# yum  -y install net-tools iproute vim psmisc tree lftp rsync

3）ifconfig查看
[root@8d07ecd7e345 /]# ifconfig 
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.17.0.3  netmask 255.255.0.0  broadcast 0.0.0.0
        inet6 fe80::42:acff:fe11:3  prefixlen 64  scopeid 0x20<link>
        ether 02:42:ac:11:00:03  txqueuelen 0  (Ethernet)
        RX packets 2488  bytes 28317945 (27.0 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 1858  bytes 130264 (127.2 KiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
[root@8d07ecd7e345 /]# exit
exit
例:
[root@abef7795ca3f /]# ifconfig  #ifconfig查看
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.17.0.2  netmask 255.255.0.0  broadcast 0.0.0.0
        inet6 fe80::42:acff:fe11:2  prefixlen 64  scopeid 0x20<link>
        ether 02:42:ac:11:00:02  txqueuelen 0  (Ethernet)
        RX packets 39711  bytes 73305654 (69.9 MiB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 36064  bytes 3091835 (2.9 MiB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0


步骤二：另存为另外一个镜像
1）创建新建镜像
[root@docker1 docker_images]# docker start 8d07ecd7e345        
//可以简写为8d，要保证唯一性
8d07ecd7e345
[root@docker1 docker_images]# docker commit 8d07ecd7e345 docker.io/myos:latest 
sha256:ac3f9c2e8c7e13db183636821783f997890029d687b694f5ce590a473ad82c5f
例:
[root@docker31 ~]# docker run -it docker.io/centos:latest
[root@docker31 ~]# docker ps  #查看后台运行的容器
CONTAINER ID    IMAGE                       COMMAND         CREATED             STATUS           PORTS      NAMES
ca939b9296ec    docker.io/centos:latest     "/bin/bash"     20 seconds ago      Up 17 seconds               peaceful_bartik
[root@docker31 ~]# docker commit ca939b9296ec centos_zyq:latest  #创建新建镜像,centos_zyq:latest是自定义
[root@docker31 ~]# docker images                                 #查看镜像
[root@docker31 ~]# docker run -it centos_zyq:latest              #启动容器
[root@2dc9de0639ab /]# 

2）查看新建的镜像
[root@docker1 ~]# docker images  #查看新建的镜像
REPOSITORY           TAG             IMAGE ID          CREATED              SIZE
docker.io/myos     latest       87feda116c17         6 weeks ago         321.6 MB
docker.io/busybox  latest       d8233ab899d4         7 weeks ago         1.199 MB
docker.io/nginx    latest       f09fe80eb0e7         9 weeks ago         109.2 MB
docker.io/redis    latest       82629e941a38        11 weeks ago        94.98 MB
docker.io/ubuntu   latest       20bb25d32758        11 weeks ago        87.47 MB
docker.io/registry latest       116995fd6624        11 weeks ago        25.76 MB
docker.io/centos   latest       1e1148e4cc2c        4 months ago        201.8 MB
例:
[root@docker31 ~]# docker images  #查看新建的镜像
REPOSITORY                      TAG            IMAGE ID            CREATED             SIZE
docker.io/centos_zhai           latest         1e034a6c4788        43 seconds ago      199.7 MB            

3）验证新建镜像
[root@docker1 docker_images]# docker run -it docker.io/myos:latest
[root@497c7b4664bf /]# ifconfig 
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet 172.17.0.6  netmask 255.255.0.0  broadcast 0.0.0.0
        inet6 fe80::42:acff:fe11:6  prefixlen 64  scopeid 0x20<link>
        ether 02:42:ac:11:00:06  txqueuelen 0  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 7  bytes 578 (578.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0
例:
[root@docker31 ~]# docker run -it docker.io/centos_zhai:latest
[root@fd0baa975eea /]# ifconfig  #验证新建镜像


步骤三：使用Dockerfile文件创建一个新的镜像文件

Dockerfile语法格式：
– FROM:基础镜像
– MAINTAINER:镜像创建者信息(说明)
– EXPOSE:开放的端口
– ENV:设置环境变量
– ADD:复制文件到镜像
– RUN:制作镜像时执行的命令,可以有多个
– WORKDIR:定义容器默认工作目录
– CMD:容器启动时执行的命令,仅可以有一条CMD
1）创建一个Apache的镜像文件
[root@docker1 ~]# mkdir bulid
[root@docker1 ~]# cd bulid
[root@docker1 bulid]# touch Dockerfile  #Dockerfile文件第一个字母要大写
[root@docker1 bulid]# cp /etc/yum.repos.d/local.repo  ./
[root@docker1 bulid]# vi Dockerfile
FROM  docker.io/myos:latest
RUN yum -y install httpd
ENV EnvironmentFile=/etc/sysconfig/httpd
WORKDIR /var/www/html/   #定义容器默认工作目录
RUN echo "test" > /var/www/html/index.html
EXPOSE 80                #设置开放端口号
CMD ["/usr/sbin/httpd", "-DFOREGROUND"]
[root@docker1 bulid]# docker build -t docker.io/myos:http .
[root@docker1 bulid]# docker run -d  docker.io/myos:http 
d9a5402709b26b42cd304c77be442559a5329dc784ec4f6c90e4abac1c88e206
[root@docker1 bulid]# docker inspect d9
[root@docker1 bulid]# curl 172.17.0.7
test
例:
[root@docker31 ~]# mkdir bulid ; cd bulid
[root@docker31 bulid]# touch Dockerfile  #Dockerfile文件第一个字母要大写
[root@docker31 bulid]# cp /etc/yum.repos.d/local.repo  ./
[root@docker31 bulid]# echo "343243254643dfedfdsf4543" >> index.html
[root@docker31 bulid]# echo "343243254643dfedfdsf4543" >> index.html
[root@docker31 bulid]# echo "343243254643dfedfdsf4543" >> index.html
[root@docker31 bulid]# echo "34324325464" >> index.html
[root@docker31 bulid]# vim Dockerfile
FROM  zhaiyanquan02:latest
RUN rm -f /etc/yum.repos.d/*.repo
ADD local.repo /etc/yum.repos.d/local.repo
RUN yum -y install httpd  #安装软件包
ENV EnvironmentFile=/etc/sysconfig/httpd
WORKDIR /var/www/html/    #定义容器默认工作目录
ADD index.html /var/www/html/index.html
EXPOSE 80                 #设置开放端口号
CMD ["/usr/sbin/httpd", "-DFOREGROUND"]
[root@docker31 bulid]# docker build -t myhttp:http .  #build是命令, myhttp:http是自定义
[root@docker31 bulid]# docker run -d myhttp:http
3d0880d6c08d7a10dd5901bc13d9ea7452bf4de38a318279080fee99bc971337
[root@docker31 bulid]# docker inspect 8e1410285ba5b547fe7e1d6361b60e61824215dec0a26429dedb8a067d2e1b46
"IPAddress": "172.17.0.5",
[root@docker31 bulid]# curl 172.17.0.5
zhaiyanquan2432546
343243254643dfedfdsf4543
343243254643dfedfdsf4543
343243254643dfedfdsf4543
34324325464


=============================================================================
创建私有镜像与仓库

2.1 问题
本案例要求创建私有的镜像仓库：
Docker主机：192.168.1.31
镜像仓库服务器：192.168.1.30
2.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：自定义私有仓库
1）定义一个私有仓库
[root@docker1 bulid]# vim /etc/docker/daemon.json  #不写这个文件会报错
{
    "insecure-registries": [ "192.168.1.30:5000" ]
}
[root@docker1 bulid]# systemctl restart docker
[root@docker1 bulid]# docker run -d -p 5000:5000 registry
273be3d1f3280b392cf382f4b74fea53aed58968122eff69fd016f638505ee0e
[root@docker1 bulid]# curl 192.168.1.30:5000/v2/
{}    #出现括号
[root@docker1 bulid]# docker tag docker.io/busybox:latest 192.168.1.30:5000/docker.io/busybox:latest  #打标签
[root@docker1 bulid]# docker push 192.168.1.30:5000/docker.io/busybox:latest  #上传
[root@docker1 bulid]# docker tag docker.io/myos:http 192.168.1.30:5000/ docker.io/myos:http
[root@docker1 bulid]# docker push  192.168.1.30:5000/docker.io/myos:http
例:
服务端

==============================================================================================
自定义镜像仓库

reistry基本概念: 恭喜一台镜像的服务器(镜像化的一台服务器)
安装私有仓库(服务端)
  yum -y install docker-distribution
启动私有仓库,并设置开机自启动
  systemctl restart docker-distribution.service
  systemctl enable docker-distribution.service
仓库配置文件及数据存储路径
  /etc/docker-distribution/registry/config.yml
例:
服务端
[root@docker31 ~]# yum -y install docker-distribution
[root@docker31 ~]# systemctl restart docker-distribution.service
[root@docker31 ~]# systemctl enable docker-distribution.service
[root@docker31 ~]# netstat -npult | grep :5000  #查看端口状态
[root@docker31 ~]# curl http://192.168.1.137:5000/v2/


客户端配置:
修改配置文件 /etc/sysconfig/docker
允许非加密方式问仓库
  INSECURE_REGISTRY='--insecure-registry docker1:5000'
docker 仓库地址
  ADD_REGISTRY='--add-registry docker1:5000'
重启动docker服务
  sysemctl restart docker
例:
[root@docker32 ~]# vim /etc/sysconfig/docker
13 ADD_REGISTRY='--add-registry 192.168.1.137:5000'
24 INSECURE_REGISTRY='--insecure-registry 192.168.1.137:5000'
[root@docker32 ~]# systemctl start docker



=====================================================================================
NFS共享存储


3.1 问题
本案例要求创建NFS共享，能映射到容器里：
服务器创建NFS共享存储，共享目录为/content，权限为rw
客户端挂载共享，并将共享目录映射到容器中

3.2 方案
本方案要求需要一台NFS服务器（NFS用真机代替），ip为192.168.1.254，一台客户端docker1主机，ip为192.168.1.10，一台户端docker2主机，ip为192.168.1.20，实现客户端挂载共享，并将共享目录映射到容器中，docker1更新文件时，docker2实现同步更新


3.3 步骤
实现此案例需要按照如下步骤进行。

步骤一：配置NFS服务器
[root@room9pc01 ~]# yum -y install nfs-utils
[root@room9pc01 ~]# mkdir /content
[root@room9pc01 ~]# vim /etc/exports
/content     *(rw，no_root_squash)
[root@room9pc01 ~]# systemctl restart nfs-server.service
[root@room9pc01 ~]# systemctl restart nfs-secure.service
[root@room9pc01 ~]# exportfs  -rv
exporting *:/content
[root@room9pc01 ~]# chmod 777 /content
[root@room9pc01 ~]# echo 11 > /content/index.html
例:
[root@docker31 ~]# yum -y install nfs-utils
[root@docker31 ~]# mkdir /content
[root@docker31 ~]# vim /etc/exports
/content  *(rw，no_root_squash)
[root@docker31 ~]# systemctl restart nfs-server.service
[root@docker31 ~]# systemctl restart nfs-secure.service
[root@docker31 ~]# exportfs -rv
[root@docker31 ~]# chmod 777 /content
[root@docker31 ~]# echo "f898989898989" > /content/index.html


步骤二：配置客户端

[root@docker1 bulid]# yum -y install nfs-utils
[root@docker1 bulid]# systemctl restart nfs-server.service
[root@docker1 bulid]# showmount -e 192.168.1.254
Export list for 192.168.1.254:
/content *
[root@docker1 ~]# mkdir /mnt/qq
[root@docker1 ~]# mount -t nfs 192.168.1.254:/content /mnt/qq
[root@docker1 ~]# ls /mnt/qq
index.html
[root@docker1 ~]# cat  /mnt/qq/index.html 
11
[root@docker1 ~]# docker run  -d -p 80:80 -v /mnt/qq:/var/www/html -it docker.io/myos:http
224248f0df5d795457c43c2a7dad0b7e5ec86abdc3f31d577e72f7929f020e01
[root@docker1 ~]# curl 192.168.1.30
11
[root@docker2 ~]# yum -y install nfs-utils
[root@docker2 ~]# showmount -e 192.168.1.254
Export list for 192.168.1.254:
/content *
[root@docker2 ~]# mkdir /mnt/qq
[root@docker2 ~]# mount -t nfs 192.168.1.254:/content /mnt/qq
[root@docker2 ~]# docker run  -d -p 80:80 -v /mnt/qq:/usr/share/nginx/html -it 192.168.1.10:5000/docker.io/myos:http
00346dabec2c7a12958da4b7fee6551020249cdcb111ad6a1058352d2838742a
[root@docker2 ~]# curl 192.168.1.31
11
[root@docker1 ~]# touch /mnt/qq/a.sh
[root@docker1 ~]# echo 22 > /mnt/qq/index.html
[root@docker2 ~]#ls  /mnt/qq/
a.sh  index.html
[root@docker2 ~]# cat /mnt/qq/index.html 
22
例:
[root@docker32 ~]# yum -y install nfs-utils
[root@docker32 ~]# systemctl restart nfs-server.service

14.architcture===============================================================================================================

architcture_day01============================================================================================================

ansible基础


什么是ansible
  ansible是2013年推出的一款∏自动化和DevOps软件,2015年被Redhat收购。是基于Python研发
   糅合很多老运维工具的优点，实现了批量操作系统配置，批量程序部署，批量运行命令等功能
  ansible可以实现:
  自动化部署APP
  自动化管理配置项
  自动化持续交付
  自动化(AWS)云服务管理


为什么选择ansible
选择一款配置管理软件，无外乎从以下几点来权衡利弊
  活跃度(社区)
  学习成本
  使用成本
  编码语言
  性能
  使用是否广泛


为什么选择 ansible(续2)
ansible优点
  只需要SSH和Python即可使用
  无客户端
  ansible功能强大，模块丰富
  上手容易，门槛低
  基于 Python开发，做二次开发更容易
  使用公司比较多，社区活跃

ansible特性
模块化设计，调用特定的模块完成特定任务
基于Python语言实现
  paramiko
  PyYAML(半结构化语言)
  Jinja2
其模块支持JSON等标准输出格式，可以采用仼何编程语言重写

ansible特性(续1)
  部署简单
  主从模式工作
  支持自定义模块
  支持 playbook
  易于使用
  支持多层部署
  支持异构∏环境

工作流程
ansible大体执行过程

=====================================================================
ansible安装

软件依赖关系
  对管理主机: 要求 Python2.6 Python2.7
ansible使用以下模块，都需要安装
  paramiko
  PyYAML
  httplib2
  six

软件依赖关系(续1)
对于被托管主机
  ansible默认通过SSH协办议管理机器
  被管理主机要开启sSh服务，允许 ansible主机登录
  在托管节点上也需要安装 Python25或以上的版本
  如果托管节点上开启了 SElinux，需要安装libselinux-python

安装 ansible(续2)
Yum安装
  把软件包拷贝到(真机)ftp共享目录中
  更新索引文件
    createrepo --update

安装及验证
  在ansible托管主机上配置yum配置文件
  安装 yum install ansible
  验证 ansible-- version

案例1：环境准备
启动6台虚拟机
 2cpu,1.5G以上内存,10G以上硬盘,1块网卡
主机名        ip地址              角色
ansible   192.168.1.40    管理主机
web1      192.168.1.41    托管主机
web2      192.168.1.42    托管主机
db1       192.168.1.43    托管主机
db2       192.168.1.44    托管主机
cache     192.168,1.45    托管主机


主机管理
主机定义与分组
安装 ansible之后可以做一些简单的任务
  ansible配置文件查找顺序
  首先检测ANSIBLE CONFIG变量定义的配置文件
  其次检查当前目录下的/ ansible。 cfg文件
  再次检查当前用户家目录下~/ ansible。 cfg文件
  最后检查/etc/ ansible/ ansible。 cfg文件
  /etc/ansible/ansible.cfg是ansible的默认配置文件路径


主机定义与分组(续1)
ansible.cfg配置文件
  inventory定义托管主机地址配置文件路径名
  inventory指定的配置文件，写入远程主机的地址

·格式
#表示注释
  [组名称]
  主机名称或p地址，其他参数

主机定义与分组(续2)
ansible.cfg配置文件
  ssh主机key验证配置参数
  host_key_checking=False
  如果为 False，不需要输入yes  
  如果为True，等待输入yes


主机定义与分组(续3)
·分组定义、范围定义样例
[webl]
 Web1
 web2
[db]
db[1:2]

[other]
 cach


ansible命令基础

ansible主机集合-m模块名称-a模块参数
  主机集合主机名或分组名，多个使用"逗号"分隔
 -m 模块名称，默认command模块
 -a or --args模块参数
其他参数
  -i inventory文件路径，或可执行脚本
  -k 使用交互式登录密码
  -e 定义变量
  -v 显示详细信息


ansible命令基础(续1)
列出要执行的主机
  ansible all --list-hosts
批量检测主机
  ansible all -m ping -k


部署证书文件
 ansible是通过SSH在远程执行命令的
 ssh远程执行命令必须要通过认证才行
 密码写入配置文件安全性很差
 使用key方式认证
 给所有主机部署公钥
   没有秘钥命令执行会出错
   ansible web -a 'uptime'


案例2：部署证书文件
1.创建一对密钥
  cd /root/.ssh
  ssh-keygen -t rsa -b 2048 -N '' -f key
2.给所有主机部署密钥
  ssh-copy-id -i key.pub 主机名称


inventory扩展参数

inventory 参数说明
  ansible_ssh_port
  ssh端口号：如果不是默认的端口号，通过此变量设置
  ansible_ssh_user
  默认的s用户名


inventory扩展参数(续1)
  inventory 参数说明
  ansible_ssh_pass
  ssh密码(这种方式并不安全我们强烈建议使用- ask-pass或SSH密钥)
  ansible_ssh_private_key_file
  ssh使用的私钥文件，适用于有多个密钥，而你不想使用SSH代理的情况

inventory扩展参数(续2)
inventory参数说明
 vars变量定义，用于组名后面
   例如
   [all:vars]
   ansible_ssh_private key_file="/root/.ssh/key"
 children子组定义，用于引用其他组名称
   例如
  [app: children]
    web
    db


inventory扩展参数(续3)
分组定义、范围定义样例
  子组定义
  [app: children]
    web
    db
变量引用
[other]
  cache ansible_ssh_port=222
[all:vars]
   ansible_ssh_private_key_file="/root/ssh/key"


inventory扩展参数(续4)
自定义配置文件
  创建文件夹 myansible
  创建配置文件 ansible.cfg
    [Defaults]
    inventory= myhost
    host_key_checking=False
  配置主机文件
   [app1]
    web1
    db1
  ansible appl--list-hosts


案例3：主机定义与分组
1.给所有主机部署key
2.在inventory文件中指定key的位置
3.配置主机分组，自定义文件，在重新定义一个新的ansible. cfa
4.在自定义的文件夹中完成之前的配置


动态主机

无限可能
ansible Inventory包含静态和动态的inventory，静态inventory指在文件/etc/ansible/hosts中指定的主机和组动态 Inventory指通过外部脚本获取主机列表，按照其要求格式返回给 ansilbe命令
Json
  JsON(JavaScript object Notation， JavaScript对象表示法)，—种基于文本独立于语言的轻量级数据交换格式

=============================================================
批量配置管理


模块
ansible-doc和ping模块
ansible-doc
  模块的手册相当与shell的man，很重要
  ansible-doc -l          #列出所有模块
  ansible-doc modulename  #查看帮助
ping模块
  测试网络连通性，ping模块没有参数
  注：测试sSh的连通性
  ansible host-pattern -m ping
例：
[root@ansible ~]# ansible-doc -l          #列出所有模块
[root@ansible ~]# ansible-doc command  #查看帮助

command模块
command模块
  默认模块，远程执行命令
用法
  ansible host-pattern -m command -a '[args]'
查看所有机器负载
  ansible all -m command -a 'uptime'
直看日期和时间
  ansible all -m command -a 'date +%F_%T'
例：
[root@ansible ~]# ansible all -m command -a 'uptime'       #查看所有管理的机器负载
[root@ansible ~]# ansible all -m command -a 'date +%F_%T'  #查看所有管理的机器日期和时间

command模块(续1)
command模块注意事项
  该模块通过-a跟上要执行的命令可以直接执行，若命令里有如下字符则执行不成功
  "<",">", "|" ,"&"
  command模块不能解析系统变量
  该模块不启动shel直接在ssh进程中执行，所有使用到shel的命令执行都会失败
  下列命令执行会失败‘
  ansible all -m command -a 'ps aux | grep ssh’
  ansible all -m command -a 'set'
例：
[root@ansible ~]# ansible all -m command -a 'ps aux | grep ssh'  #报错
[root@ansible ~]# ansible all -m command -a 'set'                #报错


she模块
shell
 shell模块用法基本和 command一样，区别是shell模块是通过/bin/sh进行执行命令，可以执行任意命令
 不能执行交互式的命令，例如 vim top等
 查看所有机器的负载
 ansible all -m shell -a ' uptime'
例：
[root@ansible ~]# ansible all -m shell -a  'uptime'  #查看所有管理机器的负载


案例4：练习理解批量执行
shell
 执行以下命令查看结果，并说明原因
  nsible web -m shell -a "echo S(HOSTNAMEI
  ansible web -m shell -a 'echo S(HOSTNAMEJ
例：
[root@ansible ~]# ansible web -m shell -a "echo ${HOSTNAME}"  #输出本机主机名
web2 | SUCCESS | rc=0 >>
ansible
web1 | SUCCESS | rc=0 >>
ansible
[root@ansible ~]# ansible web -m shell -a 'echo ${HOSTNAME}'  #输出管理主机名
web1 | SUCCESS | rc=0 >>
web1
web2 | SUCCESS | rc=0 >>
web2
[root@ansible ~]# ansible web -m command -a 'echo ${HOSTSNAME}' #用command输出${HOSTSNAME}
web1 | SUCCESS | rc=0 >>
${HOSTSNAME}
web2 | SUCCESS | rc=0 >>
${HOSTSNAME}
[root@ansible ~]# ansible web -m command -a "echo ${HOSTSNAME}" 
web1 | SUCCESS | rc=0 >>
web2 | SUCCESS | rc=0 >>

testfile 文件在哪里
  ansible cache -m shell -a 'cd /tmp
  ansible cache-m shell -a 'touch testfile'
例：



leduc
问题解答(续案例4)
达内教育
·变量解析
ansible执行命令是二次解析
第一次在本机解析，第二次在执行机器解析
知识讲解
需要第二次解析的变量要转义(\)
文件在哪里
文件在用户家目录
ansible是使用ssh多次连接执行
连接退出以后之前的状态就全部失效了
解决方法：使用chdi代替cd命令
ansible cache -m shell -a 'chdir=/tmp touch testfile
nedu.c


案例5：创建用户
添加用户
  给web1 db2添加用户nb
  设置nb的密码为123
例：
[root@ansible ~]# ansible web1,db2 -m command -a 'useradd nb'                  #给web1 db2添加用户nb
[root@ansible ~]# ansible web1,db2 -m shell -a 'echo 123 | passwd --stdin nb'  #设置nb的密码为123

思考：添加用户
给所有web主机添加用户wk
要求nb用户与wk用户不能出现在同一台主机上
设置wk用户的密码是456
例：


scripti模块
script模块
命令太复杂?
在本地写脚本，然后使用 script模块批量执行

ansible web -m script -a urscrip
注意：该脚本包含但不限于She脚本，只要指定Sha
bang解释器的脚本都可运行


案例6：练习模块
1.添加用户
2.给所有Web主机添加用户wk
3.要求nb用户与wk用户不能出现在同台主机上
4.设置wk用户的密码是456
yum模块
达内教育

yum模块
  使用yum包管理器来管理软件包
  name：要进行操作的软件包名字
  state:动作( installed, removed)
  install === installed
  remove === emoved

yum模块(续1)
yum模块
  给所有db主机安装 mariadb
   ansible db -m yum -a 'name="mariadb-server" state=installed
 cache主机删除lrzsz
   ansible cache -m yum -a 'name="lrzsz" state=removed'
例：
[root@ansible ~]# ansible db -m yum -a 'name="mariadb-server" state=installed'
[root@ansible ~]# ansible cache -m yum -a 'name="lrzsz" state=removed'  #cache是管理的主机名


service模块

name：必选项，服务名称
enabled：是否开机启动 yes|no
sleep：执行restarted，会在stop和 start之间沉睡几秒钟
state：对当前服务执行启动，停止、重启、重新加载等操
作( started, stopped, restarted, reloaded）
ansible cache -m service -a 'name="sshd" enabled="yes" state="started"'
例：
[root@ansible ~]# ansible all -m ping -k
[root@ansible ~]# ansible cache -m service -a 'name="sshd" enabled="yes" state="started"'


copy模块
复制文件到远程主机
src：复制本地文件到远程主机，绝对路径和相对路径都可路径为目录时会递归复制。若路径以"/"结尾，只复制目录
  里的内容，若不以"/"结尾，则复制包含目录在内的整个内容，类似于rsync
dest：必选项。远程主机的绝对路径，如果源文件是一个目录，那该路径必须是目录

copy模块(续1)
达内教育

copy模块
backup：覆盖前先备份原文件，备份文件包含时间信息。有两个选项： yes|no
force：若目标主机包含该文件，但内容不同，如果设置为yes，则强制覆盖，设为no，
   则只有当目标主机的目标位置不存在该文件时才复制。默认为yes
复制文件
  ansible all -m copy -a 'src=/etc/resolv.conf dest=/etc/resolv.conf'
例：
[root@ansible ~]# ansible all -m copy -a 'src=/etc/resolv.conf dest=/etc/resolv.conf'  #src表示原目录，dest表示目标目录
复制目录
  ansible all -m copy -a 'src=/etc/yum.repos.d/ dest=/etc/yum. repos/'  #src表示原目录，dest表示目标目录
例：
[root@ansible ~]# ansible all -m ping -k
[root@ansible ~]# ansible all -m copy -a 'src=/etc/yum.repos.d/ dest=/etc/yum.repos.d/'  #src表示原目录，dest表示目标目录


案例7：练习模块
  批量修改配置文件
  批量修改所有机器的dns配置/etc/ resolv。 conf
  批量同步所有机器的yum配置文件
  给所有db主机开启 binlog日志
  log_bin =mysql-bin
  binlog-format =mixed


lineinfille模块
  类似sed的一种行编辑替换模块
  path  目标文件文件
  regexp 正则表达式，要修改的行
  line  最终修改的结果
  例如修改 my.cnf,中bin-log的格式
  mixed --> row
   ansible db -m lineinfile -a 'path="/etc/my cnf" regexp="^binlog-format" line="binlog-format=row"'


replace模块
  类似sed的种行编辑替换模块
  path 目的文件
  regexp 正则表达式
  replace 替换后的结果
   替换指定字符row-->mied
  ansible db -m replace -a 'path="/etc/my.cnf" regexp="row" replace="mixed"'


案例8：模块练习
1.使用copy模块同步 my.cnf配置文件
2.使用 lineinfile模块修改binlog格式
3.使用 replace模块修改 binlog格式

setup模块
  主要用于获取主机信息，playbooks里经常会用的另一个参数 gather_facts与该模块相关，setup模块下经常用的是fter参数
filte过滤所需信息
  ansible cache -m setup -a ‘filter=ansible distribution’


architcture_day02============================================================================================================
playbook基础

ansible七种武器

第一种武器
  ansible命令，用于执行临时性的工作，必须掌握
第二种武器
  ansible-doc是ansible模块的文档说明，针对毎个模块都有详细的说明及应用案例介绍，功能和Linux系统man命令类似，必须掌握
第三种武器
  ansble-console是ansible为用户提供的交互式工具，用户可以在 ansible-console虚拟出来的终端上像Shell
  一样使用ansible内置的各种命令，这为习惯使用 shell交互方式的用户提供了良好的使用体验
第四种武器
  ansible-galaxy从github上下载管理Roles的一款工具，与python的pip类似
第五种武器
  ansible- playbook是日常应用中使用频率最高的命令，工作机制：通过读取先编写好的 playbook文件实现批量管理
  可以理解为按一定条件组成的 ansible任务集，必须掌握
第六种武器
  ansible-vaut主要用于配置文件加密，如编写的 playbook文件中包含敏感信息，不想其他人随意查看，可用它加密/解密这个文件
第七种武器
  ansible-pull
  ansible有两种工作模式pull/push，默认使用push模式工作，pull和push工作模式机制刚好相反
  适用场景：有大批量机器需要配置，即便使用高并发线程依旧要花费很多时间
  通常在配置大批量机器的场景下使用，灵活性稍有欠缺，但效率几乎可以无限提升，对运维人员的技术水平和前瞻性规划有较高要求


JSON简介
 JSON是什么
    JSON是JavaScrip对象表示法，它是一种基于文本独立于语言的轻量级数据交换格式
    JSON中的分隔符限于单引号"'"、小括号"()"、中括号"[]"、大括号”{}"、冒号"："和逗号","
 JSON特性
    JSON是纯文本
    JSON具有"自我描述性"(人类可读)
    SON具有层级结构(值中存在值)
    JSON可通过JavaScript进行解析
 JSON语法规则
    数据在名称/值对中
    数据由逗号分障
    大括号保存对象
    中括号保存数组
 JSON数据的书写格式是：名称/值对
    名称/值对包括字段名称(在双引号中)，后面写一个冒号，然后是值，例如: "诗仙”："李白"
 JSON语法规则之数组 
   { "诗人":
     ["李白”,"杜甫"，"白居易"，"李贺"]
   }
 复合复杂类型
   { "诗人":
     [{"李白：诗仙"，"年代："唐"},
      {"杜甫"："诗圣"，"年代："唐"},
      {"白居易"："诗魔"，"年代："唐"},
      {"李贺"："诗鬼”，"年代"："唐"}
     ]
   }


YAML简介

YAML是什么
  是一个可读性高，用来表达数据序列的格式
  YAML（YAML Ain't Markup language）
  YAML参考了多种语言，如：C语言、 Python、Per等，并从XML、电子邮件的数据格式中获得灵感，Clark Evans在
  2001年首次发表了这种语言，目前已有数种编程语言或脚本语言支持这种语言
YAML基础语法
  YAML的结构通过空格来展示
  数组使用" "来表示
  键值对使用"： "来表示
  YAML使用一个固定的缩进风格表示数据层级结构关系
  一般每个缩进级别由两个以上空格组成
  #表示注释
注意:
  不要使用tab，缩进是初学者容易出错的地方之一
  同一层级缩进必须对齐

YAML的键值表示方法
  采用冒号分隔
  ：后面必须有一个空格
  YAML键值对例子
  诗仙”： "李白“
  或
    ”李白“
     "诗仙”

复杂YAML的键值对嵌套
 "诗人“
 或
 "诗人”
   “李白”
    "诗仙“
 数组
  [李白”，"杜甫"，"白居易"，"李贺"]

YAML数组表示方法
  使用一个短横杠加一个空格
  YAML数组例子
   "李白"
   "杜甫"
   "白居易"
哈希数组复合表达式
  "诗人"
    -“李白”
    -"杜甫“
    -"白居易”
    -“李贺”
高级复合表达式
  "诗人“：
   -
    ”李白"："诗仙“
    ”年代”："唐”
   -
    "杜甫"："诗圣“
    ”年代”："唐”
   -
    "白居易"："诗魔
    ”年代”："唐“
   -
    ”李贺∵：诗鬼”
    “年代”："唐


Jinja2模版简介

Jinja2是什么
  Jnja2是基于Python的模板引擎，包含变量和表达式两部分，两者在模板求值时会被替换为值，模板中还有标签，控制模板的逻辑
为什么要学习Jina2模版
   因为playbook的模板使用Python的Jinja2模块来处理

Jinja2模版基本语法
  模板的表达式都是包含在分隔符"{(}"内的
  控制语句都是包含在分隔符"{% %}"内的
  模板支持注释，都是包含在分隔符"{# #}"內，支持块注释
  调用变量
   {{Rivarnamel}}
  计算
   {{2+3}}
  判断
   {{1 in[1,2,3]}}
  Jinja2模版控制语句
    {% if name == '诗仙' %}
      李白
    {% elif name == "诗圣" %}
      杜
    {% elif name == "诗魔" %}
      白居易
    {% else %}
      李贺
    {% endif %}


Jinja2模版控制语句
  {% if name == ......%}
  {% elif name =='于谦' %}
    {% for method in [抽烟，喝酒，烫头] %}
    {{do methodl}}
    {% endfor %}
    ......
   {endif %}


Jna2过滤器
  变量可以通过过滤器修改。过滤器与变量用管道符号(|)分割，也可以用圆括号传递可选参数，多个过滤
  器可以链式调用，前一个过滤器的输出会被作为后个过滤器的输入
例：
加密个字符串：{( astr'lpassword_hash(sha512)
过滤器这里不再—列举，需要的可以查询在线文档
http://docs.jinkan.org/docs/jinja2/templates.html
#builtin-filters


playbook是什么
  playboyαk是 ansible用于配置，部署和管理托管主机剧本，通过 playbook的详细描述，执行其中的一系列tasks，可
  以让远端主机达到预期状态
  也可以说， playbook字面意思即剧本，现实中由演员按剧本表演，在 ansible中由计算机进行安装，部署应用提供对外服务，
  以及组织计算机处理各种各样的事情

为什么要使用playbook
  执行些简单的任务，使用ad-hoc命令可以方便的解决问题，但有时一个设施过于复杂时，执行ad-hoc命令是不合适的，最好使用 playbook
  playbook可以反复使用编写的代码，可以放到不同的机器上面，像函数一样，最大化的利用代码，在使用 ansible的过程中，处理的大部分操作都是在编写playbook


playbook语法基础
playbook语法格式
  playbook由YAML语言编写，遵循YAM标准
  在同一行中，#之后的内容表示注释
  同一个列表中的元素应该保持相同的缩进
  playbook由一个或多个play组成
  play中 hosts， variables， roles， tasks等对象的表示方法都是键值中间以"："分隔表示
  YAML还有一个小的怪癖，它的文件开始行都应该是这是YAML格式的一部分，表明一个文件的开始

playbook构成
  hosts：定义将要执行playbook的远程主机组
  vars：定义playbook运行时需要使用的变量
  tasks：定义将要在远程主机上执行的任务列表
  handlers：定义task执行完成以后需要调用的任务

playbook执行结果
  使用ansible-playbook运行playbook文件，输出内容JSON格式，由不同颜色组成便于识别
  绿色代表执行成功
  ***代表系统代表系统状态发生改变
  红色代表执行失败

第一个playbook
---         #第一行，表示开始
- hosts:all
  remote_user: root
  tasks:
ansible-playbook myping yml -f 5
-f并发进程数量，默认是5
hosts行内容是一个(多个)组或主机的 patterns，以逗号为分隔符
remote_user账户名
例：
[root@ansible ~]# vim ping.yml
---
- hosts: all         #主机的集合
  remote_user: root  #远程主机用户
  tasks:             #命令的集合
     - ping:   
[root@ansible ~]# ansible-playbook ping.yml


tasks
 命令的集合
 每个play包含了一个task列表(任务列表)
 一个task在其所对应的所有主机上(通过 host pattern匹配的所有主机)执行完毕之后，下—个task才会执行

hosts
 主机的集合
 定义要执行任务的主机

playbook执行命令
 给web主机添加用户z3
 设置默认密码123，并把z3用户添加到 users组
---
- hosts: web
  remote_user:root
  tasKs:
    - name: create user z3
      user:
      name: z3
      group:users
   - name: set password
      shell: echo 123 | passwd --stdin z3
例：
[root@ansible ~]# ansible-playbook user.yml  #输出结果
---
- hosts: web
  remote_user: root
  tasks:
    - name: create user zhai  #创建用户
      user:
        name: zhai
        group: users
    - name: set password
      shell: echo 123 | passwd --stdin zhai   #为用户zhai设置密码
[root@ansible ~]# ansible-playbook user.yml   #输出结果


练习1： playbook练习
1.所有Web主机安装 Apache
2.修改配置文件的监听端口为8080
3.设置默认主页 hello world
4.启动服务
5.设置开机自启
例：
[root@ansible ~]# vim /root/index.html  #先创建一个页面
hello world
[root@ansible ~]# vim http.yml  
---
- hosts: web
  remote_user: root
  tasks:
    - name: install one specific version of Apache
      yum:
        name: httpd   #安装Apache
        state: installed
    - lineinfile:
        path: /etc/httpd/conf/httpd.conf
        regexp: '^Listen '
        line: 'Listen 8080'  #修改端口为8080
    - replace:
        path: /etc/httpd/conf/httpd.conf
        regexp: '^#(ServerName).*'   #配置ServerName
        replace: '\1 localhost'
    - service:
        name: httpd
        enabled: yes  #开机自启
        state: restarted
    - copy:
        src: /root/index.html   #修改主页，可以自己写个页面
        dest: /var/www/html/index.html
[root@ansible ~]# ansible-playbook http.yml  #输出结果
测试
[root@ansible ~]# curl 192.168.1.111:8080
hello world
[root@ansible ~]# curl 192.168.1.126:8080
hello world
[root@web1 ~]# apachectl -t
Syntax OK


===================================================================================================
1 练习1：playbook练习
1.1 问题

本案例要求：

    安装Apache并修改监听端口为8080
    修改ServerName配置，执行apachectl -t命令不报错
    设置默认主页hello world
    启动服务并设开机自启

1.2 步骤

实现此案例需要按照如下步骤进行。
步骤一：playbook的ping脚本检测
[root@ansible ~]# vim ping.yml
---
- hosts: all         #all表示所有主机
  remote_user: root  #远程主机用户
  tasks:
     - ping:   
[root@ansible ~]# ansible-playbook ping.yml
注意：如果检测的时候出错，会在当前的目录生成一个新的文件（以.retry结尾），可以去这个文件里面看是哪个主机的错


2 案例2：变量练习

2.2 步骤

实现此案例需要按照如下步骤进行。

步骤一：使用user模块添加用户，并修改密码
[root@ansible ansible]# vim user.yml
    ---
    - hosts: cache
      remote_user: root
      vars:
        username: xiaoming
      tasks:
        - name: create user "{{username}}"
          user: group=wheel uid=1000 name={{username}}
        - shell: echo 123456 | passwd --stdin xiaoming
        - shell: chage -d 0 {{username}}
[root@ansible ansible]# ansible-playbook user.yml  #执行结果


=======================================================================================================
playbook进阶


语法进阶
变量
添加用户
给web主机添加用户l4，设置默认密码123
---
- hosts: web
  remote_user:root
  vars:
     username: l4
  taske: 
  - name: create user username
   user: 
   name: "{{username}}"
  - shell: echo 123 | passwd -stdin "{{username}}"
例：
[root@ansible ~]# vim user01.yml   #给web1主机创建用户zhaiyanquan
---
- hosts: web1   #web1主机
  remote_user: root
  vars:
   username: zhaiyanquan
  tasks:
    - name: create user "{{username}}"
      user:
         name: "{{username}}"
    - shell: echo 123456 | passwd --stdin "{{username}}"  #设置用户密码
[root@ansible ~]# ansible-playbook user01.yml             #执行结果


变量(续1)
设密码
  解决密码明文问题
  user模块的 password为什么不能设置密码呢
  经过测试发现， password是把字符串直接写入shadow，并没有改变，而Linux的shadow密码是经过加密的,所以不能使用
解决方案
变量过滤器password_hash
  {{'furpassword' | password_hash('sha512')}}


变量(续2)
变量过滤器
给db主机添加用户plj，设置默认密码123qqq…A
- hosts: db
  remote_user: root
  vars:
     username: plj
  tasks:
    - name: create user "{{username}}"
  user: 
    password=(('123qqq...A' | password_hash('sha512')}}
    name={{username}}
例：
[root@ansible ~]# vim user02.yml
---
- hosts: db
  remote_user: root
  vars:
    username: zyq 
  tasks:
    - name: create user "{{username}}"  #创建用户
      user:
        password={{'zhaiyanquan' | password_hash('sha512')}}  #给用户设置秘密
        name={{username}}
[root@ansible ~]# ansible-playbook user02.yml


变量(续3)
变量参数
 传递参数
 -e 参数
 参数格式必须是json或yaml
 yaml格式可以使用参数文件，例如
 args.yml
  ---
  username
  nb
  - e @args.yml
例：


案例2：变量练习
1.练习使用user模块添加用户
2.练习使用变量简化task，让play通用性更强
3.练习使用过滤器


error
ansible-playbook对错误的处理
  默认情况判断$?，如果值不为0就停止执行
  但某些情况我们需要忽略错误继续执行
  例如 创建缓存目录，然后重启apache
  ---
  - hosts: cache
  remote_user: root
  tasks:
  - shell: mkdir /tmp/cache
  - name: Restartservicehttpd
  service: 
    name: httpd
    state: restarted


eror(续1)

错误处理方法
  ignore_errors：对错误的处理方式
  True 表示忽略错误继续执行
  False 表示遇到错误就停止执行
  默认 False
  处理方式
  - name: run some command
    shell: /usr/bin/somecomman
    ignore_errors: True


tags
tags：给指定的任务定义一个调用标识
使用格式:
  - name: NAME
  module: arguments
  tags: TAG_ID
playbook调用方式
 - t TAGS,--tags=TAGS


tags(续1)

修改htd配置的yml
task:
 - copy:
  src: httpdconf
  dest: /etc/httpd/cont/httpd.conf
  owner: apache
  group: apache
  mode: 0644
 - copy:
  src: index.html
  dest: /var/www/html/index.html
  owner: apache
  group: apache
  mode: 0644


tags(续2)
设置tags标记
  tasks:
    - copy: 
    src: httpdconf
    dest: /etc/httpd/conf/httpd.conf
    owner: apache
    group: apache
    mode: 0644
    tags: syncon
调用标记
  ansible-playbook conf.yml -t syncconf


handlers
 当关注的资源发生变化时采取的操作
 notify这个 action可用于在每个play的最后被触发知这样可以避免有多次改变发生时每次都执行指定的操
 作，取而代之仅在所有的变化发生完成后一次性地执行指定操作
在notify中列出的操作称为handler，即notify调用handle中定义的操作


handlers(续1)
 前面安装了Apache修改httpd的配置文件，重新载入配置文件让服务生效
 使用 handlers来实现
   handlers: 
     - name: restart apache
     service: 
     name: apache
     state: restarted


handlers(续2)
结合之前实验，使用 handlers
 - copy:
  src: httpd.conf
  dest: /etc/httpd/conf/httpd.conf
  owner: apach
  group: apache
  mode: 0644
  tags: syncon
  noify:
   - restart httpd
  handlers:
    - name: restart httpd
   servic:
      name: httpd
      state: restarted


handlers(续3)

注意事项
 notify调用的是 handler段的name定义的串，必须一致；否则达不到触发的效果
 多个tas触发同一个n的时候，同一个服务只会触发一次
 noty可以触发多个条件，在生产环境中往往涉及到某个配置文件的改变要重启若干服务的场景，handler用到这里非常适合
 结合vars可以写出非常普适的服务管理脚本


案例3： handlers练习
1.安装 Apache软件
2.配置文件，重新载入配置文件让服务生效
3.使用 handlers来实现


when
有些时候需要在满足特定的条件后再触发某一项操作，或在特定的条件下终止某个行为，这个时候需要进行条件判
断，when正是解决这个问题的最佳选择，远程中的系统变识量acts作为when的条件，可以通过 setup模块查看
 when的样例
   tashs: 
     - name: somecommand
       command: somecommand
       when: expr

when(续1)
一个使用when的例子
---
- name: Install VIM
  hosts:all
  tasks:
    - name: Install VIM via yum
      yum: name=vim-enhanced state=installed
      when: ansible_ os family =="RedHat
    - name: Install VIM via apt
      apt: name=vim state=installed
      when: ansible_os_family == "Debian"


register

有时候我们还需要更复杂的例子，如判断前一个命令的执行结果去处理后面的操作，这时候就需要eregister模块来保存前一个命令的返回状态，在后面进行调用
  - command: test command
    register: result
  - command: run command
    when: result


register(续1)

变量注册进阶
  针对运行命令结果的返回值做判定
  当系统负载超过一定值的时候做特殊处理
  ---
  - hosts: web
    remote user: root
    tasks: 
    - shell: uptime | awk '{printf("%.2f\n",$(NF-2))}'
      register: result
    - service: 
         name: httpd
         state: stopped
     when: result.stdout | float > 0.7


案例4：编写 playbook
1.把系统负载太高的 Apache服务停止



with_items
with items是 playbook标准循环，可以用于迭代一个列表或字典，通过{item}取每次迭代的值
例如创建多个用户
---
- hosts.web1
  remote——user: root
  tasks：
   - name: add users
     user: group=whee | password={{'123456' | password_hash('sha512')}} name={{litem}} with_items: ["nb","dd","plj","lx"]


with items(续1)
with items进阶
 为不同用户定义不同组
 ---
 - hosts: web2
  remote_user: root
  tasks:
  - name: add users
    user: group={{litem.group}} password={{'123456' | password_hash('sha512)}} name={{litem.name}}
   with_items
    - {name: 'nb', group: 'root'}
    - {name: 'dd', group: 'root'}
    - {name: 'pl', group: 'wheel'}
    - {name: 'lx', group: 'wheel'}


nclude and roles
在编写 playbook的时候随着项目越来越大， playbook越来越复杂，修改也很麻烦。这时可以把一些play、task或
handler放到其他文件中，通过 include指令包含进来是一个不错的选择
  tasks: 
    - include: tasks/setup yml
    - include： tasks/users.yml user=plj #users.yml中可以通过{{user}来使用这些变量
  handlers:
    - include: handlers/handlers.yml


include and roles(续1)
roles像是加强版的 Include，它可以引入一个项目的文件和目录
一般所需的目录层级有
 vars：变量层
 tasks：任务层
 handlers：触发条件
 files:文件
 template:模板
 default：默认，优先级最低


include and roles(续2)
假如有一个play包含了一个叫"x"的role，则
---
- hosts: host_group
  roles:
    - x
x/tasks/main.yml
x/vars/main ym
x/handler/main.yml
x/......main.yml
都会自动添加进这个play


debu
  对于 Python语法不熟悉的同学， playbook书写起来容易出错，且排错困难，这里介绍几种简单的排错调试方法 
 检测语法
   ansible-playbook --syntax-check playbook.yaml
 测试运行
   ansible-playbook -C playbook.yaml
显示受到影响的主机 --list-hosts
显示工作的task --list-tasks
显示将要运行的tag --ist-tags

debug(续1)

debug模块可以在运行时输出更为详细的信息，帮助我们排错
---
- hosts: web
  remote_user: root
  tasks:
  - shell: uptime | awk '{printf("%.2f\n",$(NF-2))}'
    register: result
  - service
     name: httpd
     state: stopped
   when: result.stdout | float > 0.7
   - name: Show debug info
   debug: var=result


architcture_day03============================================================================================================

分布式ELK平台


ELK简介

什么是ELK
ELK是一整套解决方案，是三个软件产品的首字母缩写，很多公司都在使用，如：Sina、携程、华为、美团等
ELK分别代表
  Elasticsearch：负责日志检索和储存
  Logstash：负责日志的收集和分析、处理
  Kiana：负责日志的可视化
这三款软件都是开源软件，通常是配合使用，而且又先后归于 Elastic。cO公司名下，故被简称为ELK

ELK能做什么
 ELK组件在海量日志系统的运维中，可用于解决
   分布式日志数据集中式查询和管理
   系统监控，包含系统硬件和应用各个组件的监控
   故障排查
   安全信息和事件管理
   报表功能


Elasticsearch

Elasticsearch部分
  ElasticSearch是一个基于 Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于RESTful AP的Web接口
  Elasticsearch是用ava开发的，并作为 Apache许可条款下的开放源码发布，是当前流行的企业级搜索引
  擎。设计用于云计算中，能够达到实时搜索，稳定可靠，快速，安装使用方便

Elasticsearch部分(续1)
主要特点
  实时分析
  分布式实时文件存储，并将每个字段都编入索引
  文档导向，所有的对象全部是文档
  高可用性，易扩展，支持集群( Cluster)、分片和复制( Shards和 Replicas)
接口友好，支持JSON

Elasticsearch部分(续2)
ES没有什么
  Elasticsearch没有典型意义的事务
  Elasticsearch是—种面向文档的数据库
  Elasticsearch没有提供授权和认证特性

Elasticsearch部分(续3)

相关概念
  Node：装有一个ES服务器的节点
  Cluster：有多个Node组成的集群
  Document：一个可被搜索的基础信息单元
  Index：拥有相似特征的文档的集合
  Type：-个索引中可以定义一种或多种类型
  Fled：是ES的最小单位，相当于数据的某一列
  Shards：索引的分片，每个分片就是个 Shard
  Replicas：索引的拷贝


sQL与NoSQL
ES与关系型数据库的对比
  在ES中，文档归属于种类型(type)，而这些类型存在于索引( index)中，类比传统关系型数据库
DB-> Databases -> Tables -> Rows -> Columns
关系型   数据库       表       行        列
ES-> Indices - Types ->Documents -> Fields
ES     索引     类型       文档        域(字段)

SQL与 NOSQL(续1)

ES与关系型数据库的对比
Relational database      Elasticsearch
Database                    lndex
Table                       Type
Row                         Document                    
Column                      Field                       
Schema                      Mapping                    
lndex                       Everything is indexed
SQL                         Query DSL
SELECT·FROM table...        Gethttp://...
UPDATE table SET            PUThttp://...


==================================================================================
Elasticsearch架构图


ES基础

ES集群安装
安装第一台ES服务器
  设置主机名称和对应关系
  解决依赖关系
  安装软件包
  修改配置文件
  启动服务
  检查服务


案例1：ES集群安装
1.准备1台虚拟机
2.部署 elasticsearch第一个节点
3.访问9200端口查看是否安装成功


ES集群安装(续1)
设置ip与主机名称对应关系
  配置/etc/hosts
   192.168.1.51 es1
例：
[root@es ~]# echo "192.168.1.137 es" >> /etc/hosts

安装JDK
  Elasticsearch要求至少Java 7
  一般推荐使用 OpenJDK 1.8
  配置好安装源以后，我们先解决依赖关系
    yum install -y java-1.8.0-openjdk
例：
[root@room212pc4 ~]# cp -r /elk /var/ftp/       #在真机操作
[root@room212pc4 ~]# createrepo /var/ftp/elk    #在真机操作
[root@es01 ~]# cat /etc/yum.repos.d/local.repo  #搭建yum，在虚拟机操作
[local_repo]
name=CentOS-$releasever - Base
baseurl="ftp://192.168.1.254/centos-1804"
enabled=1
gpgcheck=0
[elk]
name=my_elk
baseurl="ftp://192.168.1.254/elk"
enabled=1
gpgcheck=0
[root@es ~]# yum install -y java-1.8.0-openjdk


Es集群安装(续2)
安装ES
  yum -y install elasticsearch
修改配置文件
  elasticsearch yml
    network.host: 0.0.0.0
例：
[root@es ~]# yum -y install elasticsearch
[root@es ~]# vim /etc/elasticsearch/elasticsearch.yml
54 network.host: 0.0.0.0

ES集群安装(续3)
启动服务
 启动服务并设开机自启
  systemctl enable elasticsearch
  systemctl start elasticsearch
验证
  netstat-ltunp
能够看到9200,9300被监听
例：
[root@es ~]# systemctl restart elasticsearch  #重启服务
[root@es ~]# systemctl enable elasticsearch   #设置为开机自启
[root@es ~]# netstat -ltunp                   #验证


案例2：ES集群安装配置
1.一共安装5台虚拟机
2.在所有机器中部署ES
3.启动服务查看验证集群状态

ES集群安装(续4)
通过浏览器或cur访问9200端口
curl http://192.168.1.51:9200/
{
cluster_name": melk
verslon
" number":"2.3.4"
build hash
e455fdoc13dceca8dbbdbb1665d068ae55dabe3f
build_ timestamp":"2016-06-30711:24:31z
build snapshot": false,
"lucene version":5.5.0
tagline": You Know, for Search
}
例：
[root@es ~]# curl http://192.168.1.51:9200
{
  "name" : "Gavel",
  "cluster_name" : "elasticsearch",
  "version" : {
    "number" : "2.3.4",
    "build_hash" : "e455fd0c13dceca8dbbdbb1665d068ae55dabe3f",
    "build_timestamp" : "2016-06-30T11:24:31Z",
    "build_snapshot" : false,
    "lucene_version" : "5.5.0"
  },
  "tagline" : "You Know, for Search"
}


ES集群配置
  ES集群配置也很简单，只需要对配置文件做少量的修改即可，其他步骤和单机完全一致
  ES集群配置文件
    cluster.name: myelk
    node.name:es1
    network.host: 0.0.0.0
    discovery.zen.ping.unicast.hosts:["es1","es2","es3"]
例：
[root@es01 ~]# vim /etc/elasticsearch/elasticsearch.yml
17 cluster.name: myelk
23 node.name: es01
54 network.host: 0.0.0.0
68 discovery.zen.ping.unicast.hosts: ["es01", "es02","es03"]
[root@es ~]# systemctl restart elasticsearch  #重启服务
[root@es ~]# systemctl enable elasticsearch   #设置为开机自启


ES集群配置(续1)
ES集群配置
  集群中的所有节点要相互能够ping通，要在所有集群机器上配置/etc/hosts中的主机名与ip对应关系
  集群中所有机器都要安装Java环境
  cluster.name集群名称配置要求完全—致
  node.name为当前节点标识，应配置本机的主机名
  discovery为集群节点机器，不需要全部配置
   配置完成以后启动所有节点服务


ES集群配置(续2)
ES集群配置
 验证集群，使用ES内置字段 cluster/health
 curl http://192.168.1.51:9200/_cluster/health?pretty
 {
 "cluster name": melk
 status: green
 timed out". false
 "number of nodes
 "number of data nodes
 "active_shards_percent_as_number": 100.0
 }
例：
[root@es01 ~]# curl http://192.168.1.51:9200/_cluster/health?pretty
{
  "cluster_name" : "myelk",
  "status" : "green",
  "timed_out" : false,
  "number_of_nodes" : 5,       #表示集群中节点的数量
  "number_of_data_nodes" : 5,  #数据节点数量
  "active_primary_shards" : 0,
  "active_shards" : 0,
  "relocating_shards" : 0,
  "initializing_shards" : 0,
  "unassigned_shards" : 0,
  "delayed_unassigned_shards" : 0,
  "number_of_pending_tasks" : 0,
  "number_of_in_flight_fetch" : 0,
  "task_max_waiting_in_queue_millis" : 0,
  "active_shards_percent_as_number" : 100.0
}


ES集群配置(续3)

ES集群验证
 返回字段解析
 tatus ":" green " 集群状态，绿色为正常，黄色表示有问题但不是很严重，红色表示严重故障
 "number_of_nodes":5，表示集群中节点的数量
   "number of data nodes": 5
    ............
   "task_max_waiting_in_queue_millis":O,
   "active shards percent as number": 100.0


===================================================================
ES插件的使用

ES常用插件
head插件
  它展现ES集群的拓扑结构，并且可以通过它来进行索引(Index)和节点(Node)级别的操作
  它提供组针对集群的查询API，并将结果以json和表格形式返回
  它提供一些快捷菜单，用以展现集群的各种状态


案例4：练习插件
1.在其中一台机器上部署插件
2.使用bigdesk查看集群状态
3.使用head创建index
4.使用kopf查看数据

ES插件的使用(续1)
ES常用插件
kopf插件
  是一个ElasticSearch的管理工具
  它提供了对ES集群操作的API
bigdesk插件
  是elasticsearch的一个集群监控工具
  可以通过它来查看es集群的各种状态，如：cpu、内存使用情况，索引数据、搜索情况http连接数等


ES插件的使用(续2)
ES插件安装、查看
查看安装的插件
  /usr/share/elasticsearch/bin/plugin list
   安装插件
  /usr/share/elasticsearch/bin/plugin install ftp:192.168.1.254/head.zip
  /usr/share/elasticsearch/bin/plugin instal file:///tmp/kopf.zip
这里必须使用ul的方式进行安装，如果文件在本地我们也需要使用file：//的方式指定路径，例如文件在
/tmp/XXX下面，我们要写成file：///tmp/xxx，删除使用remove指令
例：
步骤一：部署插件
插件装在哪一台机器上，只能在哪台机器上使用（这里安装在es5机器上面）
1）使用远程 uri 路径可以直接安装
[root@es01 ~]# cd /usr/share/elasticsearch/bin
[root@es01 bin]# ./plugin install ftp://192.168.1.254/elk/elasticsearch-head-master.zip  #安装head插件
[root@es01 bin]# ./plugin install ftp://192.168.1.254/elk/elasticsearch-kopf-master.zip  #安装kopf插件
[root@es01 bin]# ./plugin install ftp://192.168.1.254/elk/bigdesk-master.zip             #安装bigdesk插件     
[root@es01 bin]# ./plugin list                                                           #查看安装的插件
[root@es01 ~]# /usr/share/elasticsearch/bin/plugin list                                  #查看安装的插件
Installed plugins in /usr/share/elasticsearch/plugins:
    - head
    - kopf
    - bigdesk

2）访问head插件(在真机操作)
[root@zyq ~]# firefox http://192.168.1.51:9200/_plugin/head


3）访问kopf插件(在真机操作)
[root@zyq ~]# firefox http://192.168.1.51:9200/_plugin/kopf

4）访问bigdesk插件(在真机操作)
[root@zyq ~]# firefox http://192.168.1.51:9200/_plugin/bigdesk


====================================================================================================
扩展插件

扩展插件  RESTfuL API RESTful API调用

RESTful API

HTTP协议简介
http请求由三部分组成
  分别是：请求行、消息报头、请求正文
  请求行以一个方法符号开头，以空格分开，后面跟着请求的∪R和协议版本，格式如下:
     Method Request-URI HTTP-Version CRLF

HTTP协议简介(续1)
http请求方法
  常用方法GET，POST，HEAD
  其他方法 OPTIONS,PUT，DELETE，TRACE和CONNECT
ES常用
  PUT      ---增
  DELETE   ---删
  POST     ---改
  GET      ---查
curl 命令连接使用ES数据库
PUT 方法增加数据
POST 修改数据
GET 查询数据
DELETE 删除数据
例：
步骤一：增加数据
[root@es01 ~]# curl -X PUT "http://192.168.1.51/tedu/teacher/1" -d '{
> "职业":"诗人",
> "名字":"李白",
> "称号":"诗仙",
> "年代":"唐"
> }'

步骤二：修改数据
[root@es01 ~]#  curl -X PUT "http://192.168.1.51:9200/tedu/teacher/1" -d '{
>  "doc":{
> "年代": "唐代"
> }
> }'

步骤三：查询数据
[root@es01 ~]# curl -X GET "http://192.168.1.51:9200/tedu/teacher/3?pretty"
{
  "_index" : "tedu",
  "_type" : "teacher",
  "_id" : "3",
  "found" : false
}

步骤四：删除数据
[root@es01 ~]# curl -X DELETE "http://192.168.1.51:9200/tedu/teacher/3?pretty"
{
  "found" : false,
  "_index" : "tedu",
  "_type" : "teacher",
  "_id" : "3",
  "_version" : 1,
  "_shards" : {
    "total" : 2,
    "successful" : 2,
    "failed" : 0
  }
}

步骤五：删除索引
[root@es01 ~]# curl -X DELETE http://192.168.1.55:9200/tedu/  #删除索引
[root@es01 ~]# curl -X DELETE http://192.168.1.51:9200/*      #删除所有索引

导入数据
步骤一：导入数据
使用POST方式批量导入数据，数据格式为json，url 编码使用data-binary导入含有index配置的json文件
[root@zyq ~]# scp /var/ftp/elk/*.gz root@192.168.1.56:/root/
[root@kibana ~]# gzip -d logs.jsonl.gz
[root@kibana ~]# curl -X POST "http://192.168.1.51:9200/_bulk" --data-binary @logs.jsonl

2）使用GET查询结果
[root@kibana ~]# curl -XGET 'http://192.168.1.51:9200/_mget?pretty' -d '{
>  "docs":[
>  {
>         "_index":"shakespeare",
>         "_type:":"act",
>         "_id":0
> },
> {
>         "_index":"shakespeare",
>         "_type:":"line",
>         "_id":0
> },
> {
>         "_index":"tedu",
>         "_type:":"teacher",
>         "_id":25
> }
> ]
> }'
#查询的结果
{
  "docs" : [ {
    "_index" : "shakespeare",
    "_type" : null,
    "_id" : "0",
    "error" : {
      "root_cause" : [ {
        "type" : "index_not_found_exception",
        "reason" : "no such index",
        "index" : "shakespeare"
      } ],
      "type" : "index_not_found_exception",
      "reason" : "no such index",
      "index" : "shakespeare"
    }
  }, {
    "_index" : "shakespeare",
    "_type" : null,
    "_id" : "0",
    "error" : {
      "root_cause" : [ {
        "type" : "index_not_found_exception",
        "reason" : "no such index",
        "index" : "shakespeare"
      } ],
      "type" : "index_not_found_exception",
      "reason" : "no such index",
      "index" : "shakespeare"
    }
  }, {
    "_index" : "tedu",
    "_type" : null,
    "_id" : "25",
    "error" : {
      "root_cause" : [ {
        "type" : "index_not_found_exception",
        "reason" : "no such index",
        "index" : "tedu"
      } ],
      "type" : "index_not_found_exception",
      "reason" : "no such index",
      "index" : "tedu"
    }
  } ]
}



系统命令curl
在inux中cu是一个利用URL规则在命令行下工作的文件传输工具，可以说是一款很强大的h命令行工
具。它支持多种请求模式，自定义请求头等强大功能是一款综合工具

curl常用参数介绍
  -A 修改请求 agent
  -Ⅹ 设置请求方法
  -i 显示返回头信息

RESTfuL AP调用
Elasticsearch提供了一系列 RESTful的API
  检查集群、节点、索引的健康度、状态和统计
  管理集群、节点、索引的数据及元数据
  对索引进行CRUD操作及查询操作
  执行其他高级操作如分页、排序、过滤等
POST或PUT数据使用son格式

RESTful API调用(续1)
JSON
  JSON( Javascript Object Notation)，意思是JavaScript对象表示法，它是种基于文本独立于语言的轻量级数据交换格式。
  JSON格式
  数组["aa","bb","cc"]
  键值对{key：value}

ReSTfuL API调用(续2)
RESTful ap的简单使用
 _cat API查询集群状态，节点信息
 V参数显示详细信息
   http://192.168.1.51:9200/cat/health?v
 help显示帮助信息
   http://192.168.1.51:9200/cat/health?help
例：
在真机操作
[root@zyq ~]# firefox http://192.168.1.51:9200/_cat/health?v     #参数显示详细信息
[root@zyq ~]# firefox http://192.168.1.51:9200/_cat/health?help  #显示帮助信息

RESTful APi调用(续3)

Rest API的简单使用
nodes查询节点状态信息
  http://192.168.1.51:9200/_cat/nodes?v
索引信息
  http://192.168.1.51:9200/_cat/indices?v
例：
[root@zyq ~]# firefox http://192.168.1.51:9200/_cat/nodes?v     #查询节点状态信息
[root@zyq ~]# firefox http://192.168.1.51:9200/_cat/indices?v   #索引信息


案例5：插入，增加，删除查询数据
1.使用cur命令连接使用ES数据库
2.使用PUT方法增加数据
3.使用POST修改数据
4.使用GET查询数据
5.使用DELETE删除数据

RESTful API调用(续4)

RESTful API增加
创建一个索引，并设置分片数量与副本数量
 curl -XPUT 'http://192.168.1.55:9200/tedu/' -d '{
   "settings":{
       "index":{
           "number_of_shards": 5,
            "number_of_replicas": 1
           }
        }
    }'
例：
[root@es01 ~]# curl -XPUT 'http://192.168.1.51:9200/tedu/' -d '{
> "settings":{
> "index":{
> "number_of_shards": 5,
> "number_of_replicas": 1
>   }
>    }
>     }'


RESTful API调用(续5)
RESTful AP插入数据
  (增)加数据，使用PUT方法
  调用方式：数据库地址傃索引/类型id值
   curl-XPUT 'http://192.168.1.55:9200/tedu/teacher/1' -d '{
      "职业"："诗人"
      "名字"："李白"
      "称号"："诗仙"
    }'
例：
[root@es01 ~]# curl -XPUT 'http://192.168.1.55:9200/tedu/teacher/1' -d '{
      "职业"："诗人"
      "名字"："李白"
      "称号"："诗仙"
    }'


RESTful API调用(续6)
POST修改
  修(改)数据，使用POST方法
  在修改数据的时候必须调用_update关键字
  调用方式：数据库地址索引/类型/id值/_update
  curl -XPOST 'http://192.168.1.51:9200/tedu/teacher/3/_update' -d '{
     "doc":{
          "年代∵："唐代"
       }
   }'
例：
[root@zyq ~]# curl -XPOST 'http://192.168.1.51:9200/tedu/teacher/3/_update' -d '{
>      "doc":{
>           "年代∵："唐代"
>        }
>    }'


RESTful api调用(续6)
(查)查询
  查询使用GET方法，GET为默认方法
  查询显示结果时候可以用 pretty规范显示格式
  多条查询需要使用_mget关键字配合json调用
    curl -XGET 'http://192.168.1.55:9200/tedu/teacher/1'
(删)除
  删除时候可以是文档，也可以是库，但不能是类型
   curl -XDELETE 'http://192.168.1.55:9200/tedu/teacher/1'
   curl  -XDELETE 'http://192.168.1.55:9200/tedu'
例：
[root@zyq ~]# curl -XGET 'http://192.168.1.55:9200/tedu/teacher/1'  #查询
[root@zyq ~]# curl -XDELETE 'http://192.168.1.55:9200/tedu/teacher/1' 
[root@zyq ~]# curl -XDELETE 'http://192.168.1.55:9200/tedu'


批量导入数据
使用_buk批量导入数据
  批量导入数据使用POST方式，数据格式为json，url编码使用data-binary
  导入含有nde配置的son文件
   #gzip-d logs.json.gz
   #curl -XPOST 'http://192.168.1.51:9200/bulk' --data-binary
    @logs.jsonl


map映射
mapping
  映射：创建索引的时候，可以预先定义字段的类型及相关属性
  作用：这样会让索引建立得更加的细致和完善
  分类：静态映射和动态映射
  动态映射：自动根据数据进行相应的映射
  静态映射：自定义字段映射数据类型


案例6：批量导入数据
1.使用cur命名为集群批量导入数据


===============================================================================
ag / -g 文件名     ==》  find / -name 文件名    #使用
ag类似grep 和 find，但是执行效率比后两者高。
ag -g <File Name> 类似于 find . -name <File Name>
ag -i PATTERN： 忽略大小写搜索含PATTERN文本
ag -A PATTERN：搜索含PATTERN文本，并显示匹配内容之后的n行文本，例如：ag -A 5  abc会显示搜索到的包含abc的行以及它之后5行的文本信息。
ag -B PATTERN：搜索含PATTERN文本，并显示匹配内容之前的n行文本
ag -C PATTERN：搜索含PATTERN文本，并同时显示匹配内容以及它前后各n行文本的内容。
ag --ignore-dir <Dir Name>：忽略某些文件目录进行搜索。
ag -w PATTERN： 全匹配搜索，只搜索与所搜内容完全匹配的文本。
ag --java PATTERN： 在java文件中搜索含PATTERN的文本。
ag --xml PATTERN：在XML文件中搜索含PATTERN的文本。

